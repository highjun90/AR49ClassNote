  - 구조화버퍼를 사용하는 이유
    덩치가 큰데이터는 상수버퍼로는 활용이 어려워서 어쩔수 없이 텍스처에 그 큰 데이터를 넘기는 경우가 많았다. 
    이제는 텍스처 레지스터에다 넘기는 전용 버퍼를 따로 만들었다. 그게 구조버퍼. 텍스처 레지스터에 바인딩해서 렌더링할때 사용한다.
 
  - CStructuredBuffer
   상수버퍼니 인덱스버퍼니 모든 버퍼는 ID3D11Buffer 클래스 형이다. 다만 DESC에서 그 성질을 기술하면 그제서야 이 버퍼의 용도가 정해지는 것이다.

  - enum class SB_TYPE -> 'Structured Buffer'
    디폴프는 read only.

 - MiscFlags ('Miscellaneous flag')
   평소 안쓰는건데 구조버퍼는 이용함.
 - StructureByteStride = m_ElementSize;
   이것도 딴버퍼는 잘 안쓰는데 구조버퍼는 이용

 - 초기값을 넣어주고 싶은땐 시스템 메모리버퍼를 인자로 넘긴다( 구조화버퍼의 Create()함수 맨 마지막인자)

 - 구조버퍼는 텍스처레지스터에 바인딩할것인데 딴거처럼 뷰가 꼭필요하다. 따라서 ID3D11ShaderResourceView  (쉐이더리소스뷰)가 꼭 필요하다.
   딴 버퍼들도 부모 다 따라가면 ID3D리소스객체임
  
 - 역시 HLSL에서 버퍼가 16바이트 단위로 쓰이니까 구조버퍼도 16바이트 단위가 아니면 create()함수 부터 오류가 날것이다.
   assert()로 _ElementSize가 16으로 안 나눠 떨어지면 예외뜨게함.

? RenderMgr의 정확한 역할
 여기에 구조버퍼 create 실험했음

 - 기존에는 머터리얼(재질)로 데이터를 전달하는 형태가 고정되어 있었다.(상수버퍼를 통해.)
   구조화버퍼는 이제 미리 데이터의 형태를 고정시켜 놓을 필요하 없어졌다.

** Vec4와 HLSL의 float4가 대응되게 사용중이다

 - HLSL 상에서 구조화버퍼는 StructuredBuffer<float4> 로 정의함. 이때 <> 꺾쇠안의 데이터 자료형은 바뀔 수 있음
 
 - 구조화버퍼는 정말 필요한가? 이거 쓰면 장점이 뭐임?
  1) 픽셀하나당 색깔을 표현하는 가장큰 표현이 float4이다. (16바이트 r32 g32 b32 a32) (보통 2바이트이긴함 R8 G8 B8 A8 )
     근데 구조화버퍼를 사용하면 그 크기를 내맘대로 설정할수 있다.
     메모리 단위만 일치하게 HLSL에서의 데이터 구조와 머터리얼의 데이터 구조를 매칭시켜주면 됨
  2) 정확히 못듣었는데 원래는 내가 전달하는 데이터의 구조를 정확히 알고있고 인덱스의 몇번째 바이트에 접근해야 거기에 색상정보가 있음을 알수있는 등 이용이 불편했는데
     구조화버퍼는 그럴 필요없이 그냥 인덱스로 접근하여 쓰는게 더 편리해졌다는 식으로 이야기함. 더 정확한 이해필요

======================================================================================================================

 - 역시 CStructedBuffer 헤더 몰라서 소멸자 호출 안되는 현상 또 있었음

 - 구조화버퍼에 지금 딩장 필요한 나중에 필요한 기능은아니지만 미리 만듭시다.
 - 구조화버퍼에서 초기화(Create함수) 할때말고, 중간에 데이터를 변경했을때 데이터를 GPU애 전달 있는 기능이 필요하다. (지금은 Create() 할때만 GPU에 구조화버퍼 내용을 전달할수있었음) -> SetData()함수

  - SetData()함수 
   - _ElememtCount가 디폴트인자(0)으로 들어오면 버퍼의 크기가 자동으로 최대로 설정하게 설계했습니다.
 
? map과 unmap 기능 
  map은 매핑

 - 이걸 가능하게 하려면 버퍼설정에서 CPUAccessFlag가 0이아니라 다이내믹 이어야함 그런데 구조화 버퍼는 다이나믹 설정이 안됨 다이나믹으로하면 애초에 버퍼가 안만들ㅇ짐
   상수버퍼는 GPU에 한번 데이터 전달하면 바뀌는 경우가 잘 없어서 이런 문제가 없었다. 
   구조화 버퍼는 변경된 데이터를 GPU에 map()함수로 전달하고 싶은데..
   그럼 어떻게한다? 버퍼를 하나 더 만들자!

   GPU는 데이터 구조가 같으면 순식간에 복사가 가능하다.

   이런 구조를 위해서 구조화 버퍼에 bool맴버 하나 더 만들자. 얘가 true면 추가적인 버퍼를 더 쓰겠다는 것이다. 읽기 버퍼와 쓰기버퍼.
   즉, 이 구조화 버퍼가 시스템 메모리와 왔다갔다 하면서 데이터 내용을 바꿉니까? 그렇다면 true. 아니면 false.
   (위에 정의된 enum class SB_Type의 read only 같은 기능과 상관없습니다. 헷갈리지마세요)

   다시말해서, 구조화버퍼의 본체는 데이터 내용을 중간에 변경할수 있는 구조로 만들지 못하니, 구조가 구조화버퍼랑 똑같은 버퍼 하나 더 만들어서 그걸 복제해서 쓰게하면 된다.
   복제는 속도가 엄청빠르니까 리소스 낭비도 심하지 않다.

   ** 이제 구조화 버퍼는 버퍼가 3개입니다. 메인버퍼, 쓰기버퍼, 읽기버퍼(한 버퍼에 읽기 쓰기 동시에 안되서 쓰기용버퍼 읽기용버퍼 따로 만들어야함 이건 어쩔수 없이 메모리가 아깝긴하지만 구조상 어쩔수없음)


 - map으로 쓰기용버퍼에 데이터 전달하면 쓰기버퍼에서 메인버퍼에 카피해줘야합니다.
   Context->CopyResource()함수
 - 거꾸로 구조화 버퍼의 내용을 읽어들이는 기능
   GetData()함수

 - 구조화버퍼의 내용을 바꾸기
   1. SetData로 쓰기버퍼에 데이터 쓰기 2. 쓰기버퍼 내용을 메인버퍼에복사
   구조화버퍼 내용을 시스템 메모리로 읽어오기
   1. GetData로 메인버퍼 내용을 읽기버퍼에 복사. 2. 읽기버퍼의 내용을 unmap()


** 지금까지 구조화 버퍼 중간에 데이터가 변경되고 그걸 GPU에 적용하고 싶을때 버퍼를 2개 더 만들어서 해결한 것을 설명함. 데이터가 중간에 안바뀌면 필요없음
   

 - 버퍼의 크기를 더 늘리고 싶으면 기존 버퍼를 삭제하고 새로 만들어야 합니다. 
   
   Create()함수에 m_SB, m_SBV, _Read, _Write 에 = nullptr; 하는 줄을 추가합니다.
   이게 아주 똑똑한 기법인게 스마트포인터이기 때문에 null 대입하면 자동으로 메모리카운트 줄여줍니다.
   이러면 따로 버퍼삭제하고 만드는 함수나 코드 추가할 필요없이 그냥 Create()함수 재호출해서 버퍼크기를 조절할 수 있게 됩니다.
   이건좀 쩌네.. 문법을 쥐어짜내서 이렇게로도 만드네


  


   
