 - 어제까지는 개별적으로 파티클 렌더링하면서 반복문을썼는데 파티클 개수가 증가할수록 draw call이 증가하므로 퍼포먼스 즉 프레임이 엄청 떨어질거에요
   이걸 인스턴싱해서 드로우콜을 줄이자. 아무리 작업량이 적어도 렌더링파이프라인 자체가 작업량이 많은 작업이므로 최대한 파이프라인을 적게 호출해야함

 - CMesh.h 에 파티클 전용렌더함수인 render_asparticle()선언.
  - CONTEXT에 DrawINdexedINstanced() 함수를 여기서 씀. 파티클 개수를 명시해주면 GPU가 알아서 한번에 파이프라인 한번으로 처리
    g_ParticleBuffer에 파티클 개수만큼의 정보가 있는데 g_int_0(CPP에 INT_0)으로 반복문 처리해서 i를 거기에 넣어서 인덱스로 알려줘서 처리
    SetScalarParam()에서 INT_0에 어떤 인덱스를 넣어줘도 UPdate에 딱 한 파티클만 업데이트 됨.
    즉 몇번째 인자를 렌더링하고 있는지 구별할 정보가 필요하다

    -> 버텍스 쉐이더 입력으로  iInstID : SV_InstanceID 추가.
       원래 항상 값0으로 들어오는데 이번파이프라인이 몇번째인지 알려줌 매번 렌더링할때마다 이 숫자가 증가.
       따라서  g_Int_0으로 구조화버퍼에 접근했는데 이젠 인스턴스 아이디로 접근한다.
       (Particle g_ParticleBuffer[g_int_0] 부분아 변경)

       이렇게 했을때 인스턴스로 일괄적으로 하면 또 문제가 렌더링하지 말아야할(Active가 false 인애들) 까지 전부 그러버림.
       그래서 그릴 파티클은 인스턴스 아이디를 앞으로 몰아주고 안그릴 애들을 뒤로 밀어서 일정 인덱스 초과하는 id값들은 안그리게 설계해야함.
       그런데 이런 방법밖에 없는건아님 PS_Particle()함수에서 조건문으로  Particle.Active 가 false면 discard 해버리는 코드추가
       그런데 이것보다도 더 최적화 가능. 픽쉘쉐이더에서 검사하지 말고 정점 쉐이더부터 검사하는거임. 우리는 지금 안쓰지만 GS(지오메트릭쉐이더)단계에서 검사해서
       레스터라이저 단계로 넘어가는 단계를 끊어버림. 즉 현재 버텍스가 비활성화하는 파티클이라면 GS에서 이 파티클은 넘기고 다음 파티클 검사하계 함

 
  - GS(지오메트릭 쉐이더의 역할)
   1) 빌보드 구현의 편의성 (빌보드 -> 화면 메쉬가 정면을 쳐다보게 편하게 한다)
   2) 담당파티클이 비활성화 상태인 경우 렌더링을 정점연산단계에서 중단시키기
    - 이걸 바로 하지 않고 빌보드 구현때 같이한다


 - 파티클을 업데이트해주는 클래스 만들기
  - fx파일 설정2개 해주는거 확인
  - particle_update.fx 와 CPartileUpdate.cpp 생성
  - 예전 기수에서 했던 코드 가져와서 이름 좀 수정하기
   
 - 파티클 업데이트 해주는 구조화 버퍼는 일차원배열이므로 쓰레드를 x축 최대치인 1024로둠. 1만개 들어오면 그룹 10개 넣어주면됨

 - 컴퓨트 쉐이더들은 에셋매니저(외부)에서 쉐이더 Create 해주지 말고 어차피 뭐할지 정해져 있는데 본인클래스의 생성자에서 Create()할게요
   그냥 코드 한줄 더 줄어든 정도. 에셋매니저에서 Create()해주는게 아니라 파티클업데이트생성자에서 Cresate()

 - 파티클시스템클래스가 파티클업데이트시스템클래스의 포인터를 멤버로보유.

 - 업데이트 받을 버퍼가 누구인지 알려주고 파티클 업데이트 하고 렌더할때 구조화버퍼 바인딩하고 인스턴스로 그리기
        
=====================================================================================================
 - CS_ParticleUpdate(uint3 id : SV_DIspatchThreadID)
   
 - 읽어들이고 값을 수정해야하기 때문에 파티클업데이트에 사용될 버퍼는 언오더드버퍼를 써야함
 - g_int_0에 파티클 최대 갯수에 대한 정보가 있어야 쓰레드가 메모리영역을 초과해서 데이터를 수정하지 않게 한다.
   cpp 파일에서 m_Const.iarr[0]에 바로 g_int_0에 들어갈 파티클 최대 개수를 넣어줌. (파티클업데이트 클래스의 UPdateData()확인)

 - 구조화버퍼도 컴퓨트쉐이더 시점에서 바인딩되는 걸 만들어야함
   텍스처 쪽 코드랑 비슷해서 복붙해줌
   UpdateData(), Update_CS_SRV(), Update_CS_UAV().
   1번쨰는 구조화버퍼가 일반적으로 레지스터에 바인딩 되는거라면
   2 3 번째는 컴퓨트쉐이더가 쓰는 구조화버퍼를 일반적인 레지스터바인딩, 그리고 언오더디드레지스터에 바인딩하는경우
   Clear()함수도 Update()처럼 3종류있음

 - 컴퓨트쉐이더는 돌려쓰는 애들이기때문에 바인딩된 구조화버퍼를 Clear()해줘야 업데이트가 안되고, 그래야 딴데서도 새로운 일 시킴
 - 그룹수 넣어주는거 빼먹을거 같아서 가상함수로 강제하겠다
   UPdateGroupCount()

 - 픽쉘쉐이더에서 인스턴스 id를 인자로 쓰는게 오류가 나서 VS_OUT에 FOG라는 시멘틱으로 인스턴스 ID대용으로 픽셀쉐이더에 전달.
   어차피 인스턴스 ID가 정수값이기 때문에 float 형식에 값 저장해도 상관없음.
   이제 PS_Particle()의 인자 _In의 멤버로 FOG가 있는걸 써서 인스턴스 아이디로 쓰게함




