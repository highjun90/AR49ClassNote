1. 지난 시간에 행렬에 위치, 크기 정보를 담는 원리를 이야기 했는데 물체의 회전정보까지 행렬에 넣는 방법도 이야기 하겠다.

 - 회전행렬은 회전축이 무엇이냐에 따라 그 형태가 조금씩 다르다. (각도에 따른 정점의 위치이동 원리는 같음)
  - 예시) z축 회전행렬
          [ c  s  0 0 ]
          | -s c  0 0 |
            0  0  1 0
            0  0  0 1
             
 - 회전행렬의 문제는 크기행렬과 겹치는 원소가 있다는 것이다. (1,1) (2,2) 등.
   그래서 먼저 크기원소를 지정하고 그 크기원소에 회전공식에 해당하는 원소를 곱해준다.
   예를들어 z축 회전행렬이 있다고할떄  1,1 2,2 원소 부분에 cos이 있는데 크기원소에 이 cos을 곱한다. 2,1이나 1,2는 크기행렬하고 회전행렬이 겹치는 원소가 없어서 그냥 그대로 둔다.
   이렇게 되면 최종적으론 정점의 크기가 먼저 증가하고, 그 그기가 증가한 정점이 회전까지 하게 된다.
   어느 축을 회전하느냐에 따라 변환행렬에서 크기,워치 행렬과 회전행렬의 겹치는 부분은 다를 수가 있다.

 - 위치, 크기, 회전값을 행렬에 일일히 직접 넣어주는게 귀찮으니 라이브러리 함수써서 넣어줄게요 인자만 제대로 넣어주면 행렬로 알아서 리턴해줌

 ** 위치,크기,회전 변환에서  크기를 먼저 적용해야하는 이유는 만약 이동먼저하고 크기를 변환하면 엉뚱한 모양이 된다. 그래서 항상 크기부터 정하고 이동시킨다.
    마찬가지로 회전도 크기보다 늦게 변환되어야한다. 크기는 이동이나 회전보다 항상 먼저 적용되야 모양이 제대로 나온다.

    why? -> 크기변환이 현재 좌표를 기준으로 그 배율만 바꾸는 것이기 때문에 원점0,0 에서 각 정점을 곱했을때는 원하는 비율대로 커지지만,
    좌표가 0,0이 아닌 다른 정점에서 크기를 키우면 크기를 키울 정점의 원래값이 아닌 이미 허수가 포함되어 있는 값을 곱한다. 그래서 동일한 비율을 곱해도 의도한 크기변환이 제대로 되질 않는다.
     예시) (3,3,3) 좌표를 x방향으로 2만큼 이동시키면 (5,3,3) 인데 크기를 2배로 늘리면 원하는 결과는 (8,6,6) 겠지만 결과는 (10,6,6)이다.
           (5,3,3)에서 x좌표에 의도하지 않은 이동수치인 2까지 포함되어서 곱해지는 것이다.. 그래서 x좌표는 ((3 x 2) +2) 의도가 아닌 (5 x 2) 로 되버림 
   
   즉 크기를 변환하는 원리인 곱하기 메커니즘을 쓰는 이상 꼭 크기변환을 먼저 해야한다. 이런 단점이 없는 다른 방식의 크기변환 방법이 있겠지만 더 복잡할것이다. 

    수학적으로도 당연한 원리이다. 행렬의 곱셈은 교환법직이 성립하지 않음. 

 *** 위와 동일한 원리로 회전이 이동보다 먼저 이루어져야한다. 이동을 먼저 시키면 회전공식에 곱해질 정점의 위치값에 허수가 포함되어 있기 때문에 원하는 형태로 회전이 이뤄지지않을 것이다.
 **** 중요) 크기, 회전, 이동순으로 변환이 이루어져야한다. 필수암기사항

2. 지금까지 한것은 로컬스페이스에서 월드스페이스로 정점의 위치를 변환하는 것이다. 이제 카메라가 보는 기준의 좌표계로 이동시키는 작업 (뷰스페이스)을 하자.

 - 물체의 방향을 축이라고 여기고 Right, up, front 정보를 m_arrDir 배열에 저장하자. 초기상태는 당연히 각각 (1,0,0) (0,1,0) (0,0,1) 이다.
   finalTick()에서 이 정보를 항상 갱신한다. 즉 물체의 방향값을 매프레임마다 갱신한다. 방향벡터의 끝점도 회전변환행렬을 적용시키면 물체의 방향도 최신으로 갱신된다.

 - XMVector3TransformCoord() 는 인자로 벡터와 매트릭스를 달라한다. XMVector3TransformNormal() 의 차이점은 첫번째 인자(벡터4)의 동차좌표(w값)를 알아서 1이나 0으로 적용시키는게 다르다. 
   그런데 4번째 동차좌표값을 1로두는 이유가 상태행렬의 이동값의 정보를 보존하기 위해서 인데 우리는 방향벡터의 이동값은 필요하지 않다. 
   만약 방향벡터에 이동값이 적용되어 버리면 벡터가 엉뚱한 방향을 가리키게된다. 방향벡터의 끝점까지 이동시키기 때문에 이상한곳을 가리키는 결과가 나온다.
   방향벡터는 제자리에서 회전된 방향만 알면된다. 

   그래서 XMVector3TransformCoord()를 쓰지않는다. coordinate는 좌표라는 의미가 있음.
   방향벡터는 XMVector3TransformNormal()을 써야한다. 이것은 회전이나 크기는 영향을 받지만 이동은 영향을 받지 않는다.(마지막 동차좌표값이 0 이므로)
   이 함수의 인자로 방향벡터와 월드스페이스 변환행렬을 넣어주면 매 틱마다 방향벡터의 회전값을 갱신시킬수있다.
  
  - XMVector3TransformNormal()은 크기 까지 가지고 있어서 노멀라이즈까지 해준다. 월드에서 크기배율이 크게되건 작게되건 상관없이 방향벡터의 크기를 항상 1로 유지하기 위함이다.


 ** 카메라가 기준이 된다는것은 무엇을 의미하는가? (월드에서 뷰스페이스의 변환은 무엇을 의미하는가?)
  1. 원점에 카메라가 있다. 
  2. 카메라 오브젝트의 front가 z축인 좌표계이다. (즉 월드에서의 z축은 카메라 입장에선 무시되는것. 카메라가 보는게 새로운 z축이 됨)
                                                 (월드는 항상 그대로 있음. 월드가 변하면 카메라도 영향 받겠지만 카메라가 바껴도 월드는 영향을 받지 않을것임)

  - 우리는 지금까지 카메라와 월드의 z값과 원점이 일치한 상태로 작업을 하고있는 것이다. 물론 직접 카메라를 명시하진 않았지만 의미적으론 그렇다.
    다시말해, 카메라 작업을 아무것도 안하면 월드스페이스가 곧 뷰스페이스랑 똑같은 상태인 것이다.

  - 이제부터는 렌더링을 카메라가 하게된다. 당연하다. 카메라가 보는 세상을 그리는 것이므로 카메라가 그려야한다.
  - 그 이전에 월드스페이스에 있는 정점들을 뷰스페이스로 옳겨야한다. 즉 월드기준으로 보이는 정점의 위치가 카메라가 보는 정점의 위치로 바뀌어야하는데 그 바꿔주는 행렬이 뷰스페이스이다.

  - 우리는 행렬을 가로순으로 읽는데 HLSL의 row_major matrix는 세로순으로 읽는다.
    (영어 그대로 해석하면 열 우선 행렬이라는 뜻이다. 우리는 행 우선 행렬을 사용중인데..)
    뭔말이냐, 2x4 행렬을
    1234
    5678
    
    이 아니라
    1357
    2468
    이렇게 읽음. (4x2 행렬로)

    이건 c++ 입장에선 전치행렬(사선을 기준으로 원소들이 대칭되는)이다.
     
    따라서 HLSL에 행렬을 보낼때 아예 전치행렬상태로 보내주던지, 아니면 HLSL에서 행우선행렬을 받아서 본인의 열우선 행렬로 바꿔줘야함



 - 카메라가 이동하면 물체는 어떻게 화면에서 보일까? 
   예를들어 정중앙에 있던 물체가 있다고 치자. 만약 카메라가 오른쪽으로 이동하면 최종화면에는 왼쪽에 물체가 보일것이다.
   이렇듯 카메라가 이동하면 물체는 그 정 반대로 이동한걸로 보이게 된다. 다시말해 카메라 이동값에 -를 붙여주고 그것을 물체 위치값에 더해주면 그것이 곧 카메라가 물체를 보는 위치값이 된다.
   즉, 물체의 뷰스페이스의 위치변환은 월드스페이스 원점에서 카메라가 이동한 위치값의 역값(마이너스값)이다.


A1 extern 키워드 