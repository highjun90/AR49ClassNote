- 오늘 아직 계층구조 끝나지 않아서 계층구조 설정할게요

- Level - Layer - Object - (child) 구조에서  child 는 어떻게 관리되어야 하는가?
 - m_vecParent : 레이어 기준 바로 최상단 오브젝트만 알고있음(부모가 있는 오브젝트는 신경안쓰고 오직 부모가 없는 최상단 오브젝트의 정보만 있음. 레이어 입장에선 바로 밑 소속만 알고 밑의 밑부턴 신경안씀)
 - m_vecObjects : 부모자식 상관없이 해당 레이어에 속한 모든 오브젝트가 있는 배열
  - 이것을 위해 m_LayerIdx를 둔다. 오브젝트 본인이 몇번 레이어의 소속인지 이 인덱스에 값을 저장해놈
    따라서 레이어도 만들어질때 본인이 속한 레벨의 몇번째 레이어인덱스인지 설정하게된다. (그래야 오브젝트도 본인이 속한 레이어를 구분할 수단이 생기니)

 - 만약 자식이 특정레이어에 직접 속하고 싶으면 어떻하나? 그리고 그 자식이 나와는 다른 레이어에 속하고 싶다면 어떻하나?
   그래서 꼭 부모에서만 push_back 하는 구조가 아니라 다른 방식이 필요하다.
    (참고 -> 모든 오브젝트는 생성할때 처음 아무런 레이어에 속해있지 않다면 레이어 인덱스를 -1로 설정한다.)

    즉 부모 오브젝트는 레이어인덱스가 0인데 자식은 1이라던지 하는 상황이 있을수 있다는 말.
    -> 아니 이런 구조가 왜 필요힘? 그냥 자식 레이어는 부모따라가면 안됨?
       이런건 예시를 들어야한다. 예를들어 플레이어가 있고 플레이어 자식에 미사일이 있으면 
       인물과 무기효과를 따로 관리하고 싶다면 아무리 미사일이 플레이어의 자식이여도 레이어 라는 관리그룹에서는 따로 관리될 수 있다는 말이다.
       그래서 무기효과만 렌더링하기, 인물들만 렌더링하기 이런 작업도 가능하게 된다. 
       애초에 레이어의 목적도 그것이다. 내가 관심있는 관련 오브젝트끼리 묶어서 관리하기. 레벨과 오브젝트 사이에 굳이 레이어 껴논 이유가 뭔지 생각하라

 
 - AddObject() 함수
  - 만약 인자로 준 오브젝트의 레이어 인덱스가 -1이 아니고(다른레이어에 소속되어있었고) 부모가 없는 오브젝트라면? (==최상위 오브젝트였다면?)
   -> 기존의 레이어로  가서 본인의 소속을 지우고 새 레이어에 들어가야한다. 

  - 두번째 인자 bMove는 오브젝트의 자식소속도 본인과 같이 바꿀지 안바꿀지 결정하는 인자.
    true면 오브젝트에 소속된 자식들 전부 같게 비꿔주고  false면 본인과 같건말건 신경 안쓰고 해당 오브젝트의 소속만 바꿈
    ** 이때 자식의 레이어 소속이 -1(없는경우)이면 강제로 소속을 인자로 준 오브젝트와 같게 설정한다. 이거 안하면 오류가 날테니. 소속없는 오브젝트 처리를 뭐 어떻게 하는 구조가 지금은 없다.

  - bMove의 디폴트인자는 true
 
 - DisconnectWithlayer() 함수 
  본인의 소속을 없애고 레이어 인덱스를 -1로 설정
  1.현재본인의 레벨을 알아야 레이어에 접근이 가능하므로 레벨메니저에서 현재 레벨을 가져옴
  2.본인이 속한 레이어 정보가져옴

 - DetachGameObject() 함수 
  - 해당오브젝트 레이어 인덱스가 -1이거나 내레이어인덱스와 일치하지 않으면 그 오브젝트를 현재 레이어에 뗴달라는 요청, 즉 이 함수를 요청하는게 잘못된것임


 - 카메라에 레이어를 분리시켜서 보일수 있게 하는 기능을 만들것임. 예를들어 한화면에 UI 레이어를 찍는 카메라와 일반 레이어를찍는 카메라 등. 

 - 이제 특정레이어 소속인 애들만 렌더하는 기능이 생깁니다. 렌더링은 계층구조로 하는게 말이 안됩니다. 렌더링은 계층구조와 상관이 없어요 플레이어그리고난 다음 미사일 그리고 할게 아니라 그냥 플레이어 미사일 동시에 그리죠
   메틱마다 m_vecObjects 배열에 동일한 레이어에 속한 모든 오브젝트 를 등록하고 그립니다.
   프레임시작전에 한번 clear() 돌려주고 렌더하게합니다. 매틱마다 오브젝트의 소속 레이어가 바뀔수 있기 때문에 이런 구조가 된겁니다.

 ==========================================================
  TastMgr란? 당장 처리할수 없는 일들을 모아뒀다가 한꺼번에 처리해주는 매니저. 예전에 만들어 놓은게 있다함

  - Task 구조체가 있고 그 안 멤버에 enum 으로 첫번째 인자에 하고자 하는일, 나머지 param1, param2 등등은 그 task type 처리에 활용할 데이터공간.
  - Task 유형은 계속 추가될거라함

 - CREATE_OBJECT task 에서, Object의 begin()함수는 Level의 상태에 따라 실행여부가 결정된다. 만들어지자 마자 바로 실시하는게 아님

 - 이제 전역함수로 namespace GamePlayStatic 에 방금 가져온 Task의 여러 상황에 대응하는 함수들을 정의하고 만든다.
  - SpawnGameObject()함수
   태스크매니저에 오브젝트를 등록시켜놓고 나중에 오브젝트를 처리한다.
   태스크매니저에 TIck()도 돌려줘야 나중에 Task 처리가된다.

 - 이제 예시로 미사일 오브젝트를 만들어서 바로 레벨에 꽂아 넣는게 아니라 SpawnGameObjec()를 써서 등록함
 - 추가로 미사일스크립트만들어서 본인 스피트만큼 위로감 (y축이동)



 !!) 오늘 핵심) 레이어는 오브젝트간에 수평구조인거고 오브젝트간에 계층구조도 동시에 있는 것이다.

 스크립트는 엔진에 있으면 안됨내가 추가로 구현한것이기때문. 최종적으론 스크립트가 엔진에서 빠져나오는게 목적입니다.