 - Inspector   - AssetUI
               - ComponentUI  - MeshRender
                              - TransformUI
                              - 카메라컴포넌트UI
                              .
                              .
                              . 등등 최대 14개 (현재 우리 엔진은 컴포넌트 종류가 14개임)


 - 즉 Inspector UI가 하나의 오브젝트의 정보를 보여줄때, 세세하게 따지면 최대 15가지 (AssetUI 1개 + ComponentUI 14개)의 정보를 보여줄수 있다.

 - 이렇게 비슷한 구조가 많이 보이고 계층구조까지 보인다면 상속구조와 다형성을 생각해야됩니다.
   비슷한 구조가 많아진다 싶으면 전부다 부모포인터의 벡터로 일괄관리 하면 되겠다는 생각을 하셔야 합니다.
 - 이제 UI클래스를 상속하는 ComponentUI를 만들고 이걸 또 각 UI들(MeshRenderUI, TransformUI 등등)이 상속하는 구조를 만들겁니다.
 
 - ComponentUI 클래스
  - m_TargetObject -> 정보를 보여줄 오브젝트 주소
  - m_TYPE         -> 본인이 보여주는 정보의 컴포넌트유형이 뭔지 enum으로 표시
  - 생성자는 원래 부모 UI가 요구했던 _strName과 _ID에 이어 COMPONENT_TYPE 까지 인자로 줘야함

 - 기존에 있던 MeshRenderUI 나 TransformUI에 있던 멤버들(타겟오브젝트등등)은 이제 부모인 ComponentUI가 대신 가지게되어서 다 삭제했습니다.
   나중에 각 컴포넌트에 맞는 맴버는 필요하면 추가합니다.

 - 컴포넌트 종류가 총 14개이니까 그만큼 Inspector가 모든컴포넌트들을 다 대응할수있도록 용량 똑같은 배열을 만들어줍시다.
   그리고 오브젝트에 달린 컴포넌트들과 대응하는 UI는 아직 전부 만들지 않앗기때문에,  m_arrCom[i] == nullptr 이면 안보여주게 if문 걸게요

 - 만약 타겟오브젝트가 해당 컴포넌트를 보유하지 않고있다면 컴포넌트UI도 보여주지 말아야한다. (Deactive())
  - 예시로 어떤 오브젝트가 매쉬 컴포넌트와 트랜스폼 컴포넌트만 갖고있는데 카메라컴포넌트UI라면 (이 UI의 타입이 즉 m_TYPE 이 카메라라면) 보여줄 정보가 없는 것이다.
  - componentUI의 setTargetObject()함수에 이 논리가 코드로 구현되어 있다

 T) imgui가 1바이트 문자열만 요구해서 선생님이 중간에 2바이트 문자열 1바이트로 바꾸는거 너무 귀찮다고 매크로 함수하나 만드심
  - func.cpp 에 구현
   - ToString()함수와 ToWString()함수.

 T) 중간에 선생님왈 - 에셋매니저 잘못만들었네.. 본인의 키값이 무엇인지 에셋매니저가 알게해야지
 T) 아 이거 UI 사이즈 설정 안해주면 겹치네.. 최상단 UI클래스에 UI 설정해주는 m_vSize 멤버 만들게요
  - BeginChile()의 두번째 인자가 부모UI의 공간을 얼마나 차지할지 결정하는 인자입니다. 
    원래 이전시간까지 디폴트 설정으로 뒀거든요? 그건 부모 UI 공간을 다 꽊 채우는 설정입니다.
    이제 그렇게 하지 말고 인자로 m_vSize를 줄거에요.
  - 자식UI들은 다른자식UI가 쓰고남은 부모UI의 남는 공간부터 그립니다. 우선순위는 당연히 먼저 BeginChild() EndChild()한 UI입니다.


 - 이제 TransformUI 같은게 생긴게 맘에 안들어서 UI 생김새 고치는거 구현해봅시다.
   각 UI 머리말에 이게 뭔지 본인UI 이름알려주고 구분선도 있었으면 합니다.

 - 컴포넌트UI들(트랜스폼UI같은애들)은 이제 render_update()에서 맨처음에 구분선그려주는 부모의 Separate()함수를 먼저 쓰고 본인이 할거 합니다. (자식이 부모함수 호출할수  있는거 아시죠?)

 - ImguiMgr 에서 m_bDemoUI를 키면 데모버전 UI가 보입니다. 보면서 본인이 원하는 기능을 찾고 거기에 맞는 코드를 찾아서 본인 UI 설계해 나가면 됩니다.

 - 예시로 버튼하나 만들어볼게요
   ComponentUI::render_update()에서

   PushID() 적어주고
   PushStyleColor어쩌구() 함수 로 버튼 색깔 정해주고(상황이 3가지여서 함수도 3개임)(HSV는 채도인가 그럴거에요)(뒤에 숫자가색깔인데 RGB형태인지는 몰루? 공부해볼것)
   
   이름 적어주고

   색깔pop 해주고
   아이디pop 해준다.

   구조보시면 알겠지만 push한 설정만큼 pop도 해줘야합니다 스택구조처럼

  - 이걸 이제 자식인 TransformUI나 MeshRenderUI들이 본인UI 이름에 맞게 바꾸도록 설계하면 되겠죠? 지금은 두 UI다 버튼 이름이 Component 잖아요?
    -> 실제로 바꾸심
 
 T) 상속구조 만들었으면 무조건 부모 소멸자에  Virtual 붙이세요 그래야 leak 안생겨요 제발 -> Virtual ~UI()

 ==========================================================================================================================================

 ** 미리컴파일된 헤더 설정 -> pch.cpp가 만들기, pch.h가 사용

 - 유니티 빌드를 써봅시다.
  - 구성 속성>고급>Unity(JUMBO)빌드 사용> 예
  - 이러면 C/C++에 유니티빌드 설정이 나타납니다.
    구성속성>C/C++>유니티빌드
    - Unity 파일의 최대 소스 수 20
                   최소         10
    - Unity 파일 디렉터리 - 우리 프로젝트 파일경로 $(Project)


  - 프로젝트 설정에서 빌드제외하면 그 프로젝트에서 없는 취급하거든요? 유니티빌드가 뭐냐면 모든cpp파일에대한 제외처리를 프로젝트에 적용시켜주는겁니다.
    한땀한땀 수동으로 제외처리하는게 아니라 프로그램으로 자동화한겁니다.
    만약 cpp 제외하면 링크오류나겠죠? 

    우리가 cpp파일로 구분하는 이유가 관련있는 기능을 하나로 몰아넣어서 관리 편하게 하려는 거죠? 기능이 흩어져 있으면 인간은 복잡해하니까.
    이렇게 파일 분리해놓고 참조해놓은걸 하나로 합치려면 컴파일 속도가 느려질수 밖에 없는 구조에요

    유니티 빌드가 뭐냐면 기존엔 전방선언만 가져오는 헤더파일만 include하는거죠? 유니티 빌드는 모든 cpp를 제외하고
    cpp 하나만 나두고 완성된 cpp 하나에 모든 코드를 때려박는겁니다. 이러면 링킹이 필요가 없죠? 속도가 빨라집니다.

  - 정리하자면, 파일분리 시스템은 사람이 관리하기엔 편하지만 링크과정이 비대해져서 컴파일 시간이 늘어납니다.
    유니티빌드를 쓰면 임의의 cpp파일에 관련된 모든 소스코드를 다 때려박아넣었어요 그러면서 컴파일 시간(빌드속도)을 효과적으로 줄이는 겁니다.

  - Client 프로젝트 경로에 뭔가 복잡한 이름의 cpp파일이 새로생긴걸 볼수있다. 새로생긴 파일 까보면 cpp 파일들이 죄다 include 되어있다. Engine은 양이 많아서 2개의 cpp파일로 유니티빌드가 됨
    이 새로생긴 파일들로 빌드 해서 기존에 똑같은 출력파일(exe파일등)을 만든다.


 - UI 설명정보가 지금 오른쪽에 있는데 좌측으로 옳기고 싶어요
  - 기존의 InputFloat3()함수에서 첫번째 인자 Relative posision은 앞에 ##붙여서 감출게요 ("##Relative Positipn") 그러면 숫재3개 뒤에 보여주던 문자열이 사라지겠져?
  - 그리고 그 윗줄에 Text()함수와 SameLine()추가할게요 그럼 우리가 원하는대로 우측이 아니라 좌측에 문자열이 보이는걸로 바뀌겠죠?
  - 또 InputFloat3() 대신에 DragFloat3()함수로 바꿀게요 이게 보이는건 똑같은데 마우스 드래그로 수치바꿀수 있습니다.

 - 각 컴포넌트 별로 체크박스 만들어서 특정컴포넌트의 기능을 on off 할수 있는 인터페이스 만들고 싶어요 <- 만들거처럼하더니 바로 다음이야기로 넘어감
 - 그리고 부모값에 영향받는?? 거 온오프할 체크박스 하나 만들어 봅시다.
  - IsAbsolute() 로 bool값 가져옵니다.
  - Checkbox()함수의 두번째 인자는 사용자 상호작용의 결과값을 저장해놓는 인자입니다.
    이걸 활용해서 실제 오브젝트의 Absolute 값도 바꿔줍시다. 이 구조 지난시간에 m_bActive랑 비슷한 설계방식이죠? UI창 내리는 상호작용할때 말이죠

 - Text()함수는 고정된 문자열만 보여주는 함수인데 InputText()함수는 내가 적어주는 문자열로 바꾸는 기능까지 있습니다. 근데 그런 의도로 쓰기보단 여기서는 문자열을 강조하는 효과를 주는 용도로 쓰는겁니다.
   예사) string meshname = Tostring();
         ImGui::InputText("##MeshName", (char*)meshname.c_str(), 문자열길이);
  - InputText() 결과박스의 내용을 변경할수 없게 4번째 인자를 추가해줍니다. int 인데 사실 이건 Flag값들의 조합이다. 
                                                                           즉 미리 조합된 Flag결과값인 int를 인자로 넣어줘도 되고 본인이 직접 Flag들을 OR 비트연산자로 조합해서 인자로 넘겨줘도 된다.
                                                                           int와 달리 진짜 flag값은 자료형뒤에 _(언더바) 하나 더 붙여있어서 쉽게 확인할수있음




내일은 우측에 버튼하나 더 추가할겁니다. 그 버튼으로 오브젝트의 메쉬나 재질 고칠수있게 만들어볼거에요