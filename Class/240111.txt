 - Ui는 빛계산없는 전용쉐이더를 써야한다 표준쉐이더 쓰면안됨

 - 포스트프로세스(후처리)
  - 완성된 최종화면의 그림에 마무리작업을 해주는것. 사진에 뽀샵필터같은역할
  - 안개,카툰렌더링, 경계에 윤곽선넣기 등
  - distortion(왜곡) 효과. 일렁거리는 느낌(물표면, 쉴드보호막, 블랙홀 경계면등)

 - 파이프라인을 통해 최종장면이 렌더타겟 완성되고 나면 그걸 다시 리소스로 활용하는것은 안된다고함. 이러면 최종완성본이 필요한 후처리는 어떻게하나? 그래서 최종장면의 복사장면을 만들것이다.
   => 이거 하려다가 쉐이더 도메인 안되있는거보고 뒤로 미룸

 - 쉐이더도메인이라는 enum class 추가. 이제 물체들을 분류해서 쉐이더 처리함. 
    쉐이더 도메인이란 : 이 쉐이더가 어느 작업을 수행하는데 적합한 쉐이더인가? 어느영역의 작업에 특화되어있나
     '넌 이런 쉐이더야' 라고 딱 지정해주는 표시역할도 됨

  - OPAQUE              불투명쉐이더. 아예그리거나 안그리거나. 즉 내가 쓰는 메쉬전체에 색을 꽊꽊채워 넣는 경우
    MASKED              불투명 or 투명이 혼재하는 쉐이더. 그려지는 물체는 완벽하게 투명하거나 완벽하게 불투명해야함.
    TRANSPARENT         불투명한 애들이 먼저 그려지고 반투명한 애들이 그려짐. (애초에 불투명한거 뒤에 오는 반투명한 물체는 안보임. 반투명한것이 보이는 경우는 반투명한 물체 뒤에 불투명한물체가 있을때.)
    POSTPROCESS         후처리하는 쉐이더
  - 3D는 보통 Opaque 도메인을 쓰고, 2D는 Masked를 사용. 2d는 생각외로 알파블렌딩쓰는 경우가 거의 없음 사용해도 스킬이펙트정도? 3D 게임은 입체적인 물체가 많이 때문에 얼굴앞에서 보는데 투명하면 뒤통수안쪽이 보이는 등 
    이상해짐

 - 이제 표준쉐이더를 쓸땐 알파값이 0이면 discard 해버림
 - 스킬이펙트 등에 알파블렝딩 필요하면 다른 적합한 쉐이더를 쓴 재질을 써야겠죠

 - 카메라보고 렌더링 바로 시켰는데 이제는 카메라에서 물체 분류작업을 하고 렌더링합니다. (무슨분류? 어떤 쉐이더를 적용해야하는 물체인지. 쉐이더 도메인을 만들었으니 이제 고대로 분류합니다)
  - 어떻게 구현하나? -> 쉐이더 도메인 영역별로 벡터를 만들어서 그 벡터에 물체들을 따로따로 담아놓고 순차적으로 렌더링. 
    - 구체적인 렌더링 구현방식 설명
      내가 찍으려는 레이어를 가져온다. (찍으려는 레이어 아니면 다음레이어 검사로 넘긴다.)
      가져온 레이어의 오브젝트들의 메쉬, 재질, 쉐이더를 확인한다. 설정안되있는 놈들은 렌더링 기능이 없는 놈들이니 무시하고 넘어가서 다음 오브젝트 검사.
      해당 오브젝트의 도메인을 확인하고 거기에 맞는 벡터로 push_back()한다.
      쉐이더 도메인 순서대로 렌더링한다. (opaque, masked, transparent, postprocess 순으로.)


=====================================================================
 - 이렇게 분류했으니 포스트프로세스 쉐이더 아주 간단한거 하나 만들어봅시다.

  - 지금 만들 후처리 쉐이더는 화면전체의 픽셀쉐이더를 호출하는 쉐이더입니다. 
  - 필요한 데이터들을 구조체로 받습니다. 지금당장은 지역위치와 UV 값입니다.
  - 후처리 필터이름은 GrayFilter.
  - 메쉬는 rect mesh 인데 여기서 사용하는 정점의 정보가 0.5 들이 었다. 따라서 이걸 1로 맞춰주려고 한다. NDC좌표계 꽉꽉 채운게 1이기 때문. (반대로 rectmesh 정점들의 로컬좌표값이 1 이상이면 1로 낮추려고 해야겠지)
    그래서 쉐이더에서 내부에 들어오는 점의 값을 곱하기 2한다. 왜 하필 2를 곱하는건지 이해를 해야한다 NDC좌표계꽉 채우려고 하다보니 2를 곱하는거다 만약 rectmesh가 4면 곱하기 2 아니라 나누기 4해야한다.
    => 그래서 이 쉐이더는 우리가 이 엔진에서 정의한 rect mesh 에서만 쓸수있다. 딴 메쉬 쓰면 의도한대로 화면에 적용되는 필터범위가 이상하게 나올수도있음
  - 이 쉐이더는 컬백이고 깊이 값은 있으면 안됨(그냥 화면전체에 한번 그리고 바로 나가는쉐이더), 블렌딩도 없음 내가 원하는 색을 반드시 그릴꺼기때문에(색을 그냥 흐리게만 할거기 때문에 알파블렌딩쓰면안됨)
   => 주석 읽어봐라

  - 포스트프로세스 텍스처 설계하기
   - 위치값 크기값 사용안해도 transform은 기본적으로 있어야 오류안나니까 컴포넌트에 넣어준거임
   - 지금까지 만들어보고 실행하면 그냥 화면이 회색으로 나옴..이럴거면 힘들게 파이프라인왜했나 저질후처리이다. 
     내가 원하는건 회색톤을 은은하게 넣어주는것이므로. 렌더매니저에서 화면완성본하나를 복사해놀 후처리용 텍스처 하나 맴버로 둘겁니다. (PostProcessTex)
    - 렌더타겟 파일에서 뎊스스텐실택스처, 뷰 만들던 코드 고대로 복붙.
    - Creat()함수에서 인자 중에 조합된 비트결과로 들어올 수있으니 자료형을 UINT로 한 bind flag 필요. enum class로 안한 이유는 데이터가 조합된 형태로 들어올수 있어서임 정보가 딱 하나라면 이넘으로 했음
    - 코드중에 _Usage 저장하면서 그게 다이나믹 플래그 였다면 씨피유도 write모드로 설정해주는 부분봐둘것

    - 이 텍스처가 렌더타겟용인지 뎁스스텐실용인지 아니면 쉐이더리소스용 텍스쳐인지에 따라, 바인드플래그 설정에 맞는 뷰들이 나와줘야합니다.
      애초에 바인드플래그에 깊이스텐실, 쉐이더리소스 텍스처용이라고 다중설정해서 뷰 만들라고 하면 뷰 만들기 실패가 떠버립니다.

      반면 렌더타겟설정은 다중설정이 가능합니다. 렌더타겟용 텍스처 이면서 쉐이더리소스용인 텍스처일 수 있단말입니다
      이런 다중설정이 되는 텍스처는 렌더타겟, 쉐이더리소스, 언오더릿엑세스 입니다(얜 설명안했다함). 요 3개는 텍스처가 동시에 가실수 있는 바인딩설정임
      만약 이 3가지 바인딩설정을 전부 가진 텍스처라면 뷰도 3개 다만들어진다. 

      이렇게 바인딩 설정에 맞게 뷰 만들어 줍니다 CTexture.cpp 
    - 이렇게 만들어진 텍스처는 에셋매니저로 접근할수 있음. 텍스처 만드는 함수도 에셋매니저에 추가. (CreateTexture()함수 )     
    - 지금까지 우리 메모리상에 후처리용 재료로 쓰일 최종완성장면 텍스처를 만드는 작업을 했습니다.



  - Device에 에셋매니저(CAssetMgr)로 후처리용 텍스처 만드는 코드 추가(CreateTexture()함수)

  - 소소하게 뎁스스텐실 텍스처 만드는 코드부분도 앞서 만든 코드들 활용해서 만드는 걸로 변경

  - 렌더 매니저에서 에셋매니저 활용해서 후처리용텍스처 만듬
    이때 바인딩 설정에 얘가 렌더타겟일 이유 없다면서 쉐이더 리소스만 설정해놈

** 정리 메모리 상에 텍스처 직접 만드는 기능 없어서 만들엇다. 바인딩 설정에 맞게 뷰도 다 만든다. 렌더매니저에 실제적인 포스트프로세스 텍스처까지 만들었다.






