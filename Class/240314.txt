 - 폰트도 기존에 있던 라이브러리를 가져올거에요. 폰트작성하는데 도와주는 간단한 외부 라이브러리입니다.
  - 동적라이브러리입니다.
  && 우리 실행파일이랑 디버그모드 실행파일 같이 놔서 문제가 됨 (dll파일이름이 디버그 모드와 릴리즈 모드파일 이름이 같다고함 예전 엔진은 실행파일과 디버그모드 실행파일 위치가 달랐나보다)
     웬만하면 라이브러리 파일 이름이 디버그모드와 릴리즈모드 다른게 일반적인데 이 폰트 라이브러리는 이름이 같아버림..
     현재 이 엔진은 모드마다 이름이 다를걸 가정하고 바이너리파일에 디버그, 릴리즈버전 파일이 같이 놔둬야 하는데 폰트 얘는 이름이 같아버리네..
     
!!!) 그래서 나중에 릴리즈 버전 필요한 순간(배포하는순간)에는 파일 바꿔주셔야합니다. 일단 릴리즈 버전은 파일 상위폴더 한단계 밖으로 빼놓음


 - CFontMgr 클래스 생성.
  - 예전엔진의 CFontMgr 코드를 복붙함.
  - CEngine.cpp에 

  - DrawFont()함수. 
   - 인자로 폰트가 나올 윈도우 죄표값, 색상값 등을 넣어주면 출력됨.

  - 사용예시) CTimeMgr.cpp 에 DT타임 표시하기
   - SetWindowText()함수는 주석처리하고(얘는 커널오브젝트에 접근해서 변경하는거기 때문에 렉이 굉장히 걸린다 별로 안좋아), DrawFont()함수를 써보자.
   - 그냥델타타임이 아니라 엔진델타타임을 써야함 레벨 정지했다고 시간 안흐르면 안되니까
   $$ DrawFont()도 렌더타겟에 출력되는 거라서 1프레임만 나오기 때문에 그거 고려해야되고,
      tick()에다 그리고 있었는데 이러면 렌더할때 clear()하고 시작하니까 영원히 안보임 함수위치 잘못했음
      ->tick()에선 계산만 해놓고 timeMgr의 render()에서 출력하게 한다.
    
      LevelMgr의 tick()바로 밑에 TimeMgr의 render()를 꼽사리껴준다. clear()이후로 출력하는 거래서 화면에 나온다는듯.

  - 원리 : 지오메트릭 쉐이더 써서 입력한 문자열 개수만큼 메쉬를 만들고, 월드에다가 배치시켜서 사각형 배치해서 폰트 글자 이미지를 렌더링하는 것이다.
           이 구조를 수업시간에 만드는건 너무 노가다가 심해서 그냥 만들어 논 것 쓴겁니다.
    
  - 외부 폰트 불러오는 것도 제공을 할텐데 그건 찾아보셔야합니다. 여기까지 타임매니저에 DT값 적용시켜봤어요

-------------------------------------------------------------------------------------------------

 - 메인함수 구조부터 살펴보기
  - 1프레임이 어떻게 돌아가는지 머리에 그려져야 이해한것임
  - 엔진 초기화할떄 여러 매니저 초기화합니다. 이떄 에셋mgr의 init()은 엔진에셋을 말하는겁니다 파일에 없는 애들. 그래서 나중에 너 원본에 없네 삭제 할게 막으려고 엔진에셋 표시하게 관련
    값 true로 설정했음
  - 레벨매니저 초기화 별거없음. 예전엔 여기에 뭐 많이 넣었는데 관련기능이 client로 빠짐
  
  - 이렇게 엔진 이니셜라이저가 끝나면 임시레벨을 생성.
  - 레벨 세이브 로드 전에 프리팹에서 오브젝트 단위로 저장하고 불러오는 기능이 클라이언트에 있어서 함수포인터 설정해줌
  - CCreateTempLevel::Init()은 특정시작레벨을 플레이모드로 발표할때(최종릴리즈에서는) 삭제되야함
  - 에디터오브젝트매니저는 카메라를 만든다. 지금구조는 레벨을 정지시킬떄 에디터용 카메라로 카메라 전환을한다. 
    지금구조는 레베를레이 상태에서 일시정지로 갈때 에디터 카메라로 전환하는데,
    실제 릴리즈게임은 에디터카메라가 없을테니 레벨일시정지하면 검은화면만 나올것이다.
    (render_editor()함수에서 m_EditorCam이 null이기 때문에 return 때려버림)
    여러분이 릴리즈모드 게임에서는 구조를 바꾸셔야해요 분기처리 하십쇼

  - imgui까지 다 만들었으면 메세지 루프 돕니다.

 - 이제 엔진 progress()로 가자
  - 맨처음 타임매니저와 키매니저를 프레임 제일 첫번째에서 업데이트 해준다. 이번 tick()의 키 상태를 결정지어놓고, 현재 tick()의 DT타임도 계산해놓는것.
    이때 델타타임이 2개였다는걸 기억하라. 타임매니저에 lock 걸어버리면 DT도 시간이 흐르지 않는다. (m_block이 true일떄)
    게임내적 요소는 엔진 DT를 쓰고, 실제 플레이와 관련된 요소는 일반 DT를 쓴다.

  - 사운드는 그냥 에셋이고, 맴버로 갖고있는 System은 FMOD쪽 객체다.

  - 레벨업데이트 
   - 모든 오브젝트들은 finaltick()에서 자신이 속해있는 layer에 본인을 등록시켰다.
     그래서 tick()시작마다 이전 프레임에 등록된 오브젝트들을 clear()시켜준다. 안시켜주면? 계속 중복되서 오브젝트 등록정보가 쌓여버림
   - 충돌처리는 분리축이론 적용했네 뭐네 따로 설명안하겠다
   
   - 레벨이 Play상태일떄만 tick()을 주고, 아닐때는 finalTick()만준다. finaltick()은 각 컴포넌트들이 자신의 계산값을 수행하는 부분이여서 어떤경우에도 수행되야함
     만약 수행안하면 월드값같은거 계산안해서 화면에 아무것도 보이지 않는다.

 * 한 TIck()이 어떻게 이뤄지는지 둘러보는중. 지금 LevelMgr의 tick()내부 살펴보는중 
============================================================================================

 - 렌더링부터 시작할게요

 - 화면에 있는 물체들이 이번 프레임의 최종 위치값이 확정되고나면 카메라가 상대적인 위치를 결정해줘야해요
   imgui때문에 컨텍스트에 렌더타겟에 깊이스텐실 설정을 해줘야합니다. 원래는 그냥 한번 설정하고 끝난건데
   imgui 창이 윈도우 창 넘어갈때 자신만의 렌더타겟을 가져서 렌더링이 제대로 되지 않는다고 했었죠.

   UpdateDate()함수는 GPU쪽에서 필수로 필요하는 데이터를 넘겨주는 역할을 하죠
   예를들어 2D광원 개수라던지.  g_global에 화면 해상도 라든지. 얘는 extern되어있어서 모든 cpp가 쓰죠.

   UpdateData(11) -> GPU 11번레지스터에 데이터보내는거죠

 - 이렇게 필요한 업데이트가 끝나면 알맞은 렌더함수를 호출해야해요
   render_Play()로 간다면 현재 레벨이 플레이하는 카메라 로 가고, render_editor()는 레벨이 정지되어있는 카메라로 가는거죠.

 - 결국 렌더링을 제어하는건 카메랍니다. 카메라가 주체가 되서 카메라 시점데로 그림이 그려지는 거죠.
 - 어떤 카메라던 SortObject()합니다. 카메라는 그 레이러를 보지 않기로했다면 넘기고, 보기로한 레이어는 오브젝트 모두 불러와서 
    분류합니다. 이때 메쉬, 재질, 쉐이더 중 하나라도 지정 안되있는 놈들은 걸러버립니다.

    이 단계를 넘겼다면 이제 쉐이더의 도메인에 따라서 분류합니다. 
    도메인순차대로 렌더링을 하기 때문이죠. (불투명한게 먼저 출력되야하겠죠)

    이렇게 까지 렌더링 설명이 끝남

-------------

 - GC는 가비지 컬렉터라고 지워질놈들 제거합니다. task도 수행합니다.

 - 다 끝나고나면은 엔진 progress()가 끝났다는 거니까 
   이제 에디터오브젝트매니저의 progress()를 수행합니다.
   얘는 에디터카메라같이 엔진의 기본구조를 건들지 않고 클라이언트 쪽에서 외부에서 서포팅하는, 툴로서 존재하는 오브젝트를 말합니다.
   얘도 tick()을 받아야 행렬연산이라던지 이런걸 하려면 어쨌든 오브젝트 구조를 따르고 있기때문에 tick()을 매번 수행해줘야합니다.
  
 - 얘는 레이어가 -1이기 때문에 파이널틱에서 오류날것입니다. 그래서 레이어에 본인을 등록하는 기능만 쏙빼서 파이널틱을 오버라이드로 재구현했습니다.

 -----

 - 이제 imgui

 - 얘도 progress()에서 tick()하고 render()하고 컨텐츠 폴더 싱크 검사하는 observe_content()를 실시합니다.
 - tick()은 원리도 알필요없이 이게 있어야 동작을 하니까 NewFrame()3줄이거. 필요합니다.
 - ResetID()는 매번 최신화 해줘야했던걸로 기억합니다. <-부정확
 - 사실tick()은 거의 하는게 없어요

 - render()할때 본인이 최상단부모인지 중요하다고했죠 왜냐면 열고닫는데 쓰는 함수가 다르기 때문에
   Begin() End()냐 BeginChild냐 이런거.
 - 그리고 본인이 모달타입인지도 구별했어요.
 - render_update()는 본인의 정체성에 맞는 맴버함수를 수행하는거에요. 
   이함수 하고 나서 자기 자식들의 렌더를 수행시켜줍니다.

 - 인스펙터는 특정 오브젝트를 선택하면 자식들은 그 오브젝트가 갖고있는 컴포넌트의 UI가 될겁니다.
 - 아웃라이너나 컨텐츠는 트리구조로 현재 레벨에 있는 오브젝트, 또는 현재 있는 에셋정보를 보여줌
  - 트리노드에 콜백이나 델리게이트 함수를 넣어줘서 특정 노드를 누르면 필요한 기능을 동작하게 했다.

---------------

 - 레벨세이브로드.
   현재 레벨의 상태정보를 저장하고 로드.

 - 다만 컴포넌트 개수가 변경될때마다 신경써줘야할게 있음.
   레벨에 무엇을 저장해야되고 무엇을 어떻게 불러와야 되는지 명시해줘야한다. SvaeTOFile, LoadToFile을 잘 구현하라는 말임

 - 레벨저장과 로드하는 기능을 엔진에서 구현하지 않고 클라이언트쪾에 구현한 이유가 스크립트때문이다.
   엔진은 앞으로 어떤 스크립트가 생길지 모른다. 클라이언트는 엔진과 스크립트 둘다 받아서 쓰기때문에 여기서 레벨의 세이브로드기능을 구현하기 안성맞춤이다.
   
 - 스크립트가 늘어날떄마다 필수적으로 해줘야 할 것들을 CScriptMgr.cpp에 한군데에 모아뒀다.스크립트 변화를 감지해서 알아서 필요한 코드를 만들고 갱신을 해줌.
   코드제너레이터가수행 

------------------

 - 프리팹은 어느정도 설계가 끝난 오브젝트를 에셋화 하는거였죠. FSM, 스크립트 설정 다 해주고 프리팹으로 저장해두면 프로그램껐다커도 바로바로 불러올수있겠죠
   얘가 큰자산이 될거에요 







