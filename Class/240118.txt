d - MeshRenderUI.cpp 에 버튼 하나 만들고 체크하면 메쉬 리스트들이 좌라락 나와서 선택하는 구조 만들기
  - 버튼을 누르는 순간 Imgui::Buttom()이 true를 반환하는 것을 이용해서 if문 걸어줌
   - 이if문 안에 들어왔다는건 버튼을 눌렀다는 뜻이니까 여기에 리스트UI 만들것임
  
   - ListUI 클래스 만들기 
    - 역시 UI클래스 상속.
    - m_vecStr -> 본인이 보여줄 정보(문자열)
    - m_bActive를 통한 UI 활성화 비활성화의 구조를 바꿨다. ListUI의 Deactivate()은 부모(UI)의 함수를 먼저 실행하고 본인이 해야할거를 하는 구조가 됬다.
    - AddString()은 m_vecStr 벡터에 문자열 하나 넣던지 문자열 여러개 넣던지 하게 오버라이드.
      두번째 경우에는 벡터의 .Insert()함수를 씀. 첫번째 인자는 기존 벡터의 끝 이터레이터, 두번째세번째는 삽일할 벡터의 처음과 끝의 이터레이터를 말함
    - render_update()에서 하는거
     - Imgui에 GetWindowContentRegionMax(); 함수 쓰면 현재 열려있는 최상단 Begin()에 해당하는 창 크기를 가져온다. 즉 ListUI가 쓰긴하지만 본인 크기가 아니라 부모의 창크기를 가져오게된다.
       이렇게 가져온 사이즈를 노가다로 수치를 줄여서 사이즈 설정을 해준다.
       (vWinSize.y -= -27;)
       처음에 선생님이 사이즈 예쁘게 조절하려고 했는데 함수찾고 이러는게 귀찮아서 저런식으로 구현함
   

  - 지금은 MeshRenderUI쪽에서 Button이 눌렸을때 ListUI가 활성화되는걸 구현중
   - FindUI()함수 반환으로 부모포인터를 반환하니 강제로 ListUI로 다운캐스팅. 
   - 에셋매니저에서 GetAssetName() 함수로 MESH 타입의 이름들을 벡터 vecMeshName이라는 벡터에 가져오고,
     그걸 ListUI의 AddStrign(vecMeshName)함수를 실행한다.

 - 모달방식 - 모달 창이 켜져있는경우 하위 윈도우 창을 정지시킨다. 반대개념은 모달리스 방식. 창하나가 활성화 되있다고 다른 창들을 비활성화 시키지 않음 동시에 동작함.
  - 이 방식을 ListUI에 적용시킬 필요가 있다. 선택할때 딴 UI가 동작해버리면 곤란한 경우

 - UI 클래스 맴버로 m_bModal을 둠. 이 UI가 모달 방식으로 동작하는 UI인지 알려줌 
  - BeginPopupModal() EndPopup(); 으로 설정. Begin() End() 대신 쓰는 겁니다. if 문으로 Modal 일경우와 아닐경우에 따라 Begin으로 열지 Begin모달 로 열지가 구분되는 형태.
  - 이렇게 모달로 열려진 창은 본인의 창이 활성화 되어있을때 다른 창들의 동작을 정지합니다. 그리고 모달아닌 화면은 살짝 회색처리되게 후처리됨

 ** 윈도우 모달과 Imgui 모달은 작동방식이 조금 다르다.
  - 윈도우는 메세지루프가 돌면서 메세지 발생하면 메세지에 맞는 함수를 실행하고 다시 메세지루프로 돌아옴
    만약 메세지루프돌다가 메세지 내용이 새로운 윈도우창을 여는거면 그 새로운 윈도우 창의 메세지루프를 또 돈다. 즉 기존 메세지 루프는 동작이 정자됨 이게 윈도우의 모달
  - Imgui의 모달은 프로그램자체가 먹통이 되는게 아니라 어니에 모달이 있는걸 감지하면 원래 동작하는 기능을 안하게 된다.
    즉 흐름 자체는 끊기지 않고 계속 돌아가는데 동작만 안하게하는것.

=========================================================================================
 - 이제 List에 떠있는 메쉬를 떠블클릭하면 오브젝트가 그 메쉬로 적용되야한다.
   그런데 정작 ListUI는 그걸 떠블클릭했다고 클릭된 메쉬나 재질에 맞는걸로 오브젝트를 직접 바꾸는건 안한다 그냥 내 목록중에 뭐가 떠블클릭됬어요 라는걸 알려주는 역할까지만한다.
   ListUI에 요청한 쪽에서(호출한 쪽에서) ListUI의 알림을 받으면 그것에 맞는 원하는 작업을 수행하고 ListUI는 그냥 '보여주기'라는 본연의 기능만 집중한다.
   이렇게 구조를 짜야 UI의 유연성이 유지되는 것이다. ListUI에 뭔 기능을 만들면 UI에 코드종속성이 생겨버린다. 

 - LIstUI가 더블클릭됬다면 MeshRenderUI에 콜백함수를 통해서 알려주는 기능을 만들자
  - ListUI에 더블클릭된 문자열을 저장하는 m_strDBClicked 맴버 두기. 얘는 ListUI가 비홠성화되도 상관없이 데이터는 고대로 가지고있음
  - Selectable()함수에서 목록 클릭을 하면 item_current_idx에 그 인덱스(i)가 저장됨
  - SetItemDefaultFocus()함수 - 선택된 목록 살짝 빛남
  - 호버라는게 위에있다는 뜻인가좀 Hover

 - 자주쓸 함수포인터(콜백함수) 타입을 imguiMgr에 적어놓겠습니다.
  - DWORD_PTR를 콜백함수의 인자로 쓰는이유- > 상황에 따라서 4바이트 이거나 8바이트 이기때문에 (플랫폼에따라 #define되어 있어서) 

 - 이제 ListUI에 m_CallBackFunc 에 콜백함수(함수포인터)를 저장시켜논다.
   더블클릭하는 순간  문자열주소를 인자로 하는 콜백함수 실행하고 Deactivate()한다

 - 이제 MeshRenderUI 에서 MeshSelect()는 ListUI()의 콜백함수로 동작하게될 함수이다. 인자로 당연히 DWORD_PTR 하나 가진다. 
   우리는 이 포인터가 ListUI에서 더블클릭한 문자열 이라는걸 알고있다. 그리고 이 함수는 MeshRenderUI.cpp 에 정의된 전역함수이다. 
   이 함수에서 비로소  ListUI에서 더블클릭한 메쉬대로 오브젝트의 메쉬를 바꾸게 된다.
 
 - 메쉬도 만들었으니까 재질 바꾸는 MaterialSelect()함수 도 MeshSelect() 이랑 구조 똑같이 따와서 구현합니다.
  
 - 창 종료할때 포커를 날려버리는 함수 SetWindowFocus(nullptr)을 ListUI Deactivate()에 넣어줍시다
   이거 안넣어주면 ListUI 창 끄면 자동으로 포커스기능 활성화되서 화살표키 누를때 인접한 UI 이동하면서 하이라이트 계속 보여서 정신사나워요
   



 
  -MeshDBClicked()함수