 - 어제했던 작업이어서 게임오브젝트 파일에 세이브로드하는거 부터 시작하겠다.

 - SaveGameObject()
  - 먼저 이름저장
  - 오브젝트가 저장해야할 정보가 뭐가있을까
  - 레이어인덱스값은 저장할 필요가 없을듯 어차피 레이어 로드할때 거기에 딸린 오브젝트들도 같이 로드할텐데 자동으로 그 레이어 소속으로 세팅될테니.
  - 컴포넌트 정보 저장. 모든컴포넌트 말고 갖고있는 컴포넌트만.
    컴포넌트 저장은 따로 함수 구현하려면 코드 너무 길어져서 여기서 반복문 돌면서 저장함
   - GetComponent()할때마다 그게 null이였으면 continue 하고 아니면 파일에 fwrite().
     컴포넌트 종류가 워낙 많고 각 컴포넌트들이 저장해야할 정보도 다르기 때문에 SaveToFile()로 파일포인터를 컴포넌트에 넘겨줘서 지들이 알아서 저장하라고 함
     컴포넌트에 순수가상함수 2개 추가. 컴포넌트들이 무조건 구현해야되는거. SaveToFile(), LoadFromFile().

 - Transform 컴포넌트.
  - m_bAbsolute는 부모에 크기 영향 받을지 아닐지 정보저장하는거래서 저장해야하고,
    pos scale rot 로컬행렬까지는 저장해줘야함 따라서 총 4개 맴버를 파일에 저장.
  - Load 할때는 Save의 역순으로 <- 이거 맞는지 확인해야함..

 - 메쉬렌더는 맴버가 없어서 그냥 부모쪽(렌더컴포넌트)꺼 쓰고 따로 구현안한다
 - 스크립트와 그 스트립트 객체를 상속하는 스크립트들(예시로 만들어 논것들등등)도 Save Load 구현해야함

 - Collision컴포넌트
  - Pos, scale, absolute, type(충돌체타입) 총4개를 파일에 기록해야한다.
    행렬은 어차피 갱신된다고 저장안해도 된다했나? 설명제대로 못들음
 
 - 애니메이터2D 컴포넌트
  - 얘는 단순히 맴버의 포인터를 저장한다고 될일이 아니다.
    반복문 돌면서 m_mapAnim 저장 일일히 해야한다.
    1) 우선 애니메이션 개수를 저장
    2) 맵을 순회하면서 각각의 애니메이션 정보를 저장한다.
     - CAnim 객체에 또 SaveToFile() 함수를 실행시켜준다.

    3) 플레이중인 애니메이션 key 저장
     - 재생중이 아니었으면 (==null이 아니었다면) 그 key  문자열을 파일에 저장.
    4) bRepeat 정보 저장

  - 로드할떄
   ?> 왜 이건 역순으로 로드 안하지... 로드를 세이브의 역순으로 할때와 아닐때가 정확이 뭐지 애초에 역순으로 로드하는 상황이 있는게 맞나?
   - .empty()가 null 문자열 null인지 검사해주는건가봄

 - CAnime
  - 세이브
   - 프레임의 사이즈 정보저장. 로드할때 필요.
   - 모든프레임 정보 저장. tAnimFrm 크기에 프레임 개수만큼 한꺼번에 파일에 저장.
   - 아틀라스 텍스처 정보저장
  - 로드
  - 벡터용량 늘릴때 reserve말고 resize할것. reserve는 그냥 capacity만 늘린거고 실제 벡터범위는 resize로 조절해야함.
    만약 reserve만 한다? 그럼 벡터가 실질적으로 데이터 저장할 전체 공간은 늘지않은거임 나중에 재할당한다치더라도

 - CLight2D
  - tLightInfo 딸랑하나

 - CCamera
  - '행렬은 매번계산하는거니까 필요없고'
    '매 프레임마다 물체 분류하는거니까 상관없고'
    행렬같은건 꾸준히 파일에 저장안한다.
  - 세이브하는 맴버는 코드 참조해서 볼것 너무많음

 - 렌더컴포넌트 
  - 메쉬나 공유재질, 현재재질 정보는 에셋매니저가 들고있으니까 SaveAssetRef() 이용해서 파일에 저장.
  - 현재재질은 현재 상황에 따라 공유재질일수도, 동적재질일 수도 있다. 현재 이 렌더컴포넌트가 뭘 참조하냐에 따라 다름.
    

  - 동적재질은 플레이 중일때만 순간적으로 잠깐 쓰일 놈이다. 레벨이 정지 상태일땐 생성하지 않는다.
    스크립트의 생성자에서나, 레벨의 begin이 아닌 상태에서 동적재질 만들어놔봤자 소용이 없다.
    지난 시간에 동적재질 무조건 만들고 시작해라 라는 말은 begin()함수 쪽에서 해야한다는 말이었다.
   
    애초에 동적재질은 에셋매니저에서 관리되는 놈도아니고 레벨이 플레이 상태일때만 잠깐 생기는 놈이기 때문에
    에셋매니저와 관련된 함수인 SaveAssetRed()에서 동적재질에 관한 코드는 있을 필요가 없음
    랜더컴포넌트의 GetDynamicMaterial()함수에서 레벨이 play가 아닐때 null 추가 

    이러한이유로 세이브 로드시에 동적재질만 쏙빼고 해놈. 

 - CTileMap
  - 역시 엄청많음 기록할만한거 몇개만기록
  - 무슨 아틀라스텍스처 썼는지 SaveAssetRef()로 기록
  - 구조화버퍼는 따로 저장하지않음 어차피 파이프라인보낼때 생성할듯

  파티클시스템부터 다음시간
  =========================================================================================

 - CParticleSystem
  - 엔진 DT써서 레벨이 정지상태일때도 파티클효과를 뿌려볼수있긴함
    현재는 레벨 정지상태에선 파티클이 움직이지 않는데
    그래서 파티클효과 보고싶을때마다 레벨을 플레이해야되는 상태임 이게 불편하다면 여러분들이 알아서 코드좀 수정하십쇼
 
  - 그래서 버퍼정보를 저장하진 않고 세팅값만 저장할거임

  - 파티클최대개수와 모듈정보저장
  - 모듈버퍼나 스폰카운트 버퍼는 파이널틱에서 알아서 생성해주는거라 파일에 세이브안함 <-확인필요
  - CParticleSystem.cpp에있는 테스트코드는 전부 삭제될겁니다.
  - 특수한 파티클을 위해서 컴퓨트쉐이더를 여러개 만들어서 고르는 구조라면 현재 ParticleUpdate정보도 저장해야합니다.
    하지만 수업에서 진행한 파티클업데이트는 딱 하나 존재하기때문에 저장안해도되는데 그냥 저장시켜줄게요 원래는 주석처리 할라켔음
  - 파티클 텍스처저오저장

 ---------컴포넌트끗

  - 스크립트 파일에 저장하기
   - CScript 는 파일에 따로 저장할건 없고, Save Load함수를 순수가상함수로 강제함( =0 ) 이제 스크립트 상속하는 모든 스크립트들은 무조건 구현해야함
     만약 어떤 스크립트가 딱히 파일에 저장할게 없다면 그냥 구현만 선언하고 비워두면됨

   - CPlayerScript
    - m_Speed는 생성자에서 알아서 500으로 세팅해주는 상태인데 왜 저장함? imgui에서 스크립트 UI에서 값 변경하면 그거 저장시켜주는 기능 구현할거거든.
      내가 최종 수정한 값 기준으로 파일에 저장되야하기떄문.

?? 저거 .h파일에 선언해논 함수 .cpp 파일에 자동으로 생성하는 단축키 뭐지??


---------자 다시 레벨 세이브로드로 돌아옵니다.

 - 여기까지 컴포넌트의 타입정보 저장후 각 검포넌트들이 저장할 데이터를 저장시키게했다.
   그 다음엔 스크립트 정보를 저장해야한다.
   이때 스크립트 매니저를 쓴다. 노가다 대신해주는. 
   
 - 스크립트 정보 저장절차
  1) 모든 스크립트를 벡터로 받아옴 GetScripts()함수
  2) 스크립트 개수 저장
  3) 스크립트를 스크립트의 이름으로 저장한다. 나중에 이 문자열 읽어서 거기에 대응하는 스크립트를 돌려주는 함수 쓰면되니까. 
   - 추가로 이 스크립트이름을 파일에 저장하고 나서, 그 스크립트가 또 파일에 저장해야할게 있을수 있으니 따로 SaveToFile() 실행시켜줌.

------------------------- 여기까지 한 오브젝트를 파일에 저장했던거고, 그 오브젝트가 소유한 자식오브젝트들도 파일에 저장시켜줘야함

 - 자식오브젝트 정보 파일에 저장하기
  0) 벡터로 자식오브젝트 불러오기
  1) 자식오브젝트 개수 파일에 저장
  2) 반복문 돌면서 모든 자식오브젝트에 SaveGameObject() 실시.


 - LoadGameIbject()
  0) CGameObject 객체 새로 하나 만들어두기
  1) 모든 컴포넌트를 타입별로 로드하는데 end나올때까지 반복문 돌린다.
     이게 가능했던 이유는 save할때 깨알같이 반복문 끝나고 남은 i값(컴포넌트end값)을 또 따로 저장해주었기때문에 그걸 파일에서 읽을때의 종료시점으로 이용하는것.
     만약 세이브시 컴포넌트가 3개였으면 load할때는 반복문은 end까지 포함 총 4번돈다
     
     컴포넌트 추가할때마다 이 부분은 유지보수하러 와야되기 때문에 default case 에 assert()를 걸어줍니다. 새로운 컴포넌트 만들었을때 case 알아서 잘 추가 해준다면
     상관없지만 까먹을 경우 디폴트로빠져서 case 추가하라고 경고띄우는거에요. 지금은 컴포넌트 추가할 생각이 없기 때문에 볼일이 없는 assert이긴 하다.
     3D할때 분명 컴포넌트 추가할텐데 이때 이 설정이 유지보수에 유용할듯

  2) 스크립트 load해주기
   - 스크립트 개수 읽어들이기
   - 반복문으로 문자열 읽어들인다음에 GetScript()로 알맞은 스크립트 받아서 오브젝트에 추가시킨다.
     또 스크립트에 따로 로드할게 있으면 로드시켜준다.

  3) 자식오브젝트 load해주기
   - 자식오브젝트 개수 load.
   - 

  4) 처음에 만들어 놨던, 그리고 load함수 실행 끝에 완벽히 구현된 pObject를 return.

-------------------------------- 이제 디버깅합시다.

 - CameraMoveScript는 따로 할거없음그냥 save load 구현만.
  
 - 클라이언트 쪽에서 pTempLevel save해보자.
  - ParticleUpdateShader를 못찾네요 레벨이 만들어지는 시점에서.
    엔진 초기화할때 파티클 업데이트 쉐이더 만들어주는거 있을텐데? 


  - CParticleSystem.cpp의 LoadFromFile()함수.
    다운캐스팅문제라고함.

    파티클이 무슨컴퓨터쉐이드를 쓰는지 저장하고 불러올려면..

    따로 하나를 선언을 해야갰다 원본을 전달하게.
    
    컴퓨트쉐이더는 단독으로 생성할수 없으니까 load에서 또 걸리네..

    컴퓨트쉐이더 관련된 정보는 save load 일단 비활성화 할게요 

 

    