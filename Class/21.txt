 - tTransform 구조체에서 matWorldInv 는 역행렬임 당장은 안씀
   matWV 는 월드, 뷰 스페이스를 미리 곱한거고 matWVP 는 월드 뷰 투영세개를 미리곱해논거

 - 이미지는 텍스처값이라고 했다. 이제 Asset type중 하나에 텍스처를 설계해보자
   CTexure도 CAsset을 상속한다
 
 - 이미지데이터를 로딩하는 부분이 다이렉트11이 오래되서 아예 별도의 라이브러리로 빠져서 관리되고있다. 즉 다이렉트 11에서는 더이상 텍스처 로드하는 방법을 업데이트 하지 않아서 이미지 로딩이 힘들것임.
   그래서 외부 라이브러리 쓰고,
   깃허브같은 곳에 직접 받아서 라이브러리 써야되지만 선생님은 선생님이 미리 프로젝트로 받아서 빌드할것임. 앞 기수에서 해논걸 갖다쓰자.

 - DirectX, External에 파일들추가 (아마 include엔 헤더파일, Library엔 라이브러리파일로 두곳에 둔걸로 보이는데 정확하게 보진않음)
 - 엔진 프로젝트 설정에서는 '외부 include 디렉터리' 의 설정에 경로를 추가.
   '라이브러리 디렉터리'에도 경로추가
 - 글로벌 헤더에 #include DirectXTex.h 추가.
   #Pragma로 디버그 릴리스 모드에 따라 추가되는 라이브러리 다르게 설정.

 - 수동으로 추가 시켜보고싶으면 깃허브로 다운받아서 적용해보라

 - ScratchImage : 지정된 확장자에 맞게 저장장치에 있는 이미지를 메모리에 가져오고, 그걸 GPU의 메모리로 보내주는 기능을 할수있는 클래스.
   즉, 하드디스크(원본이미지) -> 스크래치이미지(RAM) -> GPU 
   예를들어 포트리스에서 폭탄맞고 지형이 바뀌는 모습을 표현하고싶다면, 원본이미지는 그대로 있고, 스크래치이미지상의 데이터를 바꿔서 최종적으로 GPU에 그 변경된 이미지가 올라가야 원하는 모습으로 그려짐.
   다시말해 GPU상에 그림이 바뀌지 않으면 스크래치이미지에 뭐가 들었건 화면엔 아무런 변화가없음

 - m_Image는 원본이미지를 내 Ram에 가져와서 관리, m_Tex2D는 GPU에서 텍스처를 관리하는 용도임. 당연히 원본 이미지는 둘다 수정못함
   m_Image도 GPU를 가리키고 m_Tex2D도 가리킴. 이거 예전에 렌더타겟할때 하나를 두개가 가리키는 구조랑 비슷한거임(<- 정확한이해가필요하다)
    (혹시몰라강조 m_image == ScrachImage)

 - 전에도 이야기 했지만, 텍스처에 접근하려면 텍스처의 주소를 직접 가져오는게 아니라 그 텍스쳐를 가리키는 뷰로 접근하는게 다이렉트의 메커니즘이다.
 - 게다가 원본데이터는 같지만 여러개의 뷰를 가질 수 있다. 어떤 함수들이 어떤 뷰를 요구하냐에 따라 원본데이터는 다양한 모습으로 활용될수 있음을 뜻한다
   마치 사람은 갖지만 도서관은 도서관출입증, 일본여행은 여권 등이 필요한걸로 비유할수있다

 - 텍스처에 설정할 뷰는 총 4가지 뷰가 일단은 있고 하나의 텍스쳐는 하나 또는 여러개의 뷰를 설정할 수 있음. 즉 반드시 4개 다쓰는것도 아니고 하나만 쓰는것도 아님
 - SRV 쉐이더에서 쓰는 자원을 가리키는 쉐이더리소스뷰(텍스처레지스터바인딩. t)
 - UAV GPGPU(General Purpose GPU) ->읽기 쓰기 동시가 가능한 바인딩. Unordered Register, u

 - Asset에 파일경로를 인자로 하는 가상함수 Load를 만들게요. 모든 Asset이 이 기능이 필요한건 아니지만 텍스처로드에는 필요해서 만들었어요.
   ^& 텍스처 멤버변수 초기화때 '나머진 기본 생성자가 있어서 구조체만 초기화해줄게요' 라며 m_Desc만 멤버이니셜라이저에 초기화
  - 'Load가 가상함수니까 실제 타입에 맞게 로드 되겠죠?'
  - 경로매니저 CPathMgr로 상위경로 불러오고 인자인 상대경로 붙여줘요
  - 에셋에 이미 동일한 strKey 값이 있으면 그냥 새로 불러오지 말고 걔 있던거 갖다 쓰는 구조로 만들게요
  - 마지막으로 새 에셋이 본인이 어떤 key값인지 어떤 경로인지 설정하고 AddAsset으로 등록합니다
  
--------------------------------------------------------------------
오늘원래 어제 못한 블렌드스테이츠 해야되는데 깜빡했네요 텍스처 마저 하고 할게요

 - 에셋매니저의 Load에서 텍스처 등록하면, 최종경로를 그 텍스처가 가지고있을테니
   텍스처의 Load()함수에 활용되는 _strFilePath는 최종경로일 것이다.
 - _splitpath_s() 함수는 인자가 엄청 많다. 설명은 해주셨는데 따로 살펴보아라.
  - 첫번째인자는 경로
  - 8번째 인자는 확장자

A1 확장자 DDS, TGA 는 뭐지?

 - dds면 LoadFromDDSFile()함수로 텍스처를 가져온다. 마지막인자에 스크래치이미지를 요구하고 거기에 텍스처가 들어가게됨
   tga면 LoadFormTgaFile()함수.
   만약 위 2가지 확장자가 아닌 나머지 것들은 LoadFromWICFile()함수. 얘는 윈도우가 친숙한 확장자인 png,bmp,jpg,jpeg 등등 다목적용함수임

 - 이렇게 m_Image에 텍스처가 들어오게 되면 .GetMetadata()로 여러가지 정보를 알수있다.

 - 우리가 GPU에 텍스처를 보낸 이유가 렌더링하려고 보낸건데 이런걸 쉐이더 리소스라고함. 이런 쉐이더리소스에 접근하는 뷰가 쉐이더리소스뷰 SRV임.
   여기까지 마쳐야 텍스처 작업이 끝난것임.
  
 - 정리-> 1. id3d11Texture2D 로 빈 텍스처객체 만듬 2. 스크레치 이미지에 텍스처 불러오고 m_Tex2D에 전달(==GPU에전달) 3. SRV 생성
 - 위 3단계를 한번에 처리하는 함수를 다이렉트가 제공중. 수동으로 할수 있지만 귀찮으니까..
   CreateShaderResourceView()
    - 1번째인자)디바이스 
      2)
      마지막) SRV 이중포인터
 - 근데 위에 방법은 m_Tex2D는 null인데? 근데 정황상, GPU와 연결된게 있으니까 SRV가 있겠지. 그걸 생각해낼수있으면 SRV로 m_Tex2D를 채워넣어줄수있음.
   다시말해, 1~3단계를 생략하고 바로 3단계를 수행하는 CreateShadeResourceView() 를 쓰면 역으로 2, 1단계를 얻어낼수있다.
   그것을 코드로 확인해보라.

-----------------------------------------------------------------------------
알파블렌딩을 어캐하냐면 텍스처에 레지스터번호를 만들겁니다.
지정된 레지스터 번호로 쉐이더 리소스를 세팅합니다. 쉐이더 단계별로 다 적어줘야 모든 파이프라인에서 해당번호 레지스터에서 쉐이더가 꺼내씁니다.
안적으면? 그 파이프 라인에서는 해당 레지스터번호에 없기때문에 작업안함

HLSL에서 t가 텍스처용 레지스터이고, t0을 쓸게요

 - Texture2D g_tex_0 : register(t0);

 - UV는 RectMesh에서 예전에 잠깐 언급하고 쓰지는 않았는데 이제 필요합니다.
   UV 좌표계의 모습
    0,0  ----   1,0
    |            |
    |            |
    |            |
    0,1  ----   1,1

    각정점에 UV좌표값을 매칭 시켜 놓으면 최종 만들어진 메쉬에 매칭되는 픽셀의 위치도 정해지게 되는 것이다. <- 맞나?
     -> 추가 공부로 알아낸것: UV 좌표는 정점에 텍스처를 매칭시키는 좌표이다. 즉 텍스처를 쓰는 이유 자체를 생각해봐야한다.
        픽셀하나하나 찍기 불가능해서 텍스처를 밖에서 불러오고 거기에 메쉬에 덮어 씌우는거아닌가?
        만약 텍스처를 쓰지 않는다면, 메쉬내부공간 전체에 색깔을 지정해줘야한다.

        이전에 정점 4개사각형에서 색깔을 지정해주면 그라데이션으로 알아서 사각형 색깔을 채워주는걸 봤을것이다.
        근데 그렇게 해서 내가 원하는 그림(게임캐릭터이미지등)을 어떻게 그릴까? 너무 막막하다. 그래서 이미 만들어진 색깔 정보를 가진 텍스처를 갖다 쓰려고하는것이다.

        그니까 텍스처는 곧 내가 색깔 일일히 다 그리는게 어려우니까 미리 만들어진 그림을 가져오는 자원이 텍스처인것이다.

        그런데 내가 텍스처를 가져오긴왔는데 메쉬라는 형태에 어떻게 덮어씌우겠는가?
        만약 사각형정점 4개가있다고치자. 똑같이 사각형 텍스처 한장 불러와서 메쉬에 덮어 씌우는데 그게 항상 메쉬형태와 일치하는가?
        텍스처가 직사각형이라면?

        이런 문제를 해결해주는 좌표계가 UV 좌표계이다.

        각 정점에 텍스처의 어디 위치를 매칭시킬지 명시해주는 것이다.


 - HLSL에서 픽쉘쉐이더에서 sample 함수가 있다. 첫번째인자로 sampler로 추출하고, UV값까지 인자로 주면 그 픽셀의 색깔이 정해진다.

 - 흑백처리 쉐이더로 만들 수있음






