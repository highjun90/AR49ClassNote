 - UI클래스를 imguiMgr 클래스가  map으로 갖고있음
 
 - 제일처음 만들 UI - 인스펙터: 클릭하면 정보띄워주는UI
 - Inspector 클래스는 UI클래스를 상속
 
 - 이제 UI와 그 자식들은 생성자 호출때부터 이름(보여지는이름, ID 둘다)지정하도록함
   선생님예시로 inspector 생성자의 멤버이니셜라이저에 ID 로 "##Inspector" 라고 했는데 개인적으로 뒤에 번호 0같은거 붙이는게 좋아보임 ( "##Inspector0")

 - ImguiMgr에서 모든 m_UI에 tick()과 render()를 수행하게함
  - UI객체의 render()함수에서 전에 학습했던 Begin(), End()함수 쓰면 진짜로 화면에 나옴
  ** 만약 UI구조가 대규모로 바뀌는 작업을 했다면 실행파일 있는 경로의 imgui.ini 파일 한번 삭제해고 빌드할것을 추천 (이전에 한 작업 제거)

 - ImGui 매니저에서 들고있는 UI맵 삭제 추가

** 인스펙터, OutLiner, Content라는 대표적인 UI 만들겁니다.
 - 전부 UI 클래스 상속

 - UI클래스는 m_bActive이라는 맴버가 true 일때만 Begin End()하도록 if문을 render()함수에 걸어놈
   이걸 Begin()의 마지막 인자 bool값에도 활용하는데 갠적으로 맘에 안드는 코딩스타일임.. 용도를 공유하는거.
    - 이렇게 짠 이유가 UI창의 x버튼 누르면 m_bActive에 false 값을 imgui가 넣어줘서 다음 tick()때 if문 검사때 걸려서 안그리게 하는 구조가 된다. 
    - 여러분은 여기까지 알아도 본인이 코드짜서 단축키 누르면 UI 켜고 끄게 할수 있어요
    - Activate()과 Deactivate()함수로 m_bActive 값을 바꿉니다.

-------------------------------------------------------
% 물체의 정보를 띄워주는 Inspector UI
 1) 게임오브젝트의 정보를 보여주기
  - 가지고있는 Component(or Script) 정보
 2) Asset정보
  - 재질이라던가, 메쉬면 정점이 뭐고 등 각 에셋정보.


% 아웃라이너 UI
 - 현재 레벨의 모든 오브젝트 나열

% 컨텐츠 UI
 - 현재 에셋매니저에 로딩되어있는 모든 에셋들을 나열
-------------------------------------------------------

& 플레이어라는 게임오브젝트 정보를 인스펙터 UI에 띄우기
 - Level에 FindObjectByName()이라는 함수 만들기
  - 오버로드할거임 첫번째 함수는 같은 이름이 없는 놈을 찾을때나 같은 이름 있더라도 가장 빨리 찾은놈을 반환
                   두번째 함수는 이름 같은 모든 놈들을 인자로준 벡터에 담아서 반환
  - Tick()에서는 쓰지말것을 추천 성능저하가 심할것임

 - 지금 레이어는 최상단 오브젝트 벡터와 직접등록된 오브젝트 백터 두가지로 관리하고 있는데 두번째 벡터는 레벨을 한틱이라도 돌려야 오브젝트들이 들어가 있어서 자칫 여기서 찾을 경우 못찾을수 있음
   (구조가 두번째 벡터는 매 틱마다 오브젝트들이 저장되고 클리어되는구조임) 따라서 첫번째 벡터에서 (최상단 오브젝트정보가 있는벡터)에서 찾는다.
 
 - 즉 해당 레벨의 모든 레이어들에서 최상단 오브젝트들의 모든 자식오브젝트까지 큐에 다 넣어서 하나씩 pop 하는 반복문돌리면 결국 원하는 오브젝트를 찾는다.
   찾으면 결과벡터에 담아서 반환한다.
    - 예시) ImguiMgr.cpp 에서 create_ui()함수 다음에 레벨 풀러오고 ID로 UI 찾는코드 추가

 - Inspector 클래스에는 내가 표시할 오브젝트의 주소(m_TargetObject)와 에셋의 주소(m_TargetAsset)이있음



 - UI 렌더 기능을 2개로 분리. (render(), render_Update())
  - render_update()는 UI부모에서 구현 안하므로 자식들이 무조건 오버라이드 코드 짜줘야함
  - 자식들은 본인의 render()가 아니라 UI(부모)의 render()를 쓸것임 거기에 Begin End()가 있으니까.
    따라서 자식들(인스펙터같은애)은 본인이 구현할 기능을 render()가 아닌 render_update()에 넣어줘야함

 - render_update()에서 이름 2바이트짜리를 1바이트로 바꾸는 코드추가(imgui제작자가 C친화적이여서 wstring 지원잘안함)

=============================================================

 - Vec3에 컨버전오퍼레이터가 정의되어있음
  - operator f3() 
   - f3()는 또 typedef 되어있음
    - 자세한건 Vec3객체에서 검색해볼것


 - UI 화면에서 내가 박스의 수치를 변경하면 내가 인저로 넣어준 vPos, vScale, vRot에 저장시켜놓는다 
 - 이거를 다시 Settransform같은 함수의 인자로 넘겨주면 진짜로 오브젝트의 transform이 변경된다. 
   만약 Set 안해주면 수치변경하고 엔터쳐도 아무런 변화가 없을 것이다. set 함수들 안적어주면 변경점을 원본 오브젝트에 적용시키지 않는것 이건 선택할수있음 UI 화면의 수치 바꾸면 진짜로 변경되게 할지 안할지.
   (수치 바꾸고 엔터눌러도 그걸 진짜 적용되게 하기 싫다면 set함수들 빼버리면됨)

 - 어떤오브젝트들은 메쉬가 없는애가 있을수 있으므로 컴포넌트와 에셋 정보들을 분리해서 보여줄겁니다.
  - UI도 계층개념이 있음 이 구조를 도입하자

 - begin() 함수가 끝나기 전에 beginchild()가 실시되면 endChild() 까지 최근에 열려있는 UI를 기준으로 Imgui 코드가 실행된다. 스택개념이라고 보면됨.
   Begin()
   .
   . (어떤작업)
   .
    BeginChild()
    .
    . (어떤작업)
    .
    EndChild()
   End()

 - 즉 Begin end()는 한세트마다 각각 다른 창으로 만들어지고
    BeginChild() EndChild()는 이미 있던 부모UI 안에서 만들어지는 자식UI이다

 - 이제 UI에 계층구조를 적용시킴으로서 render()함수도 구조가 바뀌어야한다. 
   첫번째 조건은 m_bActive이고
   두번째 조건은 내가 부모일때만 Begin End()가 실행되게한다. (Parrent가 null일때만)
    - 본인(부모)UI가 할 일을 render_update()에서 실행한다.
    - 내가 할거 다 했으면, 자식UI들 for문 돌려서 걔들 render() 시켜준다.
   두번쨰 조건에서 내가 부모가 아니라면 BeginChild() EndChild()로 실시.
    - 부모 UI 처럼 내 할일을 render_update()에서 실행.
    - 이때 자식UI에서도 자식을 가질 수 있으므로 걔들도 for문 돌려주며 render() 시켜줌


   - TransformUI 클래스
    - UI클래스를 상속하긴 하지만 인스펙터를 간접적으로 부모로 가질것임

내일은 오브젝트 컴퍼넌트 출력해볼겁니다.

