_dlib - 디버그버전 라이브러리
lib - 릴리즈버전 라이브러리

ctrl shift b - 전체빌드

 - 미리컴파일된 헤더를 사용한다고 프로젝트 설정을 했으면 해당 프로젝트의 모든 cpp 파일에는 그 헤더를 포함하는 코드가 있어야한다. 
   ex) include "pch.h" ->  당연히 pch.h 이 프로젝트 내부에 만들어져있어야함


 - 헤더파일과 라이브러리 파일 디렉터리 경로를 동일하게 한 엔진임
   외부 include 다이렉트(경로) 설정을 해줬음

 - Staticlib 프로젝트 빌드 결과물이 External 폴더경로에 저장되고, Client 프로젝트가 그 External 폴더 경로의 파일들을 갖다쓴다. 
 - copy.bat 파일은 x64 파일의 파일들을 External에 복붙하게 해서 Clinet가 항상 최신 라이브러리를 참고하도록 하는 자동화 시스템을 구현한것이다.
   - 프로젝트 설정의 빌드이벤트에서, 빌드 전 이벤트에 copy.bat을 등록한다.

 - External 폴더엔 직접만든 헤더 라이브러리 파일도 있지만 외부 라이브러리(fmod)까지 총괄하여 가지고있다.

 - 동적라이브러리는 dllexport 키워드를 넣어줘야 li

 - 정적라이브러리는 최종결과물이 lib 파일이고 동적라이브러리는 dll, lib 두개 나온다.
   - 정적라이브러리는 컴파일된 코드 집합체가 lib에 들어있고 동적라이브러리는 dll에있다.
     동적라이브러리의 lib는 정적라이브러리의 lib와 기능이 완전다르다. 동적라이브러리의 lib는 dll의 어떤 기능을 쓰겟다는 암시적인 역할만한다.
   - 동적라이브러리를 쓰면 다양한 프로세스가 쓸데없이 같은 코드를 포함하지 않고 한 프로세스(dll)를 따로둬서 그 프로세스(dll)를 호출해서 그 코드부분을 실행하므로 
     같은 기능을 쓰는 각 프로세스들의 크기를 효과적으로 줄일수있다. (메모리 부담감소)
   - 만약 동적 lib에서 어떤 기능을 썼을때, 이미 관련 dll이 프로세스로 실행되고 있으면 그 실행되고있는 프로세스(dll)에 링크한다.
     만약 해당 dll이 프로세스로 실행되고 있지 않다면 exe 파일 경로에서 해당 dll을 찾아 그걸 프로세스로 하나 새로 만들어 메모리에 올린다.
     그래서 exe 파일위치에 dll 파일들이 함께 있는것이다. (딱 exe 파일이 있는 경로에서 dll 파일을 찾으므로)

   - 런타임 시간에 실시간으로 동적라이브러리를 연결하고 끊는 기능을 사용하려면 동적 lib를 포함하지 않는것이 본연의 목적대로 쓰는것이다.
     만약 동적lib를 쓴다면 런타임때 모든 dll을 미리 링크하고 런타임이 끝날때 비로소 모든 dll의 링크를 끊으므로 동적라이브러리를 사용하는 의미가 사라진다.
     띠리서 오히려 동적라이브러리는 #pragma 코드 부분을 빼는것이 대체로 옳다.
     허나 수업에는 그러한 작업을 구현하는건 거의 불가능 하므로 동적 라이브러리를 쓴다면 암시적링크를 쓰던가 아예 정적 라이브러리를 쓴다.
