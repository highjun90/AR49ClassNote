 - 오브젝트에서 finalTic() 에서 Dead 상태라면 가비지컬렉터로보냄 거기서 어떻게 처리할지는 아직 안정함
   그리고 부모에서도 지워버림 만약 부모가 레이어라면 레이어에서 빼버림

 - GC (가비지커렉터)에서 쓰레기가 100개 이상 쌓일때 싹 clear
 - DestroyGameObject()함수는 오브젝트 제거하는 태스크 함수. 전역함수인걸로보였음

 - 바로삭제 안하고 가비지커렉터로 보내는 이유는 한 Tick()내에 그걸 참조하는 애들이 있을때 삭제된걸 참조하는 상황을 대처할 여유를 두도록 설계한것임
 선생님의오류설명) 헤더정보가 없으면 소멸자가 정상적으로 호출이 안되는 사례를 눈앞에서보다

 - 추가로, 본인이 dead할때 자식들까지 전부 dead해주는 코드를 태스크에 추가.

 ===== 생성삭제끝 =====
 ===== 지금뜨는 샘플러오류해결하기
 파이프라인으로가자

  - HLSL에서 샘플러 레지스터는 s임 (s0,s1...)
  - UV좌표계와 투영좌표계(NDC) 헷갈리지마세요
  - 샘플링이란 UV좌표계를 참고해서 메쉬에 텍스처를 매핑하는것 <- 그 과정에 mip map이 있음
  - 지금은 있지도않는 샘플러로 텍스처를 매핑하고있어서 s0에 왜 null이냐 샘플러 만들어라 그리고 일단 샘플러 디폴트 설정으로 해주는데 그게 니가 의도한게 아닐수있다고 디버그창에 알려주는상태임.
  - 샘플러는 굳이 type을 enum으로 안만들고 2짜리 배열로 만들게요
  - 이름도 원래 규칙대로 RS(레스터라이저 스테이츠) 이런식으로 하면 SS(Sampler State) 인데 좀 이상해서 Sampler라고함

  - s0 레지스터에서는 0번샘플러. 이방성필터. 3D에서 주로 활용
    s1 지정된 색상값을 변동없이 가져오기. 2D는 이걸 많이씀

    각 샘플러들을 context의 모든 쉐이더(PS,VS, HS 등등)에 s0, s1에 전부 매핑시켰음

 - 만약 원본이미지 보다 출력하는 화면이 더 커지면 픽셀 사이의 색깔을 보간해서 색을 채워넣는데 이게 이등방성. 이미지가 흐리게나옴
   두번째 샘플러를 쓰면 픽셀 사이의 색깔을 보간을 안하고 UV좌표에 가장 가까운 같은색깔(원색)으로 집어넣음 그래서 계단현상이 나옴
   정리하면 UV좌표계에 가장가까운 픽셀들의 평균적인 색깔로 칠해주냐, 아니면 그냥 가장가까운 픽셀의 색 딱 하나 집어서 칠해주냐의 차이.
   그래서 우리는 2D하니까 주로 두번째 샘플러를 쓴다.

 - Material 개념 이해하기
   이제는 쉐이더를 다이렉트로 가리키지 않고 Material을 사이에 낄겁니다.
   원래는 1.메쉬선택 2.쉐이더선택이었다면
   이제는 1.메쉬선택 2.재질선택 2-1. 선택한 재질에 쉐이더가 매핑되어있음
   
   즉 같은쉐이더를 쓰더라도 상황에 따라 다르게 동작하게 만들고 싶을때가있다. 예를들어 몬스터가 피격될때만 빨간색으로 잠깐 그려지게 하는 기능을 조건문으로 쓰고 싶다면, 그 신호가될 파라미터를 받아야하는 것이다.
   그걸 재질(머터리얼)이 한다.

   같은 느낌의 금속을 표현하는 쉐이더가 있어도 세세한 수치에 따라서 다른 느낌을 내게 하고싶은데 이게 머터리얼이 없다고 생각해보라.
   내가 원하는 새로운 느낌의 쉐이더를 만들고 싶을때마다 일일히 새로운 쉐이더를 만들어야 하는데 힘도들고 메모리도 낭비다.
   그냥 같은쉐이더에 수치만 딸깍해서 쉐이더 느낌을 조절하면 좋을것이다.
   그것이 재질이다

 - 제질도 에셋이다. 다양한 오브젝트들이 돌려 쓸수있는 것이다.
 - 머터리얼 상수라는 구조체를 만들자. (tMtrlConst) 쉐이더에 전달할 데이터 형식이다. 웬만한 쉐이더에 다 대응되게 맴버변수가 들어있음
 - CMaterial 구조체에는 크게 3가지 멤버변수가 중요하다. 머터리얼상수, 텍스처, 쉐이더.
 - 스칼라 값을 자주쓰는데 이거는 자주써서 쓰기불편한 enum class 말고 그냥 enum으로 정할게요. SCALAR_PARAM
   TEX_PARAM 는 10개 즉 재질로 한번에 보낼수 있는 텍스처가 최대 10개.

 - tMtrilConst에 대응하는 상수버퍼가 CB_TYPE에 미리 만들놨었죠.(MATERIAL_CONST, b1) 본인의 타입값(CB_TYPE:MATERIAL_CONST == 1 == b1) 자체가 레지스터버퍼슬롯위치죠 

 - HLSL에는 배열의 최소단위가 16바이트 이므로 내가 int배열 4개를 보내도 제대로 동작을 안한다. 그래서 수동으로 int를 일일히 4개선언해줘야한다. 
   만약 무시하고 int arr[4]를 똑같이 HLSL에서 int arr[4] 만들었다고 치자. 내가 arr[1]에 접근하는 코드를 짜면 0바이트 기준에서 4바이트 떨어진 곳을 참조하는게아니라 16바이트 떨어진 곳을 참조함.
   아니면 애초에 배열하나의 크기가 16바이트 짜리로 만들던가. 그니까 16바이트 짜리 구조체의 배열은 HLSL와 매칭 되려나?

 - 이제 렌더컴포넌트는 다이렉트로 쉐이더 참조를 안하고 머터리얼을 참조합니다.
 - 메쉬렌더도 쉐이더관련 코드가 머터리얼로 바뀝니다.

 - 이렇게 되면 HLSL에서 g_int_0(머터리얼상수) 값에따라 얼마든지 색을 바꿀수 있는 쉐이더코드를 짤수가 있습니다 런타임실시간으로