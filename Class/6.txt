1. 쉐이더 함수를 컴파일 해봅시다.

 - #pragma once : 중복되는 헤더를 무시한다. 
   C에서는 이 기능이 없어서 #ifdef, #define, #endif 를 쓴다.
   그런데 이걸 HLSL에서 똑같이 쓴다. HLSL도 C스타일로 헤더의 중복을 막는 것이다

 - HLSL 에서 바이너리코드로 컴파일된 함수주소를 저장하고있는 포인터가 필요한데, Blob를 쓴다
 - outputfile binary content파일경로에 쉐이더 코드(std2dfx)파일을 저장해 놀거고, 역시 매번 빌드할때마다 복붙 귀찮으니 bat파일로 편의기능을 만들어 두자.
 - (위처나 갓오브워 같은게임보면) 설치폴더 안에 쉐이더코드들이 같이있다. 런타임 시간에 쉐이더바이너리 코드를 만들기 때문이다. 
    넥서스 모드안에 쉐이더 모드들은 그냥 원래 게임폴더 안에 있는 쉐이더 함수를 보고 그걸 살짝 고쳐서 올리는 것들이다.
   즉, 비주얼 스튜디오의 fx파일은 비주얼 스튜디오가 어느정도 문법검사도 해주니까 + HLSL로 어셈블리 안쓰고 쉽게 쉐이더 코드 개발하려고 쓰는거지 실제 실행되는 코드는 아니다. 
   실제 실행되는 코드는 outputfile/content/shader 파일에 바이너리 코드로 빌드되어(bat도움받아서) 있을것이다. -> 잘못이해했을 수도 있음. 그냥 런타임때 이 fx파일 참고해서 바이너리 코드로 바로 만들어서 쓰는건가?

 - 키매니저, 타임매니저,패스매니저 같은경우 옛날 윈도우API에 썼던것들을 그대로 가져올게요 직접 안만들고. (그냥 컨트롤 c 컨트롤 v했음)
   (그리고 싱글톤 상속, define 정의 single 같은 자잘한 작업함 그냥 현재 directX 구조에 맞게 수정한거임)
   각 매니저들의 tick() 함수는 한번의 작업을 나타내는 건가?

 *** Blob은 그냥 버퍼라고 생각하면됨. 쉐이더 함수는 바이너리 코드를 들고있겠고, 에러표시해주는 블롭은그냥 문자열 저장하고있겠지 딱 데이터 형태가 고정적인건 아님
 - 드디어 D3DCompileFromFile() 함수로 쉐이더함수를 컴파일한다. 쉐이더 함수의 이름과 버전, 기타 옵션을 인자로 적어준다. D3DCOMPILE_DEBUG 모드로 해야 비주얼 스튜디오에서 못잡아주는 오류를 오류박스 띄워주면서 잡아준다.
  - g_VSBlob에서 GetAddressof()로 쉐이더의 바이너리 코드를 갖게된다.
  - g_ErrBlob에 어떤 내용이 들어있다면 쉐이더함수 컴파일에 실패한거고, 거기에 저장된건 문자열 이므로 char 형으로 참조해서 오류메세지 박스를 띄운다.

 - 이제 Device->CreateVertesShader()로 컴파일한 쉐이더함수로 장치에 쉐이더 함수를 등록한다. ->맞나? 더 정확하게 이 함수 공부해볼것

2. 픽셀 쉐이더도 앞서 버텍스 쉐이더 만들때 했던 1번작업과 비슷한 과정을 합니다.
3. 지금까지 한거 정리
 - 전역변수에 정점3개 3각형 위치 지정 
 - GPU에 버텍스 버퍼를 통해 그 정보 전달
 - Blob을 통해 쉐이더 만들어서 GPU에 전달?
 - g_VB 라는 버퍼를 자세히 공부해라 context가 다 이걸로 작업한다.

 - 이제 위에서 사전에 설정해준걸 바탕으로 한거
  - IA에 버텍스 버퍼 등록. (정점들 등록. 그 정점에 여러 정보가 있겠지 포지션 컬러 등등)
  - VS, PS 각 쉐이더를 통해 각 모든 정점에 일일히 쉐이더 작업 함.
    (VS, PS 사이에 레스터라이저같은건 디폴트 작업이 있어서 굳이 언급안했는데 VS 다음에 레스터라이저, 그다임에 PS 작업이 이루어 진다는걸 꼭 명심해라)
    ( 레스터 라이저는 정점들 사이의 픽셀들을 하나의 영역으로 만들어 주는 것이다.)
 *** 렌더링 파이프라인 과정은 암기해야합니다. 적어도 DirectX로 작업했다고 한다면.

 - 토폴로지란, 정점을 통해 만들고자 하는 도형을 지정하는 설정이다. 즉 몇개의 정점으로 어떤 도형을 만들건지 (선을 만들건지, 삼각형인지 사각형인지) 알려줘야한다.
   토폴로지를 바탕으로 레스터라이저 단계에서 그 정점들이 만들고자 하는 도형에 맞게 그려져야될 픽셀영역을 결정해준다.
   토폴로지란 다시말해, 내가 전달한 버텍스 버퍼의 

 - 정점 하나에도 인풋레이아웃이 있다. 이것은 정점하나의 구조를 알려준다. 
   iStride(스트라이드가 직역하면 보폭이다) 에 Vtx(버텍스) 하나의 크기를 말한다.
   iOffset이란 오프셋인데, Stride에서 알려주는 하나의 버텍스 크기를 바탕으로, 그 버텍스들을 몇개씩 묶을 것인지 설정하는 것이다. 이 오프셋을 쓰면 상체는 그리고 하체는 안그리고 이렇게 일부만 그리게 하는 응용도 할수있음
 
 - g_Layout은 앞서 만든 버텍스(Vtx)의 정확한 구조(이것을 정점 구조정보 라고함)를 알려준다. 우선 우리가 만든 Vtx에는 position, color, UV 이렇게 3개로 구분된다.
   D3D11_INPUT_ELEMENT_DESC에 그 정보를 담는다. 요소개수만큼 필요하므로, 배열로 3개만든다.

   inputslot은 버퍼의 몇번째 슬롯을 쓰는지 알려달라는 거다. 일단 0번 슬롯을 쓰므로 0을 적어준다(한번에 여러개의 슬롯을 전달할 수 있는데 우리는 아님 0번슬롯만 쓰고있음)
   SementicName : HLSL 내에서 사용되는 요소의 변수이름을 알려달라는 것이다. 반드시 이 이름과 GPU에서 사용하는 아름이 같아야한다. sememtic의 정확한 의미는 정점의 메모리에서 일정 영역을 말한다.
                  만약 Position 이라는 sementic이 있다고 치면, 하나의 정점(VTx)가 GPU 상에 들어왔을때, GPU는 정점의 메모리 영역에서 이 sementic 이름이 같은 변수를 찾아 매칭한다.
                  sementic 이름이 곧 vtx(버텍스) 구조체의 특정 메모리 영역이다
                  나중에 이걸 응용하면, 각 쉐이더에서 필요한 정점의 정보만 쏙쏙 뽑아서 갖고올수있다. 나중에가면 하나의 버텍스에 딸린 레이아웃이 엄청 많아진다. 그런데 쉐이더는 거기에서 필요한 정보는 
                  정해져 있는데 한 정점의 모든 레이아웃 정보를 가져올 필요가 없다. 이 sementic 키워드를 쓰면, 하나의 정점에서 그 쉐이더가 필요한 레이아웃만 쏙 뽑아서 쓰면 되므로 메모리 절약이 가능하다.
                  HLSL 뒤에 변수 뒤에 콜론(:) 붙여있고 뒤에 오는 문자열들이 바로 semantic 이다.

                  만약에 내가 레이아웃을 설정하고 있을때, 동일한 이름으로 semantic 이름을 주고 싶으면 어떻게 할까?
                  이때 쓰는 옵션이  SemanticIndex이다. 그래서 엄밀히 이야기 하자면 HLSL 상에서 쓰이는 semantic 이름 뒤에 이 index숫자가 생략됬다고 이야기 할수있다.
                  예를 들어, HLSL에 semantic 이름으로 Position 이라는 변수가 있다고 하자.

  - 레이아웃 Position 분석
    AlignedByteOffset 이 정점상에서 이 레이아웃의 시작위치이고, Format대로 (12바이트) 만큼의 크기를 갖고있꼬, 이 메모리 영역의 이름(semantic)은 Position이고, 
 
  - 이렇게 각 레이아웃의 정점상에서의 위치(AlignedByteOffset), 포멧(메모리크기), 이름(semantic) 알려주는게 정점의 레이아웃 설정이라는 것이다.


4. 정점의 color를 이해해보자.
 - 예를 들어, 정점3개로 삼각형을 만들었는데 각 색깔을 R,G,B로 다르게 하고 화면에 나오게 해보면 그라데이션으로 삼각형 색깔이 나온다.
   내가 정해준 정점은 3개밖에 안되는데 결과물에 나와야 하는 픽셀은 몇만개이다. 나머지 픽셀들은 대체 어떻게 색깔을 정해야할까?
   레스터라이저가 디폴트로 결정해준다. 어느 무작위 픽셀을 골랐을때 정해지는 색깔은, 각 3개의 정점에서 떨어진 거리에 비례하여 각 색깔을 적절하게 섞는다.
   정중앙의 픽셀은 3개 정점에 동일한 거리에 떨어져 있을테니 색깔 비율도 거기에 맞게 R x 0.333... G x 0.3333... B x 0.333333.... 이런식으로 색깔 계산이 이뤄져서 회색이 나온다.

 - 앞의 원리를 응용해서, 원본 이미지가 정사각형이 아니래도, UV 값을 이용한다면 어떤 모양이던 그 UV 값에 대응해서 색깔을 픽셀쉐이더에서 가져온다. 즉 API 처럼 좌표값에 일일히 대응하는게 아니라
   UV라는 상대값으로 픽셀쉐이더에서 색깔을 칠하므로 이게 회전을 하던 뭔 짓을 하던 텍스처 자체의 모양은 달라지더라도 대응하는 이미지 색깔이 이상해지지는 않는다. 
   이미지를 늘리고 줄여도 전체적인 텍스처의 색깔의 비율은 무너지지 않는다는 말이다.



 

- 내가 이해한거 개인적으로 정리
 1. VTX로 버텍스 구조를 만든다.
 2. IA 작업을 한다.
  - VTX의 stride(버텍스 하나의 데이터 크기) 와 offset(버텍스버퍼에서 몇개의 버텍스를 묶어서 한 단위로 만들지)를 지정한다.
  - 토폴로지 설정 (몇개의 정점으로 어떤 도형을 만들지 설정해줌)
  - 레이아웃 설정 (하나의 버텍스가 가진 정보들을 정확히 알려주기)
 3. 쉐이더 만들고 등록하기