 - 오늘은 여러분이 포폴할떄 도움이 될만한 기능을 추가해 볼게요

 - 스크립트UI 만들기
 - ScriptUI 클래스
  - 컴포넌트UI 상속합니다.
  
 - 지금 구조는 만약 오브젝트가 트랜스폼컴포넌트를 갖고있었다면, 인스펙터에서 트랜스폼UI를 띄워주는 형식이다.
   이때, 스크립트는 오브젝트가 여러개 가실 수도 있다. 플레이어 스크립트와 캐릭터인포 스크립트 두가지를 갖고있을때
   이 두 스크립트를 동시에 인스펙터에 보여줘야한다.

   따라서 인스펙터는 스크립트 UI를  m_arrComUI 외에 m_vecScriptUI를 벡터로 따로 들고있는다.
   어떤 오브젝트는 스크립트가 없을수도있어서 초기화는 따로 수행하지 않는다.

 - SetTargetObject()함수
  - 컴포넌트 UI 활성화 하는 코드밑에 스크립트 UI활성화 하는 코드를 추가한다.
   - if 문에서 만약 이 오브젝트가 스크립트를 갖고있지 않으면 스크립트UI활성을 안하게한다.
     만약 스크립트를 하나이상 들고있었으면, ResizeScriptUI()함수를 실행한다.

    - ResizeScriptUI()
     - 인자로 오브젝트의 스크립트 개수를 받는다.
       반복문 돌면서 스크립트UI 하나씩 넣어줌
       
   - SetTargetObject()는 컴포넌트 타입이 맞으면 컴포넌트 UI에 주소를 할당해주는 함수여서 스크립트 전용 함수가 따로 필요하다.
   - SetScript()함수.
     - 인자로 받은 스크립트포인터에서 스크립트의 이름을 받아온다. 받아온 스크립트 이름을 스크립트UI의 이름으로 설정해준다. (ID와 인스펙터 상에보이는 타이틀 둘다.)
       스크립트 UI를 활성화해준다.

 && leak 나왔던이유 -> 인스펙터에서 스크립트 UI를 맴버배열에 추가만 했지 자식으로 추가시켜놓지 않아서 스크립트UI의 release가 부모 인스펙터로부터 호출되지 않았음
                       인스펙터가 스크립트UI를 AddChildUI()해줬어야함

 - 파라미터함수를 이용해서 머터리얼의 값을 변경했는데 스크립트도 비슷한걸 만들어보고싶다.
 - 그래픽쉐이더에서 스칼라 파라미터 목록을 벡터로 들고있다. 이걸 스크립트에서도 맴버로 들고있게하자 (m_ScalarParam 이름이똑같음)
  - AddScalarParam()부모쪽 함수를 protect쪽에 놓는다.
 - Scalar_Param은 머터리얼 쪽 값이래서 스크립트 파라미터를 따로 정의하겠다.
 - enum class SCRIPT_PARAM,  define.h
  - 안에 인트도 있고 float도 있고. 머터리얼 구조를 스크립트에 그대로 갖다쓰는게 부담시러서 새로정의.
 - 구조체도 새로만든다. tScriptParam
  - 두번째 인자로 데이터 설명정보(문자열, 이 데이터가 뭐하는 놈인지 설명).
  - 세번째 인자로 데이터 주소(보이트포인터)를 둔다.

 - 플레이어 스크립트에서 예시를 들어보자
  - 속도추가해보기. AddScriptParam(SCRipt_PARAM::FLOAT, &m_speed)
   - 플레이어 스크립트의 m_ScriptParam 맴버백터에 데이터가 추가된다. 

 - render_update(), ScriptUI
   -GetScriptParam()으로 파라미터 목록들을 받아와서 반복문으로 데이터 모두 타입에 알맞게 저장된 데이터를 설정.

 - 프로그램 실행해보면 인스펙터에 플레이어의 스크립트에 Player Speed에 500이 떠져있는걸 볼수있다. 이걸 1500으로 바꾸면 실시간으로 속도가 변하는걸 확인함.
 && 강조한것이 레벨 play상태에서 수치 바꿔도 저장 안된다는걸 재언급.
    + 재질 파라미터를 UI에 연동한것과 구조가 똑같아서 그걸 고대로 이용해서 구조만들었다고 언급.

==================================================================================================================================

 - 게임용컨텐츠매니저(인벤토리매니저 등) 이런애들은 매니저급 스크립트를 따로붙이는 오브젝트에 다 붙이세요. 얘는 트랜스폼컴포넌트 딸랑하나 들고있겠죠.
   하지만 어쨌든 오브젝트 구조를 가지고있기 때문에 tick() 돌곘죠. 게임용 싱글톤패턴이라고 생각하시면되요. 우리 엔진이 유니티구조랑 비슷하거든요
   유니티는 코드를 제공하지 않아서 오브젝트의 스크립트를 부착시켜서 시스템을 제어하거든요.
   인게임용 매니저를 그렇게 유니티 방식의 싱글톤 패턴으로 해도되고, 하드코딩으로 언리얼 스타일처럼 직접 외부코드로 작성하는 싱글톤으로 해도되요. 
   다만 우리엔진이 유니티랑 비슷해서 전자가 방향성에 더 적합한거구요.

   만약 누가 스크립트를 요청했다면 오브젝트가 들고있었으면 그거 쓰면되고, 최초로 요청한거면 그때 새로 등록하면됩니다 <- 상황자세하지않음
   

   