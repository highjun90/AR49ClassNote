 - 파티클에 따라 컴퓨트쉐이드 버전을 다르게 만들것
 - 파티클 시스템 전역으로 통용되는 데이티 만들기
  tParticle은 파티클 입자 하나가 가져야할 데이터고 tParticleModule은 그 파티클들의 공통적인 정보를 관리
  모듈종류는 계속 추가될 예정

 - tParticleModule
  //sapwn 모듈 -> 파티클이 처음 스폰(최초생성) 될때의 데이터
   vSpawnColor            - 최초생성시의 파티클색상
   vSpawnMin,MaxScale     
   Min,MaxLife            - 파티클의 최소,최대수명
   SpawnRate              - 파티클 초당 생성개수
   SpaceType              - 부모오브젝트를 따라다닐지, 본인만의 월드좌표계를 유지할지 좌표계를 설정
                            전자는 이펙트가 캐릭터를 따라다녀야 되는 오라같은 경우, 후자는 나타난 자리에 캐릭터 따라다니지말고 계속 존재해야되는 경우

 - 파티클모둘로 컴퓨트쉐이더가 어떻게 파티클들을 생성하고 관리할지 알 수있는거고, 이 모듈정보를 전달할 구조화버퍼 하나를 더 만들어야함
   => CParticleSystem 클래스에 멤버 두개 추가.
    - 모듈버퍼는 크기가 1이면 되고 읽기만하면됨. 시스템 메모리는 true

 - fx에는 RW가 아니라 그냥 StructuredBuffer<>로 파티클 모듈 정보를 받는다. 
 - 컴퓨트쉐이더가 편하긴한데 특정상황에서는 동기화가 필요. 같은 작업을 한다면 다른 쓰레드들을 일시정지 시킬 필요가 있다.
   예시로 비활성화된 파티클들 중에서 제한된 갯수의 파티클만 활성화 시키고 싶을때 단 1개라도 활성화 시키라고 하면 컴퓨트 쉐이더 입장에선 무조건 파티클을 활성화함.
   파티클 1000개 비활성화 되어있고 1개만 활성화 시켜라고 해도 각 쓰레드 입장에선 어 한자리 남아있네 이러고 딴 쓰레드 고려 안하고 자기 입장만 생각하기 때문에 파티클 1000개 다 활성화됨
  - 이제 파티클 시스템에 필요한 버퍼는 3개가됨. 파티클 자체의 정보를 가진 버퍼, 그 파티클들을 어떻게 업데이트 해야할지 알려주는 버퍼, 이번틱에 몇개의 파티클을 활성화해야할지 알려주는 버퍼 총3개가 됬다.
    파티클버퍼, 파티클모듈버퍼, 파티클스폰카운트버퍼.
 
 - 아토믹함수(원자단함수)를 통해서 인터락을 걸어서 쓰레드간 동기화를 실현한다.

 - 렌더 컴포넌트인 ParticleSystem.cpp 에서 파티클, 파티클 모듈, 스폰카운트 정보 다 갖고있고 거기에 쉐이더코드의 컴퓨트쉐이더인 파티클 업데이트 포인터까지 가졌다. 그 파티클 업데이트는 또 파티클 시스템이 가졌던
   버퍼 정보 3개를 또 가진다.


===========================================================
 - Qa2x82Mz

 - 아토믹 함수도 종류가 많은데 우리는 interlockedExchange() 라는 함수를 쓸겁니다.
  - 첫번째인자로 목적지 
    두번쨰로 목적지를 어떤값으로 바꾸고 싶은지
    세번째는 out인데 이게 레퍼런스라는 거에요 내가 넣어준 값에 뭐가 담겨서 나오겠죠 g_Spawn어쩌구가 바로 그값입니다.

    InterlockedExchage(SpawnCount, SpawnCount - 1, Origin)
    해석하자면 SpawnCount의 값을 SpawnCount - 1 값으로 변경해서 그 결과를 Origin에 넣어준다. 
    만약 Origin이 0보다 크다면 이 쓰레드는 스폰카운트 하나 깎아먹어서 파티클 활성화하는게 성공한거다.  
    Origin에 있던 값이 0보다 컸다면 그 쓰레드는 성공한 것이므로 파티클을 활성화 시켜준다.              

   








