* 중요한건 다해서 오늘은 구조를 바꾸겠다. 오늘 뭘 더 추가해서 배우는것은 없음 => 메쉬와 쉐이더라는 껍데기 만들기



 - Modeling space 또는 local space ->  맥스, 마야 블랜더로 디자이너들이 작업하는 화면임
 - 로컬스페이스에 만들어진 모델(우리가 지금까지 만든 사각형같은거)의 정보를 가진 리소스를 메쉬라고 하자. 
 - CAsset(리소스객체) 만들기
   CAsset은 CEntity를 상속한다. CAsset은 리소스를 말한다. 즉 메쉬의 상위개념이다.
   이것을 레퍼런스카운트로 메모리관리 하는 구조로 만들거고, 이게 0되면 메모리에서 삭제할거다. 
   asset은 type이 있고 이거을 enum 클래스에 정의해 두었다. 그리고 한번세팅하면 못바꾸게 하려고 const로 했다.

 - 메쉬에서 가져야할 정보는 버텍스버퍼, 인덱스버퍼, 관련 Desc, 버텍스카운트(개수), 
   시스템메모리상에 버텍스, 인덱스버퍼 주소정보를 저장할거.
    -> m_VB, m_IB 는 GPU 메모리공간을 가리키는거고, 가끔씩 이 두개가 GPU에서 오류로 잊어먹는 경우가 있는데 그래서 내 시스템 메모리에도 주소값저장해놓는 안전장치를 마련하고 싶어서
       m_VtxSysMem, m_IdxSysMem 보이드포인터도 함께 만들어둔다
       (참고-> 앞에 m_ 이거는 메쉬라는 뜻. 이전엔 g_ 였는데 이건 글로벌이라는뜻)
       인자로 받은 _Vtx, _Idx 주소를 memcpy함수를 통해 m_VtxSysMem, m_IdxSysMem에 복사하여 메쉬 자체에서 동적할당해서 관리.
       이건 delete 직접해줘서 릴리즈해줬다.

 - 메쉬의 UpdateData()함수는 인풋어셈블러에 본인(메쉬)과 매핑시켜준다
 - Render() 함수는 Draw()함수로 마침내 모델을 그린다.

-- 여기까지 한 작업을 Mesh라는 객체에 포장지 하나 더 싼게 끝이다. 
-- 이제 동그라미 메쉬를 만들어보자.

 - 동그라미는 가운데 원의 중심을 공유하는 삼각형들이 빙 둘러서 나열하는형태로 만든다.
 - cosf, sinf 함수는 인자로 각도(새타)를 주면되는 삼각함수인듯 f는 실수?
 - 인덱스 지정해줄때 i+2 부터 하네.. 012 가 아니라 021 이런식으로 묶어주네 좀 맘에 안든다 직관적이지 않아서
 - 삼각형 10개로 원 만든다더니 for문은 11번 돌게하는 이유는? 맨 마지막 삼각형이 오버되서?? 어쨌든 이유가 있었는데 제대로 이해 못함
   선생님대로짜면 오류없이 삼각형 10개로 원만드는 논리가 된다고함.
 - 역시 circle메쉬도 마지막에 릴리즈해줌
 - 삼각형 40개로 늘리면 더 부드러운 원이됨
 - 타원이 되는건 어쩔수없음 ndc좌표계를 썼는데 마지막 출력되는 화면은 가로비가 더 크니까. 그게 싫으면 처음 ndc좌표에서 위아래로 긴 타원이 되야 최종 출력이 딱 원이 될것임


-- 이제 쉐이더작업도 클래스라는 껍데기를 덮어주자.

 - CShader 라는 쉐이더의 상위개념을 CGraphicsShader가 상속.
 - 메쉬처럼 Asset Type에 enum class중에 하나로 타입지정.
 - Graphicsshader에는 VS,Hs,DS,Gs,PS 등 모든 형태의 쉐이더를 blob으로 스마트포인터 멤버를 가진다.



** 모든 오브젝트는 본인의 모양(메쉬)를 정하고, 그 모양의 그려지는 방식(쉐이더)를 정한다.
   예를들어 모양(메쉬)는 같은데 카툰쉐이더를 고르거나 실사쉐이더를 골라서 다르게 그려질 수 있다.
**** 나중에 레스터라이저 및 뎊스스텐실스테이츠, 블랜딩스테이츠를 지정해야한다. 꼭 쉐이더에서 지정해줘야함.

 - 모든쉐이더 만들때 전에 했던거처럼 경로와 버전을 인자로 전달한다. CreateVertexShder() 같은함수가 총 5개 있다. 
   _strHLSLVer인자는 HLSL에 정의된 쉐이더함수의 이름임
   _strRelativePath는 상대경로라는 뜻

A. wstring 한번더 짚고가시오

 - '내가 사용할 쉐이더를 지정해놓고, 원하는 메쉬를 렌더하는거죠' 실제로 지금 순서가 쉐이더부터 지정하고 특정형태의 메쉬를 render()했다.

- 지금 관리자가 context하나인데, 지금 정의안한 쉐이더도 기본적인 조치를 해줘야 내가 의도한 파이프라인 세팅된대로 렌더한다.
   즉, 파이프라인에 세팅된 이전 쉐이더들이 남아있을 수도 있으니 설령 hull 쉐이더를 사용 안하더라도 비어있는 쉐이더를 파이프라인에 전달해서 혹시모를 이전작업에 남아있을 수도있는 쉐이더 함수를 비워준다.

- 레이아웃은 쉐이더에 둘것이다.왜? 어떤 메쉬는 버텍스버전1 어떤메쉬는 버텍스버전2 이래버리면 복잡해지니까 선생님 엔진은 버텍스의 구조를 고정시켜버릴것이다.
  즉 vtx는 pos, color, uv 딱 3개의 구성요소만 가지게 할거다. 이렇게 버텍스의 구조가 고정되면 쉐이더에 레이아웃을 둘 수있다. 메쉬에 안둘거임
- 토폴로지도 쉐이더에 둘거다. 정점들을 어떻게 어떤도형으로 구성할건지 결정하는거니까 쉐이더랑 더 연관이 있다. 
  디폴트 토폴로지는 TRIANGLELIST(삼각형)로 설정하겠음.


지금까지 메쉬 두종류를 만들었습니다. (사각형, 원) 결과는 똑같지만 코드를 잘 묶어서 구조화한겁니다. 이제 오브젝트라는 개념을 연장해서 설계해봅시다.
하나의 오브젝트를 게임오브젝트라고 할거에요

 - CGameObject도 CEntity 상속합니다.
 - 컴포넌트를 고정숫자로 정확히 관리할거기 때문에 벡터대신 배열로 해서 코드를 더 간결하게 할겁니다.
 - enum class로 COMPONENT_TYPE을 만들어봅시다.
  . TRANSFORM -> 오브젝트의 위치,크기,회전
  . COLLIDER2D -> 2차원충돌체
  .         3D    3차원충돌체
  . ANIMATOR2D -> 스프라이트애니메이션
  .         3D -> Bone Skinning Animation
  . CAMERA  -> 카메라 기능을 해주는 컴포넌트
  . LIGHT2D -> 2차원광원
  .      3D -> 3차원광원

  // 밑에는 렌더링 기능을 가진 컴포넌트
  . 메쉬렌더, 타일맵, PARTICLESYSTEM, 등등등

 - CGameObject는 CComponent를 배열로 갖고있다.


   