 - 디바이스 + 컨텍스트 만들기 
  - D3D_DRIVER+TU[EHARDWARE : GPU가 없다면 오류남. GPU로 DEVICE를 초기화 하겠다는뜻
  - 이중포인터 달라고 하는 이유 - 포인터에 디바이스의 주소값을 넣어주려면 그 포인터의 주소값으로 접근해야 되니까 포인터의 주소(= 이중포인터)
  - 마이크로소프트 레퍼런스에 다 있는 내용이므로 외울필요없이 참고하라
  - createDevice함수로 디바이스와 컨텍스트 객체를 가리키는 포인터들을 얻음
  - 장치초기화 종료

 - 스왑체인만들기
  - dxgi_swap_chain_desc 로 스왑체인의 사전정보를 구조체에 적어야 만들수있음
   - 스왑체인을 만들면 스왑체인이 관리하는 버퍼까지 만들어진다. 그 버퍼의 정보를 적어준다.(그 버퍼는 랜더타겟이라고 보면됨)
     만들어진 버퍼는 PC의 메모리가 아니라, GPU의 메모리를 사용하는 것이다.
   - BufferCount = 1 스왑체인 여러개일 필요가 딱히없음
   - BufferUsage -> 이 버퍼는 렌더타켓으로 이용되는 거라고 명시하는 값을 넣었음
   - BufferFomat -> 이 버퍼에 그려지는 픽셀들의 형식. 맨뒤에 unorm은 0~255의 정수값을 0~1 사이의 실수값으로 바꿔서 쉐이더에 전달하겠다는뜻
   - scaling은 언스페서파이(특정한설정안함) 즉 디폴트값이 된다.
  - 정보를 적었으니 스왑체인을 만드는 권한을 얻어와야한다.
   - 디바이스에서 어뎁터를, 어뎁터에서 팩토리를 얻어와서 그 팩토리에서 비로소 createswapchain 함수로 스왑체인 만듬.

 - 랜더타겟, 뷰 만들기
  - ID3DResource란 GPU상에 있는 메모리들에 접근하고 관리해주는 객체이다. 
    얘를 상속하는 애들중에 ID3DBuffer, ID3DTexture(이미지형태관리)등이있음
  - 앞에서 만든 스왑체인 함수중에 GetBuffer함수가 있는데, 거기서 ID3D11Texture2D가 그 렌더타겟에 접근할 권한을 갖게한다. 이제 얘가 GPU상에 있는 렌더타켓 메모리공간에 접근하는 것임
  - 스왑체인 릴리즈하면 알아서 걔가 들고있던 렌더타켓같은 메모리를 자동으로 릴리즈하게 설계되어있다 허나,
    우리가 직접 참조하는 ID3DTexture2D는 직접 release해줘야 함. 만약 릴리즈 안해주면 스왑체인은 알아서 렌더타켓 릴리즈 해줬는데 정작 우리가 렌더타겟 쓰겠다고 주소값 가져온 애는 릴리즈 안되있으므로 프로세스가 터진다.

 - <wrl.h>
  - 윈도우 상에서 gpu를 제어할 수 있게할 라이브러리를 마이크로소프트가 제공하는 것.
    그 기능 중 하나로 스마트포인터로 편하게 레퍼런스들을 관리하게 해줘서 포인터 대신 쓰게 하는 기능을 쓸것이다.
    예시) *DXD11device 대신 ComPtr<DXD11device> 로 적을 수있다.
          내부에서는 소멸자가 호출될때 해당 템플릿에 명시된 대상의 포인터를 알아서 릴리즈함.
   - 스마트포인터는 GetAddressOf()는 포인터의 주소를 반환(즉 이중포인터를 반환)하는 함수를 갖고있다.
     이 기능은 이중포인터를 요구하는 함수들에 적용하며, 알아서 포인터의 주소값을 안전하게 알려준다.
     만약 이 함수 안쓰고 스마트포인터의 &로 접근하면 의도치 않은 위치에 접근할 수도 있다. (맴버포인터가 딱 첫번째 위치에 안있고 그 주소 뒤에 위치하면 엉뚱한 위치를 가리키게 되므로)
   - 스마트 포인터를 써서 이제 릴리즈 적는 코드를 안적어도 된다. 
     예시) 스마트 포인터로 렌더타켓까지 만들었을때 레퍼런스 카운트
           1. com<swapchain> 이 스왑체인 주소값가짐
           2. 스왑체인이 렌더타켓 주소가짐
           3. com<rendertarget> 이 렌더타켓주소가짐
             
             스왑체인은 1 레퍼런스 카운트가짐
             렌더타켓은 2 레퍼런스 카운트가짐
        
           이렇게 볼땐 총 3번 릴리즈 코드가 필요한데 스마트 포인터쓰면 프로세스가 종료될때 스마트포인터가 알아서 릴리즈 2번해주고, 스왑체인이 알아서 렌더타켓 릴리즈하니 나는 릴리즈코드 적을 필요가 없어짐
           만약 스마트포인터 안쓰면 스왑체인이 자동으로 릴리즈 해주는거 빼고, 나는 2번 릴리즈코드를 적어줘야 된다.
    - 참고 - c++이 제공하는 스마트포인터는 다름

  - 랜더타켓뷰, CreateTargetView
   - 1. 스왑체인에서 렌더타켓텍스처 얻어오기
     2. 디바이스에서 렌더타켓텍스처를 이용해서 렌더타켓뷰 객체 만들기
   - 뷰 이해하기
    - 보통 리소를 요구할때, 리소스전체를 달라하지 않고 그 리소스를 가리키는 뷰를 달라고 하는 경우가 많다. 
      왜 이런 구조를 만들었나? 텍스처는 생성하는 순간부터 용도가 정해져 있다. 즉 텍스처를 만들고 나서 나중에 용도를 정하는게 아니라 애초에 생성할때부터 텍스처의 용도가 미리 정해지고 텍스처가 생성되는 것이다.
      만약에 내가 깊이버퍼 텍스처를 달라고 했는데 랜더타켓 텍스처를 주면 어떻게 될까? 겉으로 볼땐 같은 텍스처래서 그대로 가져와서 작업하면 오류가 날것이다.
      그런데 뷰를 이용해서 접근한다는 것은, 그 뷰를 만들기 위해서는 반드시 그 텍스처의 용도에 걸맞게 뷰가 만들어 진다. 즉 렌더타켓뷰는 렌더타겟으로 밖에 만들어 지는 것이고, 깊이스텐실뷰는
      깊이스텐실로 밖에 만들어 질수 밖에 없다. 따라서 리소스 요구자는 텍스처를 직접 요구하는 것보다 뷰를 통해 접근하면 잘못된 텍스처로 접근할 가능성이 사라지는 것이다.
      그래서 이러한 뷰를 통한 리소스의 간접적인 접근 방식을 통해 시스템의 안정성을 높인 것이다. 
    - 스왑체인 만들때 버퍼는 렌더타켓용이라고 명시했으므로 그걸로 렌더타겟뷰를 만드는 것은 실패할 수가 없다. 

    - 렌더타겟텍스처와 깊이스텐실텍스처를 OM(Output Merge State)에 전달하는게 최종목표이다.

  - 깊이스텐실텍스처만들기
   - 깊이 3바이트 스텐실 1바이트 합쳐서 깊이스텐실이 된다. (fomat)
   - 깊이스텐실의 해상도는 렌더타겟텍스처의 해상도와 동일해야한다.
   - bindflags 는 텍스처의 용도를 의미. 당연히 깊이스텐실이라고 해야겠지
   - CPUAccessFlags는 우리(CPU)가 직접 GPU 깊이스텐실에 관여할 일이 있냐는건데 그럴리없음 따라서 0.

  - MipLevels - 해당 텍스처의 복사본을 얼마나 만들것인가. 1이면 복사본 안만든다는 거고 2부터 복사본 1개씩 늘어남. 

  - 구조체에 정보다 넣어줬으면 디바이스로 깊이스텐실텍스처 만든후 깊이스텐실 뷰도 만든다.

  - 