 - 만약 텍스처에서 검은색을 지우고 싶으면 어캐해야할까-> 블렌드스테이츠에 그 방법이 있습니다.
 
 - AlphaToCoverageEnable -> 물체들이 복잡하게 얽혀있을때 블랜딩 자체의 깊이값을 적용시키는 옵션.
                            예시로, 난초나 잡초나 나뭇잎같은게 수없이 겹쳐있다고 치자. 나뭇잎은 사각형에서 알파가 제로인 부분은 출력되고 1인데는 안그린다.
                            눈에보이지않는 투명부분의 깊이값이 더 낮으면 뒤에있는 나뭇잎이 안그려질때가 있다.
                            걔내들은 원래 그려져야하므로 이떄 Coverage를 켜주는 것이다.
 - IndependentBlendEnable -> 출력 렌더타켓은 총 8개 설정할수 있는데 타겟별로 하나의 물체를 개별적으로 블렌딩설정을 넣어줄수있다. 
                             이값이 false면 블렌딩설정 개별적용, enable이면 8개 타겟에 설정 일괄 적용이다. 우리는 어차피 렌더타켓 1개니까 false

 - DestBlend -> 원래 그려져있던 색깔. 우리는 SrcBlend의 역값을 하는 인자를 줌
   SrcBlend  -> 내가 그리고싶은 색깔. 
   BlendOp - 블렌딩 연산자. 우리는 블렌딩처리를 덧셈으로 하겠다? <- 정확히 알아볼것

 - BlendOpAlpha 및 밑에 두개는 별 의미 없어서 아무값이나 넣어줬다고함 이미 색깔이 정해져서 의미가 없다고함 (알파블렌딩 설정에서. 딴 블렌딩 설정은 아직 모름)

 - 원-제로 블렌딩 쓰는 쉐이더를 따로 만들게요.. 
   함수는 똑같은데 블렌딩스테이트만 달라요 나머지옵션은 똑같습니다.

 - 렌더타켓의 초기 클리어 색깔을 검은색으로 하면 좋은이유
   블렌딩할때 색깔이 흐려지는 제약이 사라짐. 검은색은 RGB값이 000 이기 때문에 색깔x 알파블렌딩(1) 결과가 무조건 0이다.
   따라서 배경(검은색)과 블렌딩될 다른 이미지의 원본 색깔이 흐려지는 일이 사라진다.

   만약이 렌더타켓이 회색같이 색깔이 있다면?
   그럼 원본 이미지의 색깔에 다른 색깔(회색등)이 섞여 블렌딩되서 색깔이 희미해지게된다. 

   그래도 회색색깔의 렌더타켓을 쓴다면 원본 이미지가 흐려질테니까, 쉐이더에서 원본색깔을 강화하게 수치를 조절해줘야한다.

 - 제일 좋은것은 검은색 배경으로 되어있는 이미지를 그냥 쓰지마세요. 그냥 처음부터 알파값 잘되어있는 이미지를 쓰세요.

 =======================================================================
 블렌딩 스테이츠는 여기까지 정리하도록 하겠습니다. 

  - 앞으로 할꺼
    1) 계층구조 (부모자식 오브젝트연결)
    2) 생성 삭제 (TaskMgr)
    3) Material
    4) DebugShape Render
    5. Collision
    6. Structure Buffer
    7. Light2D (광원)
    8. Sprite Animation
    9. Compute Shader
    10. Particle System
    11. ImGui Tool
===========================================================================

 - 이제부터 오브젝트들 간에 계층설정이 가능 하도록 만들겁니다.
   무슨말이냐면 지금까지는 모든 오브젝트가 독립적이고 부모가 없었다. 엄밀히 말하자면 m_vRelativePos는 절대좌표에 더할 상대좌표인데, 부모가 없는 애들은 이 상대좌표가 곧 절대좌표였다.
   (모든 물체는 월드라는 공간에 좌표값으로 위치하는데 이걸 절대좌표라고하고, 상대좌표는 어떤 다른 좌표를 기준으로 하는 좌표값.)
   (부모오브젝트가 없다면 월드내에서 절대좌표를 기준으로 움직인다. 그 절대 좌표는 월드다. 만약 본인이 자식오브젝트라면 부모오브젝트의 절대좌표를 기준으로 내 상대좌표를 더해서 월드상의 절대좌표를 정한다.)
   만약 자식오브젝트란게 존재한다면, 부모오브젝트의 절대좌표가 반드시 정해져야 그 Tick에서 부모좌표의절대좌표 + 내 상대좌표 해서 본인의 절대좌표를 정하게 된다.

 - AddChild() 함수
  - 만약 자식으로 삼을 오브젝트가 이미 부모가 있다면 원래 부모와 관계 끊고 새 부모랑 연결되게 설계할게요.

 - Component에서 GetOwner()->GetParent()의 의미
   컴포넌트는 꼭 오브젝트에 속하게 되어있는데, 그 오브젝트에도 부모가 있을수있음

 - 그럼 자식 오브젝트의 좌표는 어떻게 결정할까?
   먼저 본인의 변환을 적용하고, 부모의 변환을 적용하면 된다. 반대로 만약 부모의 변환을 먼저적용하면 엉뚱한 값이 나온다. 이는 예전에 설명했던 허수값으로 인해 계산할때 쓸데없는 수치까지 곱해서 엉뚱한 결과가
   나온다는 예시를 이미 봤었다.

   즉, 본인의변환행렬인 크기x회전x이동을 하고 x부모크기x부모회전x부모이동 을 하면된다.
       == 본인의 월드행렬 x 부모의 월드행렬

 - 자식의 방향행렬은 월드의 방향행렬과 달라질수있어서 주의해야한다. 즉 자식오브젝트의 로컬스페이스 방향과, 월드에서의 최종 방향행렬은 달라지는게 일반적이다
    따라서 이 두 방향행렬의 경우를 전부 따로 관리하게 된다.
 - 예시로, 자식은 가만히 있고 부모가 y축으로 180도 회전했다고 치자.
   자식의 로컬 방향은 여전히 변화가 없다. 당연하다 본인은 변환행렬에서 어떠한 변환도 없이 그냥 가만이 있었는데 그냥 부모가 회전해서 부모의 변환행렬만 바뀐거다.
   이제 월드에서 자식의 방향행렬은 x,z축이 90도 회전되어있다.
   다시말하지만, 부모가 회전해도 자식자체가 회전을 안하면 자식의 로컬 방향은 변화가없다. 변하는건 자식의 월드에서의 방향이다.
   본인은 가만히 있고 부모가 회전하면 월드에서의 방향행렬은 부모의 방향행렬에 맞춰진다. 그래도 여전히 로컬방향은 변하는게 없다.

   이게 헷깔린다면 이동을 한번 비유해서 생각해보라. 부모의 위치가 바뀌어도 자식의 상대좌표값이 바뀌는가? 그렇지 않다.
   고의적으로 상대좌표를 바꾸지 않았을때도 부모의 좌표만 바꿔도 자식은 그걸 따라다보니 자식의 최종적인 절대좌표는 바뀌어서 움직여 보이는데
   부모와 자식 사이의 거리는 상대좌표 안바꼈으니까 변하질 않는다.

 - transform에 옵션하나를 주겠다.
   어떤 옵션인가? m_bAbSolute.
    부모크기의 변환행렬에 의해 자식의 크기가 증폭되는게 일반적이다. 부모의 크기엔 영향받지 않고 회전 이동만 영향받고 싶을때
    부모크기행렬의 역행렬을 꼽사리껴넣으면 된다.
    즉 원래 크x자x이 x 부모크x부모회x부모이 인데 
            크x자x이 x 부모크기역행렬 x 부모크x부모회x부모이 로 하면된다.

    근데 어차피 어쨌든 부모크기역행렬x부모크기행렬의 결과가 단위행렬로 나오게 하는게 목적이니까 복잡하게 역행렬 공식을 굳이 적용하지말고.
    만약 부모크기가 100이면 단위행렬 만들도록 역수인 행렬을 대신 써줘도 된다.
    (1/100 0     0     0)
    (0     1/100 0     0)
    (0     0     1/100 0)
    (0     0     0     0)

    우리는 이 방식을 채택한다.
    크기 ignore 설정을 키면 절대수치로 크기를 정한다
  
   







    