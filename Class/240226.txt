 - 새로운 프로젝트 하나를 추가하겠다
 - CodeGen (Code Generate 약어인듯?)
  - 출력디렉터리 설정 확인해볼것.
  - 프로그램 실행시키면 필요한 기본 기능들을 자동으로 만들어주는 역할을 하는 프로젝트.


?> wcscat_copy() 함수

? enum과 enum class는 문자열이 겹쳐도 상관없나보다? 
 -> 상황설명 : 
   스크립트타입에서 END 라는 문자열 겹쳤을때 enum class에서 END 겹치는건 별 신경안쓰고
    enum 에서만 END를 찾으심 실제로 SCALAR_PARAM 에서 END 겹치는거 발견 enum class에서 겹치는 END는 상관없었음
    SCALAR_PARAM 을 enum 에서 enum class로 재정의하심. 그리고 네임스페이스 안적어준거 다 일일히 고치심

 - 스크립트 프로젝트에 스크립트매니저 추가
  - 스크립트는 enum 으로 타입 결정해서 m_iScriptType 에 적당한 값 넣어줘야함. 
    기본생성자 없애버리고 무조건 이 const 타입의 스크립트 타입을 생성시에 인자로 넣어줘야함
    새로운 스크립트 파일 추가하면 enum에도 꼭 type을 추가시켜줘야함
  - 스크립트 생성하려면 인자로 해당 타입을 직접 넣어주거나 뭔가 스크립트의 이름을 알려줘도 되는걸로보임? 문자열이름으로 알려주는건 코드확인필요
  - GetScriptInfo() 함수에 모든 스크립트 타입을 push_back()해야함.
  - 스크립트추가시 스크립트 인자로주면 해당 타입에 맞는 문자열이름을 리턴하는 함수도 있어서 case문 추가해야함

  - 아롷개 스크립트 하나 추가할때마다 유지보수 해야되는게 많은데 스크립트 매니저를 만들어줘서 하나의 파일에 몰아둔 것입니다.

 ** 엔진같은 툴용 스크립트는 따로 스크립트 타입이 없습니다 CCameraMoveScript같은 애들.
    스크립트 타입이 있는 애들은 스크립트 프로젝트에 속해있는 애들이에요 따라서 CCameraMoveScript같은 애들은 타입이 -1인가 생성자에서 그렇게 설정하셨음


 - 컴포넌트는 더이상 추가될게 없지만 스크립트는 이론상 무한히 추가해놀 수 있음.
   그럴떄마다 해줘야하는 노가다 작업을 스크립트 매니저가 대신시키도록함.

  - 어떻게 구현할까? 
   - MenuUI.cpp 에서 미리 구현해놓은 GetScriptInfo() 함수로 모든 스크리트 정보를 벡터에 담아와서
     반복문 걸어서 그 정보들을 쫘라락 보여주게 하면됨

   - 인스펙터가 현재 보여주는 오브젝트를 받아와서 거기에 바로 스크립트를 컴포넌트로 넣어주는 코드있음
     상황굼금>> GUI 상에서 인스펙터에 Player가 있었고, 거기에 메뉴에 어떤 스크립트를 클릭하면 오브젝트에 추가되는데 클릭이벤트 확인을 정확하게 어디서 하는지 MenuUI.cpp 상에서는 잘 안보였음 딴데에 있나? 


 - exceptlist.txt라는 파일에 ScriptMgr.h 추가. 이 파일의 역할은 스크립트 타입에 자동으로 추가하는 기능에서 예외로 적용할 파일목록을 기록해 논거임. 
   이 파일을 활용하는 코드는 CodeGen에 있는걸로 보였음. 선생님이 미리 짜놓은 코드인듯

 ** 와 개신기 CScript.h 하고 .cpp 파일 전부다 삭제한 상태에서 CondeGen.exe 파일 실행하니까 실시간으로 코드가 다 적혀져있게됨;
    -> 새로운 스크립트 파일 하나 만들때 해줘야할거
       1) 빌드전 이벤트에 cd $(SolutionDir)CodeGen\
                          call ㅊCodeGen.exe
          라는거 설정함.
       2) 생성자에 인자로 스크립트 타입주게 강제.


 - 스크립트 파일 삭제시 주의할점 
    CodeGen이 include 폴터의 script폴더 안에 있는 파일들을 보고 확인하기 때문에 스크립트 파일을 솔루션탐색기에서 지우면 끝이아니라 익스터널 폴더에서도 지워줘야함.

 %% 특수문자를 문자열 내부에서 기록하고 싶을땐 역슬래시를 쓰는 경우가 많다.
     쌍따옴표 같은 경우도 컴파일러가 문자열의 시작과 끝을 알리는 용도로 쓰이는데 그게아니라 진짜 쌍따옴표를 문자열의 일부로 사용하고 싶다면
     \"라고 적어줘야함

 - CodeGen은 일일히 노다가로 코드를 다 적어주라고 지시하는 파일일뿐이다. 자주하는 규칙적인 일을 자동화한것.
   빌드전에 CodeGen.exe가 실행되게함.

=================================================================================================================================

 ^ 레벨 자체를 세이브 하는 기능 만들기
  - 레벨 세이브로드 기능을 엔진에서 둘지 클라에서 둘지 고민했는데 클라에 두기로함
  - 필터하나를 더둠. 04 LevelSaveLoad에 CLevelSaveLoad.cpp생성.
  - 함수만 필요한거라 싱글톤으로 안만들고 대신 static 함수를 만들것임
  
 - SaveLevel()함수
  - _wfpen_s(파일스트림포인터, 파일저장할전체경로문자열, 모드) 유심히 살펴공부해볼것
    fclose(파일스트림포인터?)
  - 레벨에 저장해야할것들은 뭐가있을까
   - 레벨 이름 저장
   - 레벨의 레이어
    - 레이어 32개 반복문돌리기
      레이어 하나를 저장하는 기능을 함수로 처리.
 
 - SaveLayer()
  - 레이어 이름저장
  - 레이어가 보유하고 있는 최상단 오브젝트 저장
   - size_t ObjCount 
     -> 레이어가 가지고 있던 오브젝트의 개수를 모르니 이 변수로 오브젝트개수 정보를 저장시켜놔야 Load 할때 알맞은 개수로 오브젝트들을 불러올수있다.
  
 - SaveGameObject()함수 

 - LoadLevel()함수

 - LoadLayer()함수
  - 미리 Save된 레벨이 레이어 최대 32개 갖고있을테니 반복문 돌면서 GetLayer()하나씩 하면됨
  - 

 - LoadGameObject()함수
  - 인자로 파일포인터하나만 주면 그거 읽어서 게임오브젝트 포인터를반환.
    이떄 AddObject()할떄 두번쨰 인자는 false 넣어줘야함 자식들은 레이어 알아서 찾아가라고 해야함.

%% func.h에 파일의 wstirng 저장하고 로드하는 함수 추가.
   SavwWString(), LoadWString() 내부구조 살펴보기
   if(bAssetExist) 에서 세이브 로드하는 부분(실사용예시)도 봐두기