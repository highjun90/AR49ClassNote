

 - DragTime 맴버는 몇초에 걸쳐서 이 파티클의 속도가 서서기 감속해서 0이 될지에 대한 정보. 
   값이 3이면 3초에 걸쳐서 속도가 0이되는것

 - 쉐이더파일에서 Drag 모듈과 Noise 모듈 순서가 중요함 노이즈도 짜잘하게 속도가 바뀌는 모듈이래서
   -> 내생각으론 Drag모듈은 노이즈모듈보다 먼저 수행되어야 한다고봄. 선생님은 어떻게 했는지 코드 확인필요
      왜냐면 Drag모듈은 파티클의 전체적인 큰 줄기의 속도가 줄어들길 바라는거지 노이즈의 움직임이 감속하길 원하는게 아니므로.

 - 속도에 따른 정렬기능이 켜져있으면 속도가 0이 될때 파티클이 사라져버림. 속도에 따른 정렬에서 방향행렬이 0되기 때문.
   나중에 지오메트릭 쉐이더에서 다른 출력스트림으로 버퍼에 정보를 저장했다가 속도0될때 이전 상태를 유지하라는 
   코드를 짤 수도 있지만 일단은 보류한다함 드래그모듈 쓸때 속도 0되면 파티클 사라지는거 감안할것

 -------------------- 파티클종료, imgui넘어가기
 
 - 타일맵, 파티클시스템 UI 만들어야함 

 - 인스펙터에서는 선택된게 컴포넌트인지 에셋인지에 따라 보여주는게 달라져야함 분기처리.

 - 모든에셋을 보여주는 컨텐츠 UI 구현하기 그러려면 imgui의 트리UI필요

 - 예시로 보여주는 imgui는 노가다로 트리ui를 모두 짰다 클래스 안쓰고. 근데 우리는 상황에따라 보여줄게 정해진게 아니라 보여줄때도 있고 안보여줄때도 있으므로
   우리는 클래스 구조를 써서 트리 UI를 구현해야함. 

 - TreeUI 클래스
  - 단독으로는 아마 안쓸거고 누군가의 자식으로써 사용된다고함
  
 - 아웃라이너 클래스와 컨텐츠 클래스는 트리UI를 멤버로가짐
   얘네 둘은 렌더업데이트 함수에서 본인이 직접하는건 없고 자식인 트리ui에게 할거를 맡긴상태

 * imgui_demo.cpp 에서 예시 코드 확인

 - 기존엔 열고닫는건 부모UI한테 맡기고 본인이 오버라이딩한 렌더업데이트함수만 신경쓰면 됬다
   지금도 동일한 구조가 적용되는지 시험한다. 다만자식 UI가 UI열고 닫았던 beginchild() endchild()가 아니라 TreeNode() TreePop()을쓴다.

 - TreeNode 클래스
  - TreeNode 클래스는 말그대로 TreeUI 안에 존재할 수있는 많은 트리노드 중 하나 그 자체이다. 
  - 트리노드는 또 트리노드를 자식으로 가질수있다. m_vecChildNode 벡터가 그런자식들을 가리키는 벡터.

 - TreeUi는 root 에만 렌더업데이트 함수를 실행하면되고, 각 TreeNode들은  TreeNode()와 TreePop()으로 열고닫는다.


 - 트리는 루트만 delet 해주면 자식들은 알아서 delete (Delet_Vec(m_vecChildNode))
 
 - TreeNode()함수는 트리노드가 열려있으면 true 아니면 false 반환

 - 어떤 노트하나가 데이터를 품을수 있게 DWORD_PTR m_Data 맴버추가. 이걸로 트리노드가 인스펙터에게 본인이 선택됬으면 뭐가 선택됬는지 전달해서
   인스펙터가 그걸로 정보를 보여줌



===========================================================================

 - TreeUI가 트리UI구조의 본체이고TreeNode는 그 트리 UI에 속한 노드들이다.
 
 - AddTreeNOde() 트리UI에 트리노드 하나를 집어넣는 함수. 
  - 인자로 부모트리, 이름설정, 노드가 가질 정보(m_Data)

 - 정적맴버로 NodeID를 둬서 트리노드들에게 id를 준다. 얘로 이제 각 트리노드들의 id가 겹치지 않게 초기화 해주는 것이다.
   UINT id = NodeID++;

 - 실전에서 어떻게 사용되는가? 
  - Content UI에서 트리를 추가한다고 해보자.
    1. m_Tree 에 TreeUI new 하고
      AddChildUI(m_Tree) 로 트리UI를 맴버로둔다.
    2. 요 m_Tree에 노드를 추가하면 된다. 
    더 자세한건 content UI 확인할것

 - 특정타입별 에셋의 목록그룹을 반환하는 함수를 에셋매니저가 지원하게 관련함수를 만들겠다
   GetAssets() 함수. 
   - map을 반환하는 건데 선언이 좀 헷갈릴수있어서 한번 보는걸추천. 맵을 반환하는 그것도 템플릿까지 써서 반환하는 구조여서.
     또한 오버로드함수로 템플릿쓴 버전말고 인자로 그냥 에셋타입을 주면 되는 버전도 만듬 이건 이제 반복문 써서 enum으로 에셋타입에 접근해서 활용할떄 좋음

 - ResetContent() 
  - m_Tree에 있던 모든 노드를 clear시키고 , 에셋매니저에서 텍스처타입 등 에셋 타입별로 노드들을 싹 추가시킴

 - c++는 이넘값을 문자열로 바꿔주는 기능은 문법적으로 지워을 안해줘서 어거지로 본인이 그런 구조를 만들어야함.
  - ASSET_TYPE_STRING 이라는 문자열 배열을 enum 클래스 선언한 파일에 선언해놓음 
   이 배열인덱스에 속한 문자열과 이넘클래스의 인덱스에 매핑된 문자열이 같게됨

 - 
 

