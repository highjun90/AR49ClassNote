 지난시간) 후처리 쉐이더 쓰는 애 때문에 가장 마지막에 그려지고 미리 그려져있는 색상을 회색으로 덮고있음
 - 렌더매니저에 함수 만들자. 
 - CopyRenderTargetToPostProcessTarget() 함수 -> 렌더타겟을 포스트프로세스타겟에 복사하라
 - 지난시간에 뎁스텍스처는 우리가 짠 코드로 바꿨는데 렌더타겟은 아직 그런 구조를 적용안했습니다.
   렌더타겟도 다이렉트에서 얻어오지말고, 에셋매니저로 얻어올수있게 구조 바꿀게요. 그러기 위해선 에셋매니저에 함수 만들어야합니다.

 - 지난시간에 에셋매니저에 CreateTexture()함수 만들긴 했지만 만약 텍스처가 이미 있는 텍스처인 경우는 처리 안했거든요 그거 처리하는 함수 오버로드함수 하나 만들게요
 - 그리고 지난 시간에 에셋매니저가 텍스처 만들고 정작 만든거 정보를 들고있지 않았어요 그거도 고친다
  - 인자에 key가 되는 문자열(텍스처 이름)추가.
  - 참고) pTex 지역변수는 스마트포인터여서 함수 나가면 사라지니까 자동으로 메모리해제됨
  - FindAsset()함수로 해당 키값에 대응하는 반환값이 null이면 오류

  -이제 텍스처 객체로 넘어갑니다.
   - 인자로 텍스쳐2D달랑 하나만 들어왔을경우의 Creat()함수 만듭니다. 
     본인 텍스처에 인자텍스처 덮어씌우고 뷰까지  생성하면끝.

 ** 렌더타켓같은 텍스처는 예전엔 텍스처와 뷰 둘다 장치device 에서들고 있었는데 이제 텍스처가 뷰들고 있어서 텍스처만 들고잇는 구조로 바뀜. 이 텍스처를 에셋매니저가 들고있음

  - 렌더타겟을 후처리타겟에 복사하는 함수에서 
    컨텍스트의 CopyREsource()함수를 쓸때 두 텍스처의 해상도가 일치해야 실패가 안뜹니다. 말되죠 해상도 다르면 메모리 공간 어디에 어디까질 덮어씌워야할지 모르니까

 - 포스트 프로세스는 렌더 함수 이름을 따로 만들어 둘게요 똑같은 render()로 실행시키는게 말이 안된다고함
   형태는 render()함수화 비슷한데 하기 전에 해줘야할 작업이 있다함
 - render_postProcess()함수
   최종화면의 카피본 텍스처를 에셋매니저에서 가져와도 되지만 렌더매니저에서 바로 가져올게요 그럼 탐색하는거보나 인라인 될테니(코드가 한줄) 이득입니다.
   
   이제 포스트프로세싱할 물체의 재질의 레지스터로 전달하....려고 했는데 후처리 전용레지스터 만들기로 결정(딴 중요한 정보가 더 있었을수도있어서)
   t13에다가 g_postprocess 란 이름으로새로 만듦 여기에 최종화면복사본이 있음

   보면알겠지만 반복문 돌려면 후처리하는 오브젝트가 있어야함 없으면 이함수 호출해도 하는게 없음

 - 추출한 색의 RGB를 더하고 3으로 나눈값을, 그거를 RGB색으로 각각 지정하면 회색이됨 

 - 에셋 매니저의 초기화부분 분할

 - Distortion Shader 만들기 (왜곡)
  - 얘는 메쉬가 굳이 rect mesh일 필요가없음 왜냐면 화면의 일부분에만 존재할거래서. 나머진 회색후처리 쉐이더랑 똑같음. (아 cull none 도 다름<- 확인필)
  - 레벨매니저에서 distortion 오브젝트 만들때 회색후처리랑 코드 비슷하지만 재질이 distortionMaterial 로 바뀜. 얘는 진짜 월드어딘가에 존재해야되서 위치값이 필요
    픽쉘쉐이더는 그대로 간다.


 ** 매우 어려운거 설명해서 쉬는시간에 계속생각.
    지금까지 내가 이해한것은 distortion 기능을 구현하기 위해서 렌더타겟을 하나 더 만들었다.
    그리고 기존렌더타겟 앞에 새로만든 렌더타켓을 둔다. (새로만든 렌더타겟은 기존렌더타켓보다 더 작게 만들어놈)
    새로만든 렌더타켓에 기존렌더타겟의 왜곡효과를 적용시키고 싶은 부분의 UV 값을 적용시킨다.
    그럼 어쨌든 최종결과는 마치 하나의 렌더타켓처럼 보인다. 실은 두 렌더타겟이 겹쳐있는거지만.

    이걸 명확하게 선생님이 확인시켜준 모습이 카메라의 위치를 바꿔보는 것이다. 
    신기하게 기존렌더타겟 앞에있는 새로만든 렌더타겟(크기가 더 작은화면)에 동일한 화면이 출력되는 것이다.
    이것은 새로만든 렌더타겟에 그릴 기존렌더타켓의 UV값을, 기존렌더타겟의 UV값과 동일하게 설정했다는 말.
    다른말로 
    " 기존렌더타겟이 텍스처에 적용한 UV설정 == 새로만든렌더타켓이 기존렌더타켓에 적용한 UV설정 "

    내가 지금 헷갈리는게 렌더타겟을 하나 더 만들어서 앞에둔건지 그냥 텍스처만 앞에 둔건지는 헷갈림
    아니면 그냥 픽셀만, 말그대로 픽쉘쉐이더의 처리수식만 건든걸로 보임

===========================================================================================

 - 내가 텍스처의 어떤 부분의 UV 값을 알고싶다면, 그 텍스처의 가로세로 몇번째 픽셀인지 알면 UV 값도 알 수 있다.
   즉 전체해상도와 해당 부위의 픽셀위치를 통해서 해당 부위의 UV값을 유도해낼수 있다.

 - 픽쉘쉐이더에서 입력으로 들어온 좌표가 투영좌표계를 통해 바뀌어서 들어올거라 생각하지만 sv_Posision으로 입력된 값은 픽쉘쉐이더 호출한가 해당픽셀의 좌표가 들어있다. 
   레스터라이저가 얘만 예외처리 한 것이다. 
   (내가 이해하기론 월드의 좌표가 아니라 출력되는 화면의 픽셀위치가 대신 들어있는걸로 이해)

 - 이렇게 설정한 distortion 처리의 결과는 픽셀색깔을 특이하게 설정하는등 뭔가 처리를해야 티가 난다. 아니면 절대 티가 안남 원본 색깔 고대로 출력하면 실제론 겹쳐있지만 볼때는 티가 안남.

 - 자 이제 왜곡효과를 적용하려면, 앞서 알아낸 UV값을 이용합니다. UV의 x값을 강제로 키우면 코사인 그래프의 결과값(UV y값)이 더 들쭉날쭉 될겁니다. (진동수 증가)
 - 마지막 결과값에 0.1 곱하면 그게 (진폭줄이기)
 - 수식을 잘보세요 vScreenUV.y += cos( (vScreenUV.x + (g_time * 0.1f)) *20.f) * 0.1f
                                                                속도   진동수   진폭
       속도는 일렁거리는 속도, 진동수 값은 클수록 더 x축 양옆으로 찌그러져보임, 진폭은 낮을수록 더 안정적으로 보임
       
 - 이제 외부 텍스처를 불러옴 (HLSL에는 g_btex_0에 바인딩되어있고,  c++에는 "Noise_03"였던가)
  - 거기에 기존 UV값의 3퍼센트만큼 더해주면 미세하게 울렁거리는 효과가 됨 (v.Noise.xy - 0.5f) * 0.03f <= 원래 UV값에 3퍼정도 증감시켜주는 수식
  - 거기에 또 시간에 따라 x값을 더해주면  흘러가는 효과도 추가.
    (참고 - UV값의 범위 벗어난 값은 수치가 다시 돌아간다는것 기억할것. 1+0.1 = 0.1, 0 - 0.1은 0.9)


 - 노이즈는 색상이 아니라 무작위성이 중요함. 
 
 ** 쉐이더토이란 사이트에 언어가 오픈지엘로 되어있어서 개념만 따와보세요

  - 한가지더, 강물같이 비추는 모습은 일정영역의 UV값을 뒤집어서 넣어주고 거기에 왜곡효과 + 푸른색 넣어주면 강물효과가됨



  
