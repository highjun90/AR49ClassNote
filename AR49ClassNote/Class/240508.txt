 - 지난시간에 포인트라이트 쉐이더 코드를 작업했었죠, 어제 색깔처리는 디버그하려고 여러 색깔을 넣어줬는데 이젠 discard합시다.
   
   자근데 문제가 있어요 포인트 라이트 내부로 진입하면 빛이 사라져요 '컬백'때문이에요.
   우리가 포인트라이트 작성할떄 에셋매니저 가보면 컬백으로 설정했어요. 
   컬 프론트로 하면되죠. 어 컬넌(NONE)으로 하면 안되요? 그럼 빛이 두배로 들어와요.
   컬넌은 볼륨메쉬 밖에 있을땐 엄청 밝다가 원안으로 들어가면 살짝 어두워 지는걸 확인할 수 있습니다.

   모슨상황을 고려했을때 우리는 결국 컬 프론트로 포인트라이트를 설정해야합니다.

   여기까지 포인트라이트 설정은 끝났습니다.

 - 이 방법말고 스텐실버퍼 쓰는 방식이 있다고 했죠? 2017년에는 그 방식으로 했는데..
   근데 어차피 우리가 쓰는 광원의 형태가 우리가 일반적으로 쓰는 간단한 광원이란말이죠. 그래서 프레임차이가 의미있게 나요.

   복잡한 도형 내부로 들어오는, 볼륨메쉬를 체크하면 우리현재 수업에서 했던건 못써요, 그래도 포폴에 활용할 인원을 위해 구현은 안하고 이론 설명만 할게요.

 - D24S8 - 깊이스텐실텍스처는 24비트에 깊이를 저장하고, 스텐실로 1바이트 써요. 예전에 한번 설명했죠.
   이 스텐실, 어떻게 활용할까요? 
   우선 enum class DS_TYPE에 VolumMesh용 타입을 추가합니다.
   BACKFACE_CHECK, FRONT_CHECK 이라는 스텐실 타입 2개.
   
   후면처리용 뎁스스텐실 텍스처를 만들어 봅시다.
   D3D11_COMPARISION_GREATER -> 깊이가 더 깊은애가 남는겁니다 원래 우리가 해올떄랑 정반대죠? 왜냐면 얘는 뭔가 그리려는 애가 아니라 영역체크를 하려는 용도로 쓰이기 때문이에요.
   얘는 볼륨메쉬같은 애들 앞에 뭔가 있을때만 볼륨메쉬가 그려집니다. 즉, 디버그용 도형 앞에 뭔가 있는지 확인하려고 쓰이는 옵션이죠.

   얘는 렌더타겟이 없기때문에 픽셀쉐이더가 없어요. 버텍스 쉐이더만 있습니다. 진짜로 깊이 판정만 하는겁니다.
   StencilEnable = true 로 설정합니다. 맨날 false였죠 드디어 한번 쓰이는 경우를 보는겁니다.
   
   tDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS -> 패스조건은 항상. (패스될수있는 상황이면 무조건 패스)
   tDesc.BackFace.StencilPassOP =  어쩌구     -> 스탠실이 패스됬을때 스텐실 값을 1증가시킨다.
                 
   이게 뭔 말이면 물체가 앞에 뭔가 그려졌을때, 최초 초기화할땐 스텐실이 0으로 기록되어 있는 상태인데, 그걸 1값을 증가시키겠단 말이다.
   다시말해 이 물체는 앞면에 있는거라고 체크한다는 의미다

   이 상태에서 프론트 뎁스스텐실 까지 보자

   얘는 COMPARISION_LESS다.

   tDesc.FrontFace.StencilFunc = 얘도 ALWAYS
                   PassOP = 얘도 INCR (increase 증가)
               
   우선 볼륨메쉬의 뒷면을 머저 그렸고, 어떤 물체에 스텐실 1로 증가한 상태에서, 볼륨메쉬의 앞면을 그렸을떄,
   또 물체의 스텐실이 1 증가해서 2가됬다. 후면은 물체가 앞에있는지 검사, 앞면은 뒤에있는지 검사하고, 상황이 맞으면 스텐실이 1 증가한다. 상황이 맞지 않으면 1감소한다.

   자 마지막으로 스텐실체그용 뎁스스텐실 텍스처를 만든다.
   얘는 깊이정보 조차 저장하지 않고, 오직 스텐실 정보만 저장한다. 앞서 후면 앞면 깊이텍스처는 그래도 두개다 저장해뒀음
   다음 볼륨메쉬에서 쓸수도 있으니까 PassOp FailOP 다 ZERO로 설정.

   만약 스텐실을 2로 설정했으면, 내가 예상하는 스텐실 값과 일치하고, 무조건 그리게 한다.
   그럼 내가 설정하고싶은 스텐실 값은 어디서 설정하나? 
   OMSetDepthStencilState()함수의 마지막 인자가 바로 스텐실의 판정조건에 해당하는 값을 넣어주는 것이다.
   우리는 그동안에 스텐실 안써서 항상 0을 넣어준거다. 만약 스텐실 사용할라면 쉐이더 쪽 UpdateData()함수에서 추가적인 인자를 받아야한다.

   왜 느린지 알겠죠? 렌더링을 3번해야해요. 

   자 정리. 뎁스텍스처에 렌더타겟조차 함꼐 두지도 않아요.

   스텐실버퍼써서 하면 판정조건이 똑같기 때문에 얘를 쓰면 디렉셔널, 포인트라이트, 스포트라이트 광원을 따로둘 필요가 없습니다. 광원타입에 따라 판정조건이 달랐던 기존 방식에 비해.
   코드가 하나로 통일될수있겠죠. 
   스텐실을 활용한 볼륨메쉬체크 방식이었습니다.

   여기서 최적화 좀더 할수있긴해요. 지금 3번체크하는데, 2번까지 줄일수있어요.
   뺵체크랑 프론트체크 뎁스스텐실을 합치는 방법이 있어요 이건조금 아이디어가 필요한데
   구조체 두개를 따로 만들지말고 동시에 작성하고 컬넌으로 하는거에요 볼륨메쉬안에 들어오는 물체의 스텐실을 한번에 기록하는거죠.

   그래도 어쨌든 2번 렌더링하죠? 렌더링은 횟수 무조건 줄이는게 퍼포먼스가 좋습니다.

   지난시간에 말한거 다시 강조하자면
   장점 - 메쉬형태에 개의치 않다. 어떤 복잡한 형태라도 빛영향 체크를 할수있음
   단점 - 연산이 많다

   제가 수업에 짠 코드가 그대로 되진 않을겁니다 좀 가공해서 쓰셔야 제대로 될거에요.


 - 새로운렌더컴포넌트 데칼컴포넌트라는걸 만들어봅시다.
   새로운필터 05.Decal






   






203
============================================================


204