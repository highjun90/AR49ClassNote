 - 지난시간에 포인트라이트 쉐이더 코드를 작업했었죠, 어제 색깔처리는 디버그하려고 여러 색깔을 넣어줬는데 이젠 discard합시다.
   
   자근데 문제가 있어요 포인트 라이트 내부로 진입하면 빛이 사라져요 '컬백'때문이에요.
   우리가 포인트라이트 작성할떄 에셋매니저 가보면 컬백으로 설정했어요. 
   컬 프론트로 하면되죠. 어 컬넌(NONE)으로 하면 안되요? -> 그럼 빛이 두배로 들어와요.
   컬넌은 볼륨메쉬 밖에 있을땐 엄청 밝다가 원안으로 들어가면 살짝 어두워 지는걸 확인할 수 있습니다. 밖에있을떈 프론트 백 둘다 그리고, 안에있을땐 백 하나만 그리기 때문이죠.

   모슨상황을 고려했을때 우리는 결국 컬 프론트로 포인트라이트를 설정해야합니다.

   여기까지 포인트라이트 설정은 끝났습니다.

 - 이 방법말고 스텐실버퍼 쓰는 방식이 있다고 했죠? 2017년에는 그 방식으로 했는데..
   근데 어차피 우리가 쓰는 광원의 형태가 우리가 일반적으로 쓰는 간단한 광원이란말이죠. 그래서 프레임차이가 의미있게 나요.

   복잡한 도형 내부로 들어오는, 볼륨메쉬를 체크하면 우리현재 수업에서 했던건 못써요, 그래도 포폴에 활용할 인원을 위해 구현은 안하고 이론 설명만 할게요.

 - D24S8 - 깊이스텐실텍스처는 24비트에 깊이를 저장하고, 스텐실로 1바이트 써요. 예전에 한번 설명했죠.
   이 스텐실, 어떻게 활용할까요? 
   우선 enum class DS_TYPE에 VolumMesh용 타입을 추가합니다.
   BACKFACE_CHECK, FRONT_CHECK 이라는 스텐실 타입.

   자 예전에 스텐실이라는게 미술에서 그려질 영역을 남겨놓는 프레임 같은거라고했어요. 그 뚫어진 공간에만 종이에 색이 칠해지고, 나머지는 프레임에 막혀서 안그려지죠.
   스텐실 버퍼는 바로 색이 칠해질 뻥 뚤린영역을 알려주는 버퍼입니다. 이걸 생각하고 설명을 들어보세요.
   
   후면처리용 뎁스스텐실 텍스처를 만들어 봅시다.
   D3D11_COMPARISION_GREATER -> 깊이가 더 깊은애가 남는겁니다 원래 우리가 해올떄랑 정반대죠? 왜냐면 얘는 뭔가 그리려는 애가 아니라 영역체크를 하려는 용도로 쓰이기 때문이에요.
   얘는 볼륨메쉬같은 애들 앞에 뭔가 있을때만 볼륨메쉬가 그려집니다. 즉, 디버그용 도형 앞에 뭔가 있는지 확인하려고 쓰이는 옵션이죠.

   얘는 렌더타겟이 없기때문에 픽셀쉐이더가 없어요. 버텍스 쉐이더만 있습니다. 진짜로 깊이 판정만 하는겁니다.
   StencilEnable = true 로 설정합니다. 맨날 false였죠 드디어 한번 쓰이는 경우를 보는겁니다.
   
   tDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS -> 패스조건은 항상. (패스될수있는 상황이면 무조건 패스)
   tDesc.BackFace.StencilPassOP =  어쩌구     -> 스탠실이 패스됬을때 스텐실 값을 1증가시킨다.
                 
   이게 뭔 말이면 물체가 앞에 뭔가 그려졌을때, 최초 초기화할땐 스텐실이 0으로 기록되어 있는 상태인데, 그걸 1값을 증가시키겠단 말이다.
   다시말해 이 물체는 앞면에 있는거라고 체크한다는 의미다

   이 상태에서 프론트 뎁스스텐실 까지 보자

   얘는 COMPARISION_LESS다.

   tDesc.FrontFace.StencilFunc = 얘도 ALWAYS
                   PassOP = 얘도 INCR (increase 증가)
               
   우선 볼륨메쉬의 뒷면을 머저 그렸고, 어떤 물체에 스텐실 1로 증가한 상태에서, 볼륨메쉬의 앞면을 그렸을떄,
   또 물체의 스텐실이 1 증가해서 2가됬다. 후면은 물체가 앞에있는지 검사, 앞면은 뒤에있는지 검사하고, 상황이 맞으면 스텐실이 1 증가한다. 상황이 맞지 않으면 1감소한다.

   자 마지막으로 스텐실체그용 뎁스스텐실 텍스처를 만든다.
   얘는 깊이정보 조차 저장하지 않고, 오직 스텐실 정보만 저장한다. 앞서 후면 앞면 깊이텍스처는 그래도 두개다 저장해뒀음
   다음 볼륨메쉬에서 쓸수도 있으니까 PassOp FailOP 다 ZERO로 설정.

   만약 스텐실을 2로 설정했으면, 내가 예상하는 스텐실 값과 일치하고, 무조건 그리게 한다.
   그럼 내가 설정하고싶은 스텐실 값은 어디서 설정하나? 
   OMSetDepthStencilState()함수의 마지막 인자가 바로 스텐실의 판정조건에 해당하는 값을 넣어주는 것이다.
   우리는 그동안에 스텐실 안써서 항상 0을 넣어준거다. 만약 스텐실 사용할라면 쉐이더 쪽 UpdateData()함수에서 추가적인 인자를 받아야한다.

   왜 느린지 알겠죠? 렌더링을 3번해야해요. 

   자 정리. 뎁스텍스처에 렌더타겟조차 함꼐 두지도 않아요.

   스텐실버퍼써서 하면 판정조건이 똑같기 때문에 얘를 쓰면 디렉셔널, 포인트라이트, 스포트라이트 광원을 따로둘 필요가 없습니다. 광원타입에 따라 판정조건이 달랐던 기존 방식에 비해.
   코드가 하나로 통일될수있겠죠. 
   스텐실을 활용한 볼륨메쉬체크 방식이었습니다.

   여기서 최적화 좀더 할수있긴해요. 지금 3번체크하는데, 2번까지 줄일수있어요.
   뺵체크랑 프론트체크 뎁스스텐실을 합치는 방법이 있어요 이건조금 아이디어가 필요한데
   구조체 두개를 따로 만들지말고 동시에 작성하고 컬넌으로 하는거에요 볼륨메쉬안에 들어오는 물체의 스텐실을 한번에 기록하는거죠.

   그래도 어쨌든 2번 렌더링하죠? 렌더링은 횟수 무조건 줄이는게 퍼포먼스가 좋습니다.

   지난시간에 말한거 다시 강조하자면
   장점 - 메쉬형태에 개의치 않다. 어떤 복잡한 형태라도 빛영향 체크를 할수있음
   단점 - 연산이 많다

   제가 수업에 짠 코드가 그대로 되진 않을겁니다 좀 가공해서 쓰셔야 제대로 될거에요.


 - 새로운렌더컴포넌트 데칼컴포넌트라는걸 만들어봅시다.
   새로운필터 05.Decal


   


 - 정리 : 빛처리 렌더링 두가지 방법중 로컬스페이스에서의 볼륨메쉬 영역체크 방법은 실제 코드로 구현했고, 깊이스텐실을 이용한 빛 렌더링은 이론만 설명했다. 이번교시는 내내 이론만 설명함 그리고 구현도 안할거임
          이유 - 광원은 영역형태가 간단한 경우가 대부분이고, 간단한 빛영역 검사 외에 만약 복잡한 형태의 영역체크가 필요하면 학생이 알아서 깊이스텐실 이용한 영역검사를 해야한다. 그런 학생들을위해 이론만설명.
          

          깊이스텐실을 통한 빛처리 렌더링은 총 3개의 텍스처가 필요하다. 2개는 깊이와스텐실정보를 통해 물체의 스텐실값을 증가하거나 감소시키고,
          마지막 깊이스텐실 텍스처는 오직 스텐실정보만 저장하는데 앞서 계산한 물체의 최종 스텐실 정보만을 저장한다.

          백텍스처 프론트텍스처는 각각 본인보다 앞에있면 스텐실 1증가 뒤에있으면 스텐실 1증가시켜서 물체의 스텐실정보를 저장한다. 만약 본인의 조건에 맞지 않는 픽셀은 1감소시킨다.
          그렇게 해서 최종적으로 스텐실이 2인 영역을 도출해낸다.

          렌더링할떄 바로 그 스텐실값이 2인 영역에만 물체를 그린다. 나머지는 다 discard해버리는것 .

    
203
============================================================
 
 - CDecal
  - RenderComponent 상속.
  - 저희가 볼륨메쉬 배웠잖아고 그 영역에다가 뭔가를 그려주는걸 할겁니다.
    무슨 혈흔, 발자국 이런 짜잘하거나 반복적인 패턴들을 일정영역내에 그리는 역할을 합니다.
  
  - 컴포넌트 추가했으니 오브젝트와 컴포넌트 코드에 Get 매크로 추가해주고요
    component.h에도 CDecal.h 인클루드 해주고요

    복사자체는 얕은복사해줘도 될거같아요 얘가 자체적으로 가진 맴버가 없으니까. CLONE()추가하고요.
    생성자에서 기본적으로 메쉬를 "CubeMesh"로, 재질을 DecalMtrl 로 설정합니다 재질은 나중에 만들고요.
    UpdateData() 함수에는 Transform()과 GetMaterial() UpdateData()
    render()에는 UpdateData()와 GetMesh()->render() 까지 하면

    컴포넌트 추가했을때 기본적으로 해줘야하는 틀이 다 완성됬습니다 

  - 재질이나 메쉬 완성안됬기 때문에 if문으로 없으면 바로 return하는 부분 임시로 만들어 놀게요.

  - finaltick()에서는 디버그 큐브를 초록색으로 등록하는 코드 추가했어요.데칼의 위치에 임시로 큐브 띄워놓는겁니다.

  - 자 light는 디렉셔널로 돌아갑니다.

  - 화면 출력해보면 초록색 큐브가 있고 그게 데칼영역이죠.

 - decal.fx, 3DShader 필터
  - UV는 필요없고요 포지션만 있으면 될거같아요.
  - 버텍스쉐이더에선 WVP 곱해서 정점 처리 하구요

  - 자 여기서부터 그리기 시점을 고려해야합니다 디퍼드 시점에 그려지겠다는 말은 광원처리를 하겠단 말이고, 포워드시점에서 그려지겠다는건 빛처리 이후 추가적인 작업같은걸 하는건데
    우리는 통일성을 위해 빛처리 렌더링은 무조건 디퍼드 단계에서 하기로 했어요. SHADER_DOMAIN에서 미리 데칼 타입 추가를 헀죠.

  - 자 MRT는 뭘로해야할까. decal은 이미 그려진 물체에 덧그리기 하는거니까 데칼용 MRT가 따로 있어야해요. 새로운 MRT 가 필요해요 Decal전용 MRT.
    레스터라이저 타입은 컬프론트입니다. 컬백, 컬논하면 안되는 이유 1교시에 설명한 것과 똑같습니다.
    뎊스스텐실은 필요 없어요 MRT도 아예 깊이텍스처 안만들거임.
    블렌드는 알파블랜드입니다 기존에 그려진 영역과 혼합해야할 상황이 있을수도 있어요.

    g_mat_0 뷰역행렬과 월드역행렬 곱한행렬. 이게 있어야 픽셀을 볼륨메쉬의 로컬영역으로 이동시키죠.
    g_tex_0 output texture
    g_tex_1 포지션타겟. 이게 있어야 볼륨메쉬랑 영역검사해서 그릴지 아닐지 체크하죠.

    주석에 적어놓은 이런설정들이 기본적으로 다 세팅되어있다는 가정하에 쉐이더 코드를 짜는 겁니다.

  - CRenderMgr_init.cpp, CreateMRT()에 Decal MRT를 추가합니다.
    얘는 새로운 텍스처를 만드는게 아니라 기존에 있던 텍스처를 융합할겁니다.
    텍스처는 2장으로 하고요, "ColorTargetTex" 하고
    데칼 스스로 광원처럼 빛나는 경우를 위해 EmissiveTargetTex 

    요렇게 find해서 설정해줍니다.

    SetClearColor()는 안해요. 어차피 남들이 소유한거고 걔내가 clear하겠쬬.

    MRT의 enum 에 DECAL 추가해주고 
    만들어주면 끝

  - decal.fx, PS_Decal()
   - 전에 포인트라이트에서 했던거처럼 픽셀의 xy값으로 UV 도출해서 포지션텍스처에서 값 가져옵니다.
     그후 w값이 -1이면 discard해줘야 하는데 확인을 위해서 디버그색으로 빨간색 설정합니다.

     그후에 설령 포지션텍스처 값이 있었더라도 실제로 큐브내에 겹친놈인지, 아니면 그냥 투영되서 보이는 놈인지 구분해야되죠.
     xyz값에 0.5를 더해줘서, 그값이 0보다 작거나 1보다 크면 discard해야죠. (-0.5  0.5 사이의 값만 그려져야 되는데 굳이 0.5더해서 0~1사이 값인지 계산하는데 흠.. 굳이 한단계 더 거쳐야하나 싶음)



204