 - 지금 디퍼드 MRT의 텍스처 중에 컬러텍스처만 스왑체인에 옮겨놓는 작업만 한게 다에요.
   이제는 스왑체인으로 넘기기전에 뭔가 처리를 해야 포워드렌더링과 똑같이 처리될까요?
   (빛이요) 그래 맞아요 빛처리요. 
   컬러텍스처에 있는 정보에 광원처리를 하면서 스왑체인에 가져와야 지연렌더링이 직접렌더링처럼 똑같은 결과로 렌더링이 되겠죠?

 - CRenderMgr.cpp 에서 멀티렌더타겟 만들기
    Light MRT. 얘는 총 2장의 렌더타겟으로 되어 있어요.
    첫번째 - DIffuse 램버트 코사인 법칙으로 노말값 계산. 우리가 늘 하던 빛계산임 표면의 노말값으로 밝기계산.
    두번째 - specular 얘는 반사광 계산. 얘도 늘 하던거. 카메라랑 물체 사이 빛 강조했던거.
    
   && 중간에 디퍼드 MRT 구성을 번경. Emissive 타겟은 물체가 스스로 빛을 내는 경우를 계산. 디퍼드 쪽에 있던 놈이여서 원래 있던 데이터 텍스처 없애고 그자리에 이 텍스처 넣어주는 걸로 수정

 - CCamera::render()
  - 과정 설명해보자면 우선 디퍼드 MRT에서 분할해서 그리고
    Lighting()으로 광원처리하고
    Merge()로 그래픽처리를 통합해서 계산하고. (-> 오늘 수업에서 원래있던 병합하는 코드를 Merge()함수로 따로 뻄!)
    Forward()렌더링 실시.
    마지막으로 후처리까지.

 - CCamera::Lighting()
  - 디퍼드 MRT는 광원같은거 전혀 신경안쓰고 물체만의 정보를 저장했고
    여기서는 빛관련 데이터를 따로 계산해서 저장해놓는 MRT에요.
    여기서 디퍼드 MRT에서 저장했던 정보와 라이팅 MRT에서 저장한 정보를 병합해서 스왑체인

    광원만 따로 블러처리한다던지 빛번짐 효과같은걸 구현하고 싶다면 광원정보만 따로 저장해서 추가적인 가공을 하고 물체 색상과 병합해서 다양한 효과를 누릴 수 있기 때문에
    색상과 빛을 분리처리 하는 겁니다. 또 이렇게 분리처리 해서 얻는 이득중 하나가, 
    
    아 그리고 3D애서 뭔가 새로운걸 배울때 무조건 공부할때 항상 장단점을 정리하셔야합니다. 이런 고민을 안하면 면접관들은 그걸 파고들어요. 디퍼드 MRT 왜썼어요? 이렇게 물어본단말이에요
    단점은 없어요? 오 그거 왜썼어요? 이렇게 물어보고 대답 못하면 대충 학원에서 가르쳐 준거 대충 했구나 이렇게 생각한데요.

    자 이어서 말하자면, 이렇게 돌아가면서 그래픽 처리하는 이유가 뭐냐,
    첫번째 특정 정보에대한 데이터를 따로 받을수 있다는 거에요. 포워드 렌더링에서는 어려웠던 작업이죠.
    두번째 광원 숫자가 늘어나면 포워드렌더링보다 오히려 빨라지는 경우가 있어요. 다중광원, 스킬이펙트가 화려한 게임일수록 더 빨라질수 있단거죠. 왜그런지 설명하자면
    
    단점은 첫째 광원을 적게 쓸경우 좀 느리다
    둘째로 반투명한 물체를 처리하기가 쉽지 않다는 겁니다. 디퍼드 쪽에서 반투명처리가 힘듭니다. 그래서 제가 설계를 포워드렌더링으로 반투명처리 하려고 따로 남겨둔 겁니다 camera의 렌더링에서.
    디퍼드렌더링과 포워드 렌더링을 섞어쓰고있는 엔진인거죠 그래서 면접관이 물어보면, 반투명처리 어캐했어요 이렇게 물어보면 아 섞어 씁니다 이렇게 대답할줄 알아야된다구요. 제가 엔진 설계를
    아무 생각없이 한게 아닙니다. 반투명 처리는 포워드로 했다는점 기억하세요.

   - 자 그럼 광원이 많아질수록 왜 더 빨라질수 있냐를 설명할게요.
     만약 광원이 300개인 포인트 라이트가 있다고 가정할게요. 근데 물체가 다 범위 밖에있어서 영향을 하나도 안받는다고 해볼게요. 근데 쉐이더가 그걸 어떻게 알아요?
     그니까 쉐이더는 300개 다 계산해요 픽셀쉐이더에서. 
     반면 디퍼드렌더링에서는 이미 물체의 색상정보랑 포지션 노말 계산해서 각 타겟별로 감았지 광원에서 물체가 빛에 얼마나 영향받는지 계산같은거 했나요? 안했죠.
     그냥 디퍼드의 각 텍스처에 4장분할해서 정보를 저장해놨어요 광원정보는 광원 MRT에 따로 저장했구요.
     
     개념이 반대로 가는거에요 물체가 정보를 남겨 놓으면은 빛이 자기를 그리는거에요 물체가 빛을 계산해서 내 최종 색을 결정하는게 아니라.
     빛이 디퍼드의 포지션 타겟에서 좌표가 아무것도 없으면 거긴 어차피 그릴게 없으니까 계산을 안하는거에요. 
     이런방식으로 렌더링하면 빛의 범위에 없는 물체의 영역은 계산을 안하는 겁니다. 
     접근 개념 자체가 반대로 가는거죠 물체의 각 픽셀이 빛의 정보를 가지고 계산해서 내 최종 색깔을 결정하는게 기존 방식인데,
     그게 아니라 반대로 빛에서 내 영역에 물체가 있다는 정보가 있을때만 그 영역만 계산한다고요.

     체크하는 주체가 물체가 아니라 빛이 됩니다. 
     이걸 위해서 빛은 볼륨메쉬사용 - 본인이 영향을 주는 범위를 도형화한다. 실제 도형은 없지만.

  - 디렉셔널 라이트는 볼륨메쉬가 필요없어요 어차피 화면 전체를 검사해야하니까.
    이런 특징을 바탕으로 디렉셔널 라이트용 쉐이더를 만들게요.
 


 - CCamera::Lighting()
  - 이제 빛보고 물체 색깔을 계산하라고 할거에요.
    아 그리고 얘(Light3D)는 렌더컴포넌트가 아니에요 그냥 본인이 그려야할 영역을 남겨두는 개념으로 취급하기 때문에. 실제로 뭔가 형태가있고 그걸 그려주고 그런게 아닙니다.
  
  - 우선 맨처음 하는 작업은 Light MRT로 변경하고요
    그 다음  광원이 자기 영향범위에 있는 디퍼드 물체에 빛을 남깁니다. 

 - CLight3D::render()
  - 본인이 디렉셔널라이트인경우, 포인트인경우, 스팟인경우가있는데 현재는 쉽게 디렉셔널라이트인 경우만 생각하자구요.
    화면전체에 픽셀쉐이더 호출시킬 꺼니까 rectmesh 불러와야합니다.
    라이트전용 쉐이더 만들어야 겠네요.
 
 - light.fx
  - MRT는 Light에서 쓰이는 쉐이더이고, 메쉬는 RectMesh이고, 깊이타입은 애초에 라이팅 MRT자체가 깊이 텍스처가 없고 뭔가 깊이 정보값을 저장하려는게 아니라 diffuse 텍스처에 
    물체가 있는 영역을 표시하는 것이기 때문에 NO_TEST_NO_WRITE 무슨 깊이값을 남겨두려는 작업이 의미가 없습니다.
    자 그리고 블렌딩설정이 중요해요. 빛이 누적되야 하기 때문에 ONE_ONE 으로 즉 일대일로 합쳐져야해요. 블렌드를 원원으로 잡아줘야합니다 광원이 겹치면 빛이 렌더링되는 개념이라.

    세팅해줘야할 파라미터는 포지션과 노말타겟텍스처입니다. 이 두놈이 있어야 라이트처리가 가능합니다.
    우선 개념부터 설명하면, 포지션텍스처 검색해서 뭔가 데이터가있다 그러면 빛계산을 해줘야 하는걸로 판단, 바로 노말텍스처로 가서 데이터 가져옵니다.
    포지션과 노말 두가지 정보를 알고있으니 그걸로 빛계산을하고 본인할거하고 넘기는 겁니다. 
 

199
===========================================================================




200