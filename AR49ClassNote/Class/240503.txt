 - 지금 디퍼드 MRT의 텍스처 중에 컬러텍스처만 스왑체인에 옮겨놓는 작업만 한게 다에요.
   이제는 스왑체인으로 넘기기전에 뭔가 처리를 해야 포워드렌더링과 똑같이 처리될까요?
   (빛이요) 그래 맞아요 빛처리요. 
   컬러텍스처에 있는 정보에 광원처리를 하면서 스왑체인에 가져와야 지연렌더링이 직접렌더링처럼 똑같은 결과로 렌더링이 되겠죠?

 - CRenderMgr.cpp 에서 멀티렌더타겟 만들기
    Light MRT. 얘는 총 2장의 렌더타겟으로 되어 있어요.
    첫번째 - DIffuse 램버트 코사인 법칙으로 노말값 계산. 우리가 늘 하던 빛계산임 표면의 노말값으로 밝기계산.
    두번째 - specular 얘는 반사광 계산. 얘도 늘 하던거. 카메라랑 물체 사이 빛 강조했던거.
    
   && 중간에 디퍼드 MRT 구성을 번경. Emissive 타겟은 물체가 스스로 빛을 내는 경우를 계산. 디퍼드 쪽에 있던 놈이여서 원래 있던 데이터 텍스처 없애고 그자리에 이 텍스처 넣어주는 걸로 수정

 - CCamera::render()
  - 과정 설명해보자면 우선 디퍼드 MRT에서 분할해서 그리고
    Lighting()으로 광원처리하고
    Merge()로 그래픽처리를 통합해서 계산하고. (-> 오늘 수업에서 원래있던 병합하는 코드를 Merge()함수로 따로 뻄!)
    Forward()렌더링 실시.
    마지막으로 후처리까지.

 - CCamera::Lighting()
  - 디퍼드 MRT는 광원같은거 전혀 신경안쓰고 물체만의 정보를 저장했고
    여기서는 빛관련 데이터를 따로 계산해서 저장해놓는 MRT에요.
    여기서 디퍼드 MRT에서 저장했던 정보와 라이팅 MRT에서 저장한 정보를 병합해서 스왑체인

    광원만 따로 블러처리한다던지 빛번짐 효과같은걸 구현하고 싶다면 광원정보만 따로 저장해서 추가적인 가공을 하고 물체 색상과 병합해서 다양한 효과를 누릴 수 있기 때문에
    색상과 빛을 분리처리 하는 겁니다. 또 이렇게 분리처리 해서 얻는 이득중 하나가, 
    
    아 그리고 3D애서 뭔가 새로운걸 배울때 무조건 공부할때 항상 장단점을 정리하셔야합니다. 이런 고민을 안하면 면접관들은 그걸 파고들어요. 디퍼드 MRT 왜썼어요? 이렇게 물어본단말이에요
    단점은 없어요? 오 그거 왜썼어요? 이렇게 물어보고 대답 못하면 대충 학원에서 가르쳐 준거 대충 했구나 이렇게 생각한데요.

    자 이어서 말하자면, 이렇게 돌아가면서 그래픽 처리하는 이유가 뭐냐,
    첫번째 특정 정보에대한 데이터를 따로 받을수 있다는 거에요. 포워드 렌더링에서는 어려웠던 작업이죠. 데이터를 따로받아서 그 데이터에만 추가적인 연산을 시키고 나중에 병합할수 있다는것.
    두번째 광원 숫자가 늘어나면 포워드렌더링보다 오히려 빨라지는 경우가 있어요. 다중광원, 스킬이펙트가 화려한 게임일수록 더 빨라질수 있단거죠. 왜그런지 설명하자면
    
    단점은 첫째 광원을 적게 쓸경우엔 포워드렌더링보다 좀 느리다
    둘째로 반투명한 물체를 처리하기가 쉽지 않다는 겁니다. 디퍼드 쪽에서 반투명처리가 힘듭니다. 그래서 제가 설계를 포워드렌더링으로 반투명처리 하려고 따로 남겨둔 겁니다 camera의 렌더링에서.
    디퍼드렌더링과 포워드 렌더링을 섞어쓰고있는 엔진인거죠 그래서 면접관이 물어보면, 반투명처리 어캐했어요 이렇게 물어보면 아 섞어 씁니다 이렇게 대답할줄 알아야된다구요. 제가 엔진 설계를
    아무 생각없이 한게 아닙니다. 반투명 처리는 포워드로 했다는점 기억하세요.

   - 자 그럼 광원이 많아질수록 왜 더 빨라질수 있냐를 설명할게요.
     만약 광원이 300개인 포인트 라이트가 있다고 가정할게요. 근데 물체가 다 범위 밖에있어서 영향을 하나도 안받는다고 해볼게요. 근데 쉐이더가 그걸 어떻게 알아요?
     그니까 물체의 픽셀쉐이더는 광원 300개에 대해서 다 계산해요 픽셀쉐이더에서. 
     반면 디퍼드렌더링에서는 이미 물체의 색상정보랑 포지션 노말 계산해서 각 타겟별로 저장했지 따로 광원에서 물체가 빛에 얼마나 영향받는지 계산같은거 했나요? 안했죠.
     그냥 디퍼드의 각 텍스처에 4장분할해서 정보를 저장해놨어요 광원정보는 광원 MRT에 따로 저장했구요.
     
     개념이 반대로 가는거에요 물체가 정보를 남겨 놓으면은 빛이 자기를 그리는거에요 물체가 빛을 계산해서 내 최종 색을 결정하는게 아니라.
     빛이 디퍼드의 포지션 타겟에서 좌표가 아무것도 없으면 거긴 어차피 그릴게 없으니까 계산을 안하는거에요. 
     이런방식으로 렌더링하면 빛의 범위에 없는 물체의 영역은 계산을 안하는 겁니다. 
     접근 개념 자체가 반대로 가는거죠 물체의 각 픽셀이 빛의 정보를 가지고 계산해서 내 최종 색깔을 결정하는게 기존 방식인데,
     그게 아니라 반대로 빛에서 내 영역에 물체가 있다는 정보가 있을때만 그 영역만 계산한다고요.

     체크하는 주체가 물체가 아니라 빛이 됩니다. 
     이걸 위해서 빛은 볼륨메쉬사용 - 본인이 영향을 주는 범위를 도형화한다. 실제 도형은 없지만.

  - 디렉셔널 라이트는 볼륨메쉬가 필요없어요 어차피 화면 전체를 검사해야하니까.
    이런 특징을 바탕으로 디렉셔널 라이트용 쉐이더를 만들게요.
 


 - CCamera::Lighting()
  - 이제 빛보고 물체 색깔을 계산하라고 할거에요.
    아 그리고 얘(Light3D)는 렌더컴포넌트가 아니에요 그냥 본인이 그려야할 영역을 남겨두는 개념으로 취급하기 때문에. 실제로 뭔가 형태가있고 그걸 그려주고 그런게 아닙니다.
  
  - 우선 맨처음 하는 작업은 Light MRT로 변경하고요
    그 다음  광원이 자기 영향범위에 있는 디퍼드 물체에 빛을 남깁니다. 

 - CLight3D::render()
  - 본인이 디렉셔널라이트인경우, 포인트인경우, 스팟인경우가있는데 현재는 쉽게 디렉셔널라이트인 경우만 생각하자구요.
    화면전체에 픽셀쉐이더 호출시킬 꺼니까 rectmesh 불러와야합니다.
    라이트전용 쉐이더 만들어야 겠네요.
 
 - light.fx
  - MRT는 Light에서 쓰이는 쉐이더이고, 메쉬는 RectMesh이고, 깊이타입은 애초에 라이팅 MRT자체가 깊이 텍스처가 없고 뭔가 깊이 정보값을 저장하려는게 아니라 diffuse 텍스처에 
    물체가 있는 영역을 표시하는 것이기 때문에 NO_TEST_NO_WRITE 무슨 깊이값을 남겨두려는 작업이 의미가 없습니다.
    자 그리고 블렌딩설정이 중요해요. 빛이 누적되야 하기 때문에 ONE_ONE 으로 즉 일대일로 합쳐져야해요. 블렌드를 원원으로 잡아줘야합니다 광원이 겹치면 빛이 렌더링되는 개념이라.

    세팅해줘야할 파라미터는 포지션과 노말타겟텍스처입니다. 이 두놈이 있어야 라이트처리가 가능합니다.
    우선 개념부터 설명하면, 포지션텍스처 검색해서 뭔가 데이터가있다 그러면 빛계산을 해줘야 하는걸로 판단, 바로 노말텍스처로 가서 데이터 가져옵니다.
    포지션과 노말 두가지 정보를 알고있으니 그걸로 빛계산을하고 본인할거하고 넘기는 겁니다. 
 

 정리 - 지난 시간에 그냥 컬러텍스처에서 스왑체인으로 데이터 고대로 가져오는 거까지 했고, 여기에 빛계산, 그중 diffuse 처리까지 하고 스왑체인에 넘기는걸 구현해보자. (반사광은 나중에하고)
       즉 컬러텍스처->스왑체인 까지 했는데 그걸
          컬러텍스처-> diffuse 빛계산 연산 -> 스왑체인 지금 이 작업을 하고있음.
          아 더 정확히는
          컬러텍스처-> diffuse 빛(그중에서도 디렉셔널라이트) 연산 -> 스왑체인 

       - 지금 diffuse 계산 구현만 하려는데 진짜 엄청나게 많은걸 했음..그리고 아직 다 끝나지도 않았음
          2교시때는 diffuse의 디렉셔널 빛계산 쉐이더 작성하는 코드를 짤거임.

          diffuse일때 반사광일때 계산하는거 구현안했고, diffuse 중에서도 디렉셔널 포인트 스팟라이트 구분하는것도 안했음..


199
===========================================================================

 - 자 지난시간에 이어서 light.fx 쉐이더 작성해봅시다.

  - 입력구조체 생각해보면.. 전체화면이니까 렉트메쉬 들어올꺼잖아요
   -UV 값이 필요해요 자기자신의 호출된 UV값을 알아야 보간된 UV로 디퍼드의 포지션텍스처에서 가져온단 말이죠

 - 정점쉐이더는 포지션텍스처에서 가져올 포지션과 UV값만 게산해주고 끝.

 - 픽셀쉐이더의 결과값은 뭐가 필요할까?
  - 우리가 첫시간에 Light MRT는 렌더타겟 2개라고 했죠? 그럼 SV_Target도 두개여야겠죠. diffuse와 specular.
  
 - g_tex_0 에는 포지션렌더타겟이 무조건 세팅되어 있어야해요.
   이걸 샘플링해서 꺼내옵니다. 이때 우리가 초반에 아무것도 없다는 의미로 (0 0 0 -1)로 클리어 컬러를 설정했어요 (지난시간에는 0 0 0 1인데 오늘 마지막 인자를 -1로변경)
   즉 w값이 -1일때 discard하면 되겠죠 물체가 아무것도 없다는 거니까.

   근데 w가 -1이 아니다? 그럼 뭔가 물체가 있다는거니까 이때 노말값을 가져옵니다. 역시 이때도 g_tex_1에 노말벡터텍스처가 세팅되어 있어야합니다.
   이 g_tex_1을 샘플링해서 값을 역시 가져옵니다.
   애초에 노멀라이즈 한 값이긴 하지만 그래도 노멀라이즈를 픽셀쉐이더상에서 한번더 해주구요 그편이 속 편하니까.
   
   이제 CalculateLight3D()함수로 빛 계산을 하면 되는데 이때 픽셀쉐이더에서 계산을 하는 빛의 인덱스를 첫번쨰 인자로 요구했죠?
    CLight3D 에 본인의 인덱스를 맴버로 새롭게 추가할게요.
    랜더매니저에서도 Register 할때 size-1 값이 빛의 인덱스가 되겠죠 <- 너무 빨리 지나가서 렌더 매니저에서 -1한 코드 확인해라
    쉐이더에서도 g_int_0에 라이트의 인덱스 정보를 전달합니다.
     
   자 다시 돌아와서 CalculateLight3D()로 빛의 세기 계산하고요.
   --- 시바 뒤에 못들었다. 어쨌든 뒷부분 코드 보면됨



 - CAssetMgr.init.cpp
  - DirLightShader 만들기
   - 앞에서 쉐이더 주석에서 적어논대로 설정값 설정하구요.
     DirLightMtrl 만듭시다.

 - 이제 Light보고 렌더링 하라고 하면 DirLightMtrl 로 렌더링하겠쬬.
   이제 광원도 메쉬하나를 참조 해야합니다. 맴버로 m_VolumeMesh와 재질이 있어야 합니다 새로 추가 해야합니다.
   
 - 또 CLight3D::SetLightType()에서  본인의 타입만 저장하는게 아니라
   본인의 빛 타입에 따라서 참조해야할 메쉬와 머터리얼을 설정하는 코드를 추가할게요. 

   포인트라이트는 메쉬로 스피어를 써야겠죠. 머터리얼은 간단하지 않아요 디렉셔널 라이트에 비해서. 나중에 구현할거구요

   스포트라이트였다면 볼륨메쉬로 원뿔이 되야겠죠. 그런데 게임적 허용으로 콘메쉬를 써도 될거같습니다. 
   ConMesh는 여러분들이 만드세요. 과제입니다 스피어 메쉬 만들때랑 원리는 비슷해요 끝지점 아래지점 정해놓고 둘둘 두르면서 정점 위치 정하면 됩니다 위로 올라가면서.


 - CLight3D::render()
  - 디렉셔널일때 
   - 재질에다 INT_0 슬롯에 빛 인덱스 정보 전달하구요
     
     TEX_0과 TEX_1에는 빛 타입이 어떻건 간에 공통적으로 포지션텍스처와 노말텍스처가 들어가겠쬬.
     그래서 디렉셔널 머터리얼 초기화하는 코드 바로 밑에 미리 세팅해 놓습니다. (CAssetMgr_init.cpp 에서 DirLightMtrl 초기화 하는 코드 참조)
     이를 위해서 매니저들 초기화하는 순서 좀 바꿨어요 (자세히 보진 못했는데 렌더매니저와 에셋매니저 초기화 순서 바꾼걸로 보임 정확하지 않음 확인필요)

 - 여기까지 하고 실행해봅시다. 
  - Imgui상에서 디퓨즈 텍스처 확인하는데 잘안나옴, 이유는 imgui상에서는 알파값 0으로 하는 부분이 있다고? 함 그래서 쉐이더에서 강제로 알파값 1로 설정하고, 
    이번엔 렌더매니저에서 ClearMRT()에서 클리어 안해주고 있어서 카메라 위치 바꿔 볼때마다 흰색으로 채워지는 현상있었는데 LightMRT 클리어하는 코드 한줄 추가.

 - 에셋매니저에서 머지머터리얼 만들때 아예 고정적인 파라미터 고정적으로 박아넣음
   TEX_0 TEX_1 TEX_2 에 컬러, 디퓨즈, 스페큘러. 무조건 이미 세팅 되어있는 텍스처 입니다

 - merge.fx
  - g_tex_0 등등에 바로 위에서 3개 텍스처 설정해논거 가져오고요

  - PS_Merge() 함수에서 그 텍스처들 바탕으로 픽셀 색깔 계산하면
    빌드해보면 MRT 적용 전이랑 똑같은 결과가 나왔습니다. 


 - 진짜 복잡한 과정을 통해서 겨우 여기까지 왔네요. 결과는 하나도 달라진게 없지만. 
 
 - ui 같은건 포워드렌더링입니다. 대부분 3D는 디퍼드일 거구요.
  
 - 최종렌더링이 끝나고 나서도 포지션텍스처에 포지션 값이 기록되어 있어요 나중엔 뭐가 가능하냐면
   최종렌더링이 끝났지만 포지션 정보가 다 기록되어 있기 떄문에 z값만 따로 추출해서 Depth fog를 줄수 있어요 블러를. 
   블러가 뭐에요 한 픽셀지점에서 주변 색상의 평균값으로 설정해서 뿌옇게 하는거잖아요
   그거를 z값을 바탕으로 하는거죠 멀리 있을 수록 더 뿌옇게 만드는 거죠 


 - 다음시간에 만들 데칼도 디퍼드 렌더링에서만 할수있어요 

 - 정리 - 머지끝












200