 & 오늘은 코드리뷰 및 외부라이브러리 포함시킵니다.
 
 * FMOD 
  - 사운드 관련된 라이브러리 파일을 제공. 직접 다운로드 해도 되지만 이전 기수에 미리 썼던 걸 우리엔진쪽으로 복사붙여넣기 하겠다
  - 동적라이브러리여서 dll에 실제 코드가 들어있고, 
    우리프로그램이 실행될때 dll도 같이 실행되는데 이때 그 dll의 정보가 lib파일에 있음
    lib는 어떤 dll에 있는 코드인지 위치를 명시해주는역할. 필요할때 dll과 우리프로그램을 링크한다.
    !!) lib도 dll파일에대한 링크정보가 들어있어서 꼭 필요한거임
    
  - fmodL 뒤에 L붙은게 디버그 버전이고 L없는게 릴리즈버전.
  
  - 파일상에서 FMOD 관련된 파일을들 다 위치시켰으면 코드상에서 실제로 불러와보자.
  - Engine쪽에서 CSound 클래스 생성.
   - 생성자에서 기본에셋 설정을 false로 해놓음. 당연한거임 무슨 사운드를 하드코딩으로 엔진에셋처럼 만들어서 쓰는 방법은 없음. 무조건 파일로 불러와서 쓸거니까.
   - 맨위에 헤더파일을 include하고, lib파일을 pragma한다. lib는 release, debug 설정에 따라 다르게 참조하도록 전처리기 처리를 해놓음
     마지막으로 dll파일과 실행파일 위치를 같게 하면 되는데 일단 실행파일이 어딨지..? 그리고 dll파일들은 OutputFile>bin에 있넹? 흠.. 이 부분은 확인필요

   - 맴버로 Sound라는 객체포인터를 가진다. m_pSound
    - 사운드 클래스 하나가 소리 하나를 담당한다.

   - 리스트로 Channerl클래스 포인터를 들고있다 m_listChannel
    - 사운드가 동시에 여러개 재생되어야할 상황일떄, 지난 API 에서는 똑같은 사운드라도 겹쳐서 들려야하는 순간에 그만큼 똑같은 사운드 객체를 만들어야 했다.
      왜냐면 사운드 재생은 일방통행이기때문에 사운드 재생도중 어느 한 지점으로 이동하면 거기서부터 무조건 순차적으로 재생되어야했기 때문이다.
      (정확한 동작 기전은 파악못했는데 대충 설명을 들으니 어쨌든 사운드 동시 재생은 에러사항이 있었다고 함)

      FMOD는 반면 채널이라는 개념을 도입해서, 채널은 총 32개가 있고, '재생해'라고 하는 순간 32개 채널(빈 방)중 하나에 사운드를 옳겨서 재생시킨다
      즉, 같은 소리를 동시에 재생 시킬수 있는 최대치가 한 채널당 32개 지원해준다.
      
      채널을 가지고 있는 사운드객체는 본인을 누가 재생시키고 있는지 알고있어야한다.

    - FMOD는 사운드 무한루프하려면 루프카운트가 -1이여야하고, 한번재생은 0이여야한다. 선생임은 이게 빡쳐서 일부러 인자를 하나더 크게 받아서 내부에서 알아서 1하나 빼줘서
      FMOD 라이브러리에 넘겨준다고한다. 우리가 인자로 보낼때는 0이 무한루프, 1이 한번재생으로 취급하면됨

    - Play()함수
     -_bOverlap은 소리가 중첩해서 들려서는 안된다는 bool값이다. 이때 채널이 비어있지 않으면 오류처리한다.
     - 사전설정 완료된 pChannerl은 Sound객체의 m_listCannerl에 push_back해서 관리해준다.

     - 콜백은 채널에 사운드를 재생시켰을때 작동되어야할게 있다면, 콜백기능 지원해주니까 함수포인터를 인자로 넘겨주라고
       setCallback()이라는 함수를 제공해준다. 

     - 선생님이 Channel_Callback()이라는 콜백전역함수 하나 만듬 FMOD 양식에 맞게.
       (윈도우상에서 소리 종료될때 채널관리에서 제거하는 기능인가봄 자세한건 코드 자세히 봐라)

    - RemoveChannerl()함수
     - 재생이 끝난 채널은 빈 방이여야하는데 Sound객체는 계속 그 빈방을 재생된걸로 간주하고 관리하고있음
       따라서 재생끝난 채널은 리스트에서 제거하는 작업을 해주는 함수가 바로 이 함수.

   ^^ 콜백꼭 필요없는데 굳이 쓴 이유가 뭐냐면 사운드 오버랩기능을 구현하고 싶었기 때문이다.
      m_listChannel에서는 항상 재생중인 사운드만 들어있었으면 좋겠어서 그걸 FMOD가 제공하는 콜백기능으로 구현했다는 말.
     
   - SetVolume()함수 
    - 사운드 볼륨은 그 사운드를 재생중인 채널의 볼륨설정을 해줘야한다.


 - FMOD의 시스템 포인터가 처음엔 null이다. 이게 실재해야 FMOD 기능을 쓸 수가 있다.
   에셋매니처 초기화할때 FMOD쪽 관리자를 정적맴버변수로 생성시켜준다.
   그 역할을 하는 함수가
   Init_Sound()함수 이다. ,CAssetMgr_init.cpp

 - 꼭까먹지 말고 FMOD도 매 프레임마다 tick()돌려줘야해요 사운드도 tick에 맞춰서 소리를 재생합니다.
   g_pFMOD->update(); 부분이 FMOD 시스템객체의 tick을 돌려주는 부분입니다. Engine의 tick()에 위치.

 - 에셋매니저의 load하면 sound 타입맞게 sound 객체를 만들고, 그 sound 객체의 load가 실행되면 소리가 로드된겁니다.

 - FMOD 내부에서 확장자알아서 분류해주니까 확장자는 신경안써도됩니다.

 - 사운드를 추가해 줬으니까 imgui쪽에서 SoundUI 클래스쪽 살펴봅시다.
  - content UI 쪽에는 사운드파일이 자동로딩이 되어서 보이는데 인스펙터상에는 sound글자상자만 있고 play버튼이 없어요 이거 만들어서 재생시켜봅시다.


 && 문제점발생) 개별사운드가 다 relese 되고서 FMOD관리자가 release되는게 FMOD구조다. 
                에셋매니저의 소멸자에서 release했더니 오류났고, Engine 소멸자 쪽에서 고대로 갖다 붙이니 문제가 해결됨. 
                무슨 소멸자도 스택어쩌구 했는데 자세히 이해못함..
                FMOD 관리자를 매우 나중에 release하려면 나중에 소멸하는 Engine클래스 소멸자 쪽에 FMOD관리자 release를 해준다고함.

=====================================================================================================================
** 사운드가 실제로 어떻게 load되는지 다시한번 유의깊게 인지할것. 
   1) 사운드 로드하려고 에셋매니저에서 Load()함수 실행하면
   2) 처음 만들어지는 사운드면 Sound객체가 생성되고 거기서 Load()함수가 실행되고,
   3) FMOD 라이브러리가 최종적으로 실행된다.
   이게 맞는지 정확한 공부필요.
 
 - 인스펙터의 Sound에 play버튼 만들어주기.
  - path.filename().generic_string().c_str() 이부분좀 분석해줘..
   - (공부전에 예상해보기 - 경로의 파일 이름을 string객체형식으로 받아오고, 그걸 c_str()로 포인터? 형으로 반환한다?)

 - 어떤 상황에 무슨 사운드를 재생해라는 보통 스크립트에서 제어하겠죠
   player 스크립트쪽에서 소리 재생되는 상황을 만들어봅시다.

   아 그전에 레벨 Play, Stop, Pause를 Menu에서 제어하는 기능 마저 완성해야합니다.
   레벨 stop인 상황에선 tick()이 안도니 소리도 재생 안되니까요. 
 
 - LevelMgr에서 레벨 상태가 어땠건 무조건 tick()함수 호출하는 상황이었는데 이걸 레벨이 play상태일때만 tick()함수 실행하도록 구조를 바꿉니다.
  - m_CurLevel->GetState()로 if문 걸어줌

 - fun.h, Play2DSound()함수
  - 이펙트나 효과음, 타격음 같은데에 쓰라고 만든 사운드 함수입니다

 - Play2DBGM()함수
  - 어떤 사운드를 백그라운드용으로 재생시킬때 쓰이는 함수.
  - 약간 야매 형식을 쓴다함
    static 지역변수를 이용해서 무조건 단 하나의 bgm만 재생되게한다함

    백그라운드 뮤직은 당연히 루프가 활성화되고, 오버랩금지 설정은 디폴트임


 - 3D Sound는 포폴 표시가 안나서 안할건데 관심있는 친구는 하세요. 
   개념만 알려주자면 FMOD에 좌표갑을 넣을 수 있음. 현재 사운드 위치가 어디냐에따라 소리가 다르게 들림
   이걸 적용하려면 컴포넌트 하나더 추가해야함
   SoundPlay 컴포넌트. 얘의 역할은 tick()마다 본인의 위치값을 갱신해서 FMOD에 알려주는 역할을한다.
   
   이걸 어디에쓰느냐, 폭포소리 등에 쓰일수있음. 어테뉴에이션(감쇠효과)을 FMOD가 전달받은 소리의 위치값으로 알아서 계산해서 알맞게 소리내개해줌

   이거는 수업시간에 직접구현하지는 않을겁니다.
   3D 포폴에는 구현하면 좋을거같아요 환경사운드로. 근처로 가면 용암이나 물소리가 알맞게 흘러나온다던지.


 - 다음시간엔 레벨세이브로드는 해놨는데 정작 레벨의 play stop pause하는 실질적인 기능은 안만들었어요 그거하나,
   폰트기능만들기,
   FSM을 컴포넌트로 하면 좋을거같아요

 













   

