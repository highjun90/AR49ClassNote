 - 지금 광원정보를 쉐이더에서 전역정보로 쓰고있는데요
   우리가 사용하고 있는 3차원 광원을 레벨에 배치되어있는 오브젝트로 바뀌어서 쓰여야합니다. 2D때 그랬던거처럼.
   그러기 위해서 컴포넌트를 하나 추가합시다.

   ** 3D광원 정보가 쉐이더에 어떻게 전달되는지 똑똑히 보세요 

 - CLight3D 클래스
  - 2D때처럼 tLightInfo 구조체를 들고있음. 빛의 여러가지 정보.
  - 컴포넌트 상속받았으니까 finaltick()구현해야되고요.
    생성자에 컴포넌트 타입을 맴버이니셜라이저로 초기화 해주고요(그 이전에 컴포넌트 타입 당연히 추가해줘야 했고요)
 
  - 새로운 컴포넌트 추가했으니 GameObject와 Component에 Get 매크로 추가해주고요.
  - CLONE() 매크로 구현되어있으니 복사생성자 고려해야되는데 2D때처럼 어차피 맴버가 tLightInfo 밖에 없어서 따로 구현 안할겁니다.
  - 레벨 Save Load()함수도 구현해 줘야겠죠. Light2D에 있는 코드 그대로 가져올게요 Info만 저장하면 되니까.

  - 파이널틱 에서 vWorldDir 하고 vWorldPos는 트랜스폼 컴포넌트가 관리해주고 있기때문에 월드값을 따로 저장해놓습니다.
  - 2D처럼 3D 광원도 구조화버퍼를 통해 렌더링매니저를 통해 정보를 전달할거에요.
   - 렌더링매니저에 RegisterLight3D()함수 추가
   - 파이널 틱에서 이 RegisterLight3D(this)를 호출해서 광원 자기자신을 등록.
   - 렌더매니저에의 UpdateData()에서 2d 광원에 해주는 작업과 복붙해서 똑같이 코드 넣어줍니다.
     3Dinfo 광원정보를 구조화 버퍼에 넣어줘서, t12 레지스터에 보내는거죠. 

   - 매프레임마다 레지스터에 등록시켜놓았으니까, 2D Clear()함수에서 놓아줘야죠. 아니면 계속 쌓이니까.

  - 이렇게 보니까 Light2D랑 다를게 없어보이는데 앞으로 기능이 엄청많이 추가될겁니다. 

 - CCreateTempLevel에 정의한 3D광원 추가해볼게요.
  - 광원타입을 디렉셔널로 설정
    빛 색깔은 흰색.
    앰비언트는 10퍼정도.
    반사광세기는 30퍼정도.


 - 복습합시다. 광원의 종류.
  - 방향성 광원(디렉셔널라이트) - 좌표공간 전체에 동일한 방향으로 일괄되게 빛을 쏘아주는 광원. 태양같은 광원. 너무 멀리서 온 광원이여서 광원의 위치가 의미가 없음. 
  - 포인트라이트 - 광원의 위치에서 일정 반지름영역까지 빛을 쏘아주는 광원. 
  - 스포트라이트 - 포인트라이트에서, 각도까지 제한된 광원. 즉 원이아니라 원보다 작은 부채꼴 모양으로 빛을 쏘아준다.



 - 오늘 std3d.fx에서 구조화버퍼에 저장된 정보로 색상값을 계산하기 때문에 코드가 엄청 복잡해 보이는데 사실 똑같은 겁니다. 잘 분석해보세요 그냥 변수이름만 길어졌어요.
   이제 전역으로 설정한 광원정보들 다 삭제할게요.




 - 그런데 만약 광원이 여러개인 경우에는 아직 처리가 안되있어요. b3레지스터에서 광원개수를 지정했는데 이걸 반복문을 통해 물체의 색깔을 정하게 구조를 바꿔야 합니다.
   이 작업 하기 전에 지금까지 구현해놓은 광원계산 부분을 함수로 따로 분리시켜 놓읍시다.
   CalculateLight3D() 함수
    - 입력인자로 물체의 정보과 광원의 정보를 가져와야겠죠? 그런데 이미 전역 구조화버퍼로 광원 정보를 전달해놓는 상태이기 때문에 광원의 인덱스 정보만 받아도 충분히
      광원의 모든 정보에 접근 할 수가 있죠. 

      첫번째로 광원정보를 가져올 인덱스

      두번째로 시선벡터 때문에 물체(픽셀표면)의 위치정보가 필요하구요(반사광계산할때필요) + 포인트 라이트광원일떄도 방향 계산할때 필요.

      세번째로 뷰스페이스 상의 노말벡터 정보가 있어야 빛의 세기를 계산하겠죠.

      네번째로 광원의정보를 inout으로 받아올겁니다. 


   - 이제 구조가 이렇게 됩니다
    -> 1) 픽셀의 최종 뷰스페이스 법선벡터를 구한다.
       2) CalculateLight3D() 함수로 한번 또는 그 이상 호출해서 영향 받고자하는 광원마다 필요한 연산을 수행하고 최종 빛 정보를 얻는다.
          그 최종 빛 정보를 tLightColor LightColor 에 저장해놓는다. 
       3) 2에서 여러 광원(또는한번해도됨) 처리가 누적 계산된 LightColor를 이용해서 물체(픽셀)의 최종 색을 계산해준다.



정리 : 광원정보를 쉐이더의 전역변수에서 설정해서 쓰고있었는데 그걸 우리 클라이언트의 오브젝트에서 쉐이더에 전달하는 구조로 바꿨다.
       3D광원을 컴포넌트로 새로 정의했고, 그걸 오브젝트에 붙여주면 3D광원 정보를 쉐이더에 전달할 수 있음. 지금까진 2D 라이트 구조와 별반 다르지 않지만 나중엔 기능이 더 많아진다.
       광원이 여러개일때를 고려해서 구조를 바꿈. 광원 갯수만큼 빛의 정보 계산을 계속 누적해서 최종 결과 데이터를 물체에 적용하는 방식.




188
====================================================================================================

 - 지금은 무조건 디렉셔녈 라이트일 경우만 고려해서 빛의 세기를 계산하고 있는데 포인트 라이트일경우도 고려해서 분기처리가 필요합니다.
   CalculateLight3D() 함수에서 LightType이 0번일때(디렉셔널)와 아닐때를 if문으로 구분해서 처리합니다. (define.h 에 enum으로 광원의 종류를 정의했으니 참고하세요)
   if문으로 방향값만 다르고 나머진 다 비슷하게 계산됩니다.

   1 일때 - 기존 코드와 동일.
    - 그냥 빛의 월드방향에 뷰변환행렬 곱하면 빛의 방향 계산 끝남.

   2 일때 - 포인트 라이트.
    - 광원 위치에 따라 물체에 도달하는 빛 방향이 계속바뀜.
    1) 광원정보에서 광원의 월드좌표를 가져온다. 지금 우리는 뷰스페이스 기준으로 연산을 하고있으니 여기에 뷰스페이스변환 행렬을 곱해서 광원의 뷰스페이스 위치를 구한다.
    2) 물체에서 광원 위치를 빼야 광원에서 물체를 향하는 방향벡터가 나오겠죠? 
       그걸 벡터의 길이를 구해주는 함수인 length()함수로 fDistance에 미리 따로 저장시켜놓고 노멀라이즈합니다.
       fDistance는 나중에 광원 범위 넘어가는지 검사하려고 따로 저장해놓는거에요 일단 우리가 원하는 빛의 방향은 구했습니다.

    3) 빛의세기도 설정됩니다.
       물체가 빛에서 멀어질수록 빛의 색은 약해지는데, 그 수식은
       
       빛의세기 =  1 - D/R 

       D가 광원과 물체 사이의 거리
       R이 광원의 범위.
      
       R과 D가 똑같다는건 광원범위 끝자락에 물체가 있다는 거죠. 근데 그값이 1이네? 즉 D/R이  1에 가까울수록 빛의 세기는 그 반대로 약해진다는 거니까 빛의세기는 1에서 D/R을 빼주면 되겠죠.
       그렇다고 너무 멀어졌을때는 D가 너무 커서 최종 결과가 음수 나오는데 빛의세기가 음수나오면 안되니까  saturate()함수 써주구요.

       이제 최종 빛 색깔 계산식에서 거리에따른 감쇠비율까지 곱해줍니다.(fDistancdRatio)
       이건 디렉셔널 광원만 계산했을 경우 어차피 소용없는 감쇠비율 이긴 합니다. 하지만 포인트라이트 광원이 하나라도 계산됬을땐 의미 있을 수 있겠쬬.




189