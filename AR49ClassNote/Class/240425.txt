 - 지금 광원정보를 쉐이더에서 전역정보로 쓰고있는데요
   우리가 사용하고 있는 3차원 광원을 레벨에 배치되어있는 오브젝트로 바뀌어서 쓰여야합니다. 2D때 그랬던거처럼.
   그러기 위해서 컴포넌트를 하나 추가합시다.

   ** 3D광원 정보가 쉐이더에 어떻게 전달되는지 똑똑히 보세요 

 - CLight3D 클래스
  - 2D때처럼 tLightInfo 구조체를 들고있음. 빛의 여러가지 정보.
  - 컴포넌트 상속받았으니까 finaltick()구현해야되고요.
    생성자에 컴포넌트 타입을 맴버이니셜라이저로 초기화 해주고요(컴포넌트 타입 당연히 추가하구요)
 
  - 새로운 컴포넌트 추가했으니 GameObject와 Component에 Get 매크로 추가해주고요.
  - CLONE() 매크로 구현되어있으니 복사생성자 고려해야되는데 2D때처럼 어차피 맴버가 tLightInfo 밖에 없어서 따로 구현 안할겁니다.
  - 레벨 Save Load()함수도 구현해 줘야겠죠. Light2D에 있는 코드 그대로 가져올게요 Info만 저장하면 되니까.

  - 파이널틱 에서 vWorldDir 하고 vWorldPos는 트랜스폼 컴포넌트가 관리해주고 있기때문에 월드값을 따로 저장해놓습니다.
  - 2D처럼 3D 광원도 구조화버퍼를 통해 렌더링매니저를 통해 정보를 전달할거에요.
   - 렌더링매니저에 RegisterLight3D()함수 추가
   - 파이널 틱에서 이 RegisterLight3D(this)를 호출해서 광원 자기자신을 등록.
   - 렌더매니저에의 UpdateData()에서 2d 광원에 해주는 작업과 복붙해서 똑같이 코드 넣어줍니다.
     3Dinfo 광원정보를 구조화 버퍼에 넣어줘서, t12 레지스터에 보내는거죠. 

   - 매프레임마다 레지스터에 등록시켜놓았으니까, 2D Clear()함수에서 놓아줘야죠. 아니면 계속 쌓이니까.

  - 이렇게 보니까 Light2D랑 다를게 없어보이는데 앞으로 기능이 엄청많이 추가될겁니다. 

 - CCreateTempLevel에 정의한 3D광원 추가해볼게요.
  - 광원타입을 디렉셔널로 설정
    빛 색깔은 흰색.
    앰비언트는 10퍼정도.
    반사광세기는 30퍼정도.


 - 복습합시다. 광원의 종류.
  - 방향성 광원(디렉셔널라이트) - 좌표공간 전체에 동일한 방향으로 일괄되게 빛을 쏘아주는 광원. 태양같은 광원. 너무 멀리서 온 광원이여서 광원의 위치가 의미가 없음. 
  - 포인트라이트 - 광원의 위치에서 일정 반지름영역까지 빛을 쏘아주는 광원. 
  - 스포트라이트 - 포인트라이트에서, 각도까지 제한된 광원. 즉 원이아니라 원보다 작은 부채꼴 모양으로 빛을 쏘아준다.



 - 오늘 std3d.fx에서 구조화버퍼에 저장된 정보로 색상값을 계산하기 때문에 코드가 엄청 복잡해 보이는데 사실 똑같은 겁니다. 잘 분석해보세요 그냥 변수이름만 길어졌어요.
   이제 전역으로 설정한 광원정보들 다 삭제할게요.




 - 그런데 만약 광원이 여러개인 경우에는 아직 처리가 안되있어요. b3레지스터에서 광원개수를 지정했는데 이걸 반복문을 통해 물체의 색깔을 정하게 구조를 바꿔야 합니다.
   이 작업 하기 전에 지금까지 구현해놓은 광원계산 부분을 함수로 따로 분리시켜 놓읍시다.
   CalculateLight3D() 함수
    - 입력인자로 물체의 정보과 광원의 정보를 가져와야겠죠? 그런데 이미 전역 구조화버퍼로 광원 정보를 전달해놓는 상태이기 때문에 광원의 인덱스 정보만 받아도 충분히
      광원의 모든 정보에 접근 할 수가 있죠. 

      첫번째로 광원정보를 가져올 인덱스

      두번째로 시선벡터 때문에 물체(픽셀표면)의 위치정보가 필요하구요(반사광계산할때필요) + 포인트 라이트광원일떄도 방향 계산할때 필요.

      세번째로 뷰스페이스 상의 노말벡터 정보가 있어야 빛의 세기를 계산하겠죠.

      네번째로 광원의정보를 inout으로 받아올겁니다. 


   - 이제 구조가 이렇게 됩니다
    -> 1) 픽셀의 최종 뷰스페이스 법선벡터를 구한다.
       2) CalculateLight3D() 함수로 한번 또는 그 이상 호출해서 영향 받고자하는 광원마다 필요한 연산을 수행하고 최종 빛 정보를 얻는다.
          그 최종 빛 정보를 tLightColor LightColor 에 저장해놓는다. 
       3) 2에서 여러 광원(또는한번해도됨) 처리가 누적 계산된 LightColor를 이용해서 물체(픽셀)의 최종 색을 계산해준다.



정리 : 광원정보를 쉐이더의 전역변수에서 설정해서 쓰고있었는데 그걸 우리 클라이언트의 오브젝트에서 쉐이더에 전달하는 구조로 바꿨다.
       3D광원을 컴포넌트로 새로 정의했고, 그걸 오브젝트에 붙여주면 3D광원 정보를 쉐이더에 전달할 수 있음. 지금까진 2D 라이트 구조와 별반 다르지 않지만 나중엔 기능이 더 많아진다.
       광원이 여러개일때를 고려해서 구조를 바꿈. 광원 갯수만큼 빛의 정보 계산을 계속 누적해서 최종 결과 데이터를 물체에 적용하는 방식.




188
====================================================================================================




189