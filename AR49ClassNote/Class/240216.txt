  * 오늘은 clone()관련 복사생성자 정리하는 작업함

 - Entity 클래스의 clone()함수는 자기자신을 복제해서 반환하는 순수가상함수입니다.
  - 그럼 이 clone()함수가 왜 필요하나? 예를들어 몬스터 오브젝트하나 만드려면 메쉬지정해숴 머터리얼 지정해줘 온갖 스크립트 붙여줘 이 작업이 너무 귀찮다.
    그렇다면 이렇게 사전설정한 오브젝트들을 레벨에 바로두지 말고 에셋매니저에 둬서 마치 에셋처럼 필요할때마다 뽑아쓰면 어떨까? 이런 개념을 프리페어 라고 한다.
    이 개념을 적용하려면 clone()함수 구현이 잘 되어있어야한다.
  - 이 개념대로라면 레벨조차 clone()될수 있음
   - CLevel()의 Clone()함수를 오버라이드 하는코드 자체는 간단하다. *this(본인)을 인자로주는 생성자를 리턴하면된다.
     return new CLevel(*this);
     문제는 이렇게 리턴된 레벨의 포인터는 얕은복사다. 리턴된 포인터는 메모리상에 실체가있는 복사본을 가리키는게아니라 복사의 대상이었던 원본 레벨을 가리키고있음.

  - 복사생성자에서 주의해야할점은 부모자식관계가 적용된 클래스를 다룰떄이다. 부모쪽에서 아무리 복사생성자를 제대로 호출했다고 해도,
    부모를 상속하는 자식클래스가 부모쪽 복사생성자를 명시적으로 호출하지 않는다면 부모쪽복사는 수행되지 않는다.
    예를들어 Entity클래스는 멤버로 m_ID를 갖고있는데, 만약 제대로 구현한 복사생성자를 호출하지 않으면
    새로생성한 Entity객체는 ID가 겹쳐버린다. 그래서 일차적으로 이걸 회피하는 코드를 복사생성자쪽에서 제대로 구현해놔야하고,
    이차적으론 Entity를 상속하는 자식클래스가 Entity의 복사생성자를 명시적으로 호출해야한다.
    명시적으로 안하면? 그냥 디폴트 폭사생성자를 호출해서 ID가 겹쳐버림. 자식쪽 복사만 제대로 하는 반쪽짜리 복사가된다.
  
 - Layer를 복제했다는건 무슨의미일까?
  - 레이어를 복제한다는것은 기존레이어뿐만아니라 레이어가 포함한 오브젝트를까지 고대로 복사해서 메모리상에 새로 존재해야된다. 즉 복사생성자를 제대로 구현해 놓지 않았다면
    또 얕은 복사로 레이어가가진 오브젝트들의 주소만 참조하게 된다. 

    단, m_vecParent만 제대로 깊은복사하면됨. 어차피 m_vecObject는 계속 넣었다 빼지기 때문에 이건 얕은복사로 두면된다.

 - Object의 복제는 어떻게 이뤄져야할까?
  - 헤더파일 보는 순간 컴포넌트 배열부터 깊은복사를 해야한다고 느껴진다. 이걸 얕은복사로 한다는게 말이안된다 복제된 오브젝트가 원본 오브젝트의 컴포넌트 주소를 참고하고 있는게 말이안됨
    복제된 오브젝트는 컴포넌트들도 실제로 메모리에 존재해서 독자적으로 가지고 있어야한다 남의꺼 참조하는게아니라.
  - m_iLayerIdx 는 원본오브젝트와 레이어소속까지 같이 설정될 필요는 없으므로 복제되는 순간엔 -1(무소속)으로 설정해줌.
  - 재귀함수를 써서 부모오브젝트의 자식오브젝트들 복사한다.
    오브젝트 사이의 부모자식 계층구조가 아무리 복잡해도 재귀함수로 구현하면 됨.
    어쨌든 부모오브젝트는 최상위 자식오브젝트가 지 할꺼 다한상태가 되면 m_vecChild.push_back()하면 끝임(재귀함수)

 - 컴포넌트의 Clone()은 Entity()가 순수가상함수였는데 정작 여기서도 또 순수가상함수로 오버라이드함 (이게되네;)
   이렇게 하는 이유? 반환자료형을 Entity포인터가 아니라 Component 포인터로 명시해줘서 오브젝트의 복사생성자에서 각 컴포넌트 대입이 제대로된다함 의미없어보여도 의미가있었음
   오브젝트 복사생성자의 AddCompont() 부분에서 Entity의 포인터로 반환하면 컴파일 오류가 나서 Component 포인터로 반환하게 만들고 싶으니 이렇게 굳이 순수가상함수를 순수가상함수로 오버라이드 했다.
   사실 이게 싫으면 반환결과를 강제캐스팅해도됨(Component*) 이런방법도 있다정도.
  - 이제 컴포넌트를 상속하는 각 컴포넌트 타입을 또 자세히 구현한다
  - 컴포넌트의 Owner를 얕은복사하면 문제가 되는데 오브젝트 쪽에서 복사생성자 호출시 컴포넌트복제를 대입연산자 안쓰고 AddComponent()함수 썼다면 문제가 없다 그래도
    찜찜하다면 맴버가 어차피 2개밖에 안되니까 구현해준다.
    복사생성자에 m_Owner(nullptr) 부분. 오브젝트쪽에서 주인 지정해주니까 걱정 ㄴ 


 - 트랜스폼컴포넌트는 그냥 Clone()만 정의. 왜? 위치값은 얕은복사해도됨 어차피 나중에 바꿀거야 얜 바닥이다 복사생성자의 말단부위. 더 작업 해줄 자식같은애도 없음.

 - CCollider2D는 안타깝게도 복사생성자를 제대로 구현해 줘야함.
   무슨 카운트 때문이라던데 제대로 못들음 아마  m_CollisionCount 같음 원본이 충돌한정보와 복사본이 충돌한 정보가 공유되면 안되니까. 얘 아니었으면 복사생성자 구현을 스킵해도 됬을거라함

 - CAnimator2D는 멤버볼때 딱봐도 복사생성자 구현해줘야함.
   애니메이션 객체를 따로 써야 인덱스가 공유안되서 따로 움직일것이 아닌가.
  - 원본 애니메이터의 map에서 모든 객체를 깊은복사해야한다.

**** 복사생성자를 구현하는 과정을 잘봤다. 레벨 복사생성자가 제대로 동작하려면 레이어 복사생성자가 제대로 구현되어 있어야하고, 레이어 복사생성자는 또 오브젝트 복사생성자를,
     또 오브젝트 복사생성자는 컴포넌트 복사생성자가 제대로 구현되어있어야되고.. 이렇게 지금은 선생님이 탑다운 방식으로 복사생성자 구현중이심.
     그 과정에서 부모쪽 복사생성자는 자식이 제대로 복사생성자가 구현되어있다고 가정하고 짜고 실제구현은 (탑다운이니) 나중에 한다.

     - 복사생성자 구현할때 보통 그 객체의 맴버를 보고 복사생성자 구현할지 안할지 결정한다. 본인의 맴버가 얕은복사되도 문제 없을거 같으면 복사생성자를 굳이 구현안하고 넘어간다 대표적인예가 트랜스폼 컨포넌트.

    - clone()함수는 그냥 복사생성자 호출해서 그렇게 생긴 객체의 포인터를 반환해주는게 끝이지만 의외로 공부할게 많음 매크로 구현해놓은거도 있고(컴포넌트쪽이엇나?) 
      오버라이드할때 또 순수가상함수로 오버라이딩하는경우도 봤고(이것도 컴포넌트)

============================================================================================================

 - 이어서 애니메이션의 복사생성자도 만듦

 - CLight2D는 그냥 CLONE(); 만 정의 복사생성자 안만듬

 - CCamera.h도 어차피 맴버들 값 다시받을거라서 얗은복사. 복사생성자 안받음

 - 렌더컴포넌트도 컴포넌트포인터로 Clone()이 반환하면 안되니 얘도 오버라이딩함 즉
   순수가상함수를(Entity) 순수가삼함수로 오버라이딩하고(Component) 그걸또 순수가상함수로 오버라이딩(RenderComponent)

   동적재질은 깊은복사 되야하므로 복사생성자 정의해줘야함

 - 메쉬랜더는 별거없어서 clone()만 정의

 - 타일맵마다 자신만의 구조화버퍼를 가지고 있어야 되기 때문에 얕은복사 하면 안됨 따라서 복사생성자 정의해줌(구조화버퍼하나 때문에 나머진 얕은복사 되는데도 어쩔수없이..)
 
 - 구조화버퍼는 생각할것도 없이 깊은복사되야함
  - read write 맴버는 알아서 어쩌구될꺼래서 복사생성자의 맴버이니셜라이저에서 뺌 <- 여기부터  HP 급격다운

 - 파티클시스템은 복사생성자 필요. 당연한거지만 부모인 렌더컴포넌트 복사생성자 부터 호출.

 - 스크립트는 얕은복사 되도됨
  - 플레이어, 미사일 스크립트에도 직접 가서 깊은복사 되야되는지 검사. 다 그냥 clone()만 정의하고 얕은복사함.

 - 상수버퍼는 오히려 Clone()을 방지할거에요. 얘는 복제생성되면 안됩니다 시스템메모리와 GPU에 일대일로 매칭되야 되는데 얘가 복제되면 GPU에 바인딩되는
   시스템메모리가 한개가 아닌 여러개가 되버리겠쬬
   하지만 순수가상함수 때문에 구조적으로 구현은 되야하기 때문에 CLONE_Disable()이라는 걸로 CLONE()을 대신합니다
   거기에 복사생성자 = delete 해주면 완벽.


 - Asset은 보통 깊은복사가 필요없지만 가끔 머터리얼같은 애처럼 깊은복사 필요한애가 있을때가 있으니 순수가상함수로 clone()선언.

 - 쉐이더나 메쉬 등등은 CLONE_DISABLE(), Material은 CLONE() 으로 오버라이드


 --- LevelMgr에 플레이어나 파티클 Clone()떠서 레벨에 추가시켰더니 똑같이 작동하는걸 확인했다.
     레벨단위는 안돘음