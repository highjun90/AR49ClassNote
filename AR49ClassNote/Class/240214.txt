 & 어제 파라미터 교환하고 있었다.
    (어제 컨디션이 않좋아서 2교시는 필기 많이 못함 피로로)
   imgui가 행렬 지원을 안해서 float4로 구현해야하기 때문에 귀찮아서 구현안하겠다 굳이 행렬을 표현해주고 싶은 사람은 구현해보라. 
   Module 필터에서 RaramUI 필터를 어제 새로 만들었다.

 - ParamUI.h 은 Imgui상의 어떤UI 에서 특정 값을 출력시켜주는 함수 <- 맞나? 이 파일의 목적을 제대로 이해?
   예를들어 MaterialUI.cpp 에서  ImGui::Text("Shader  ");로 텍스트를 출력시켜주는데 이건 한번 빌드하면 바뀌지가 않고,
   ParamUI.h 인터페이스로 구현하면 런타임 도중에 이런 파라미터를 바꿔서 바로 실제 오브젝트에 반영하는 등의 작업을 할수있음

 ** 선생님 수업시간에 Content의 Material을 클릭해서 인스펙터에 나온 파라미터의 값을 수정하면 사전에 설정한
    (두가지 설정. 하나는 std fx 파일에서 특정 바인딩된 파라미터값일때 노란색이 뜨게하는 등, 
     두번째는 CAssetMgr_init.cpp의 //Parameter 에서 쉐이더에 AddScalarParam()함수로 첫번째 인자에 바인딩해서 두번째 인자에 문자열을 바탕으로 설정)
    대로 오브젝트의 재질이 바꿔진다.

   *** 이걸왜하나-> 매번 쉐이더 변경마다 프로그램 끄고 했는데 이제는 imgui로 수치 딸깍 바꿔주면 머터리얼 쉐이더 등을 런타임중에 변경.


 - Param_TEXTURE()함수 
  - 똑같이 디스크립션 띄워주고 ID만들고, 얘는 이미지 띄워줘야되니까
  - 만약 머터리어에 텍스처가 없는 놈이었다면 첫번째 인자로 전달한 텍스쳐가 null 일것이다. 이때 이것의 쉐이더리소스뷰로 접근하면 오류가 날것이므로
    if문으로 texid에다가 GetSRV()->Get()을 받아서 쓰는 코드추가. 

 - void MaterialUI::render_update() 에서  // Shader Parameter 부분한번 보면
  - switch문이 있는데 여기서 imgui 화면에 값 고치면 실제로 쉐이더에 바인딩된 파라미터 값이 런타임 중에 변함
    ImGui::InputInt(szID, _Data) 부분인거 같은데 sprintf_s가 무한대기 안하는 거였던가?


  - Param_TEXTURE()함수에서 델리게이트에 필요한 Inst와 func을 넣어줬으면 버튼기능 활성화. 원래는 그냥 null 디폴트인자.
    버튼을 누르면 리스트 UI창이 띄워지게 하고, 거기서 선택한것을 재질에 적용시키는 구조를 만들것임.

  - MaterialUI.h 에 m_SelectTexParam 추가. 버튼눌러서 리스트UI 띄웠다면 거기서 선택한 텍스쳐가 이 맴버에 저장됨
   - Se;ectTexture()함수에서 인자로 DWORD_PTR 주는데 이것은 곧 텍스쳐의 경로이다. 

 *** [ 결론 ]
     content의 어떤 머터리얼의 텍스처를 imgui 상에서 바꾸고자할때 두가지 방법이있음, 
     인스펙터 상에서의 재질정보표시 중 Oupput Texture 1 옆의 텍스처 이름에 Content의 TEXTURE 목록 중 하나를 DragAndDrop으로 해도 되고, 
     이미지 옆에있는 조그만 네모버튼 클릭후 리스트 UI에서 어떤 텍스처 더블클랙해서 선택해도 재질의 텍스처 세팅이 바뀌게 구현했음

 
======================================================================================================

 $ 머터리얼 UI완료했고, 재질관련 이야기를 해보고자 한다.
  - 어떤 재질을 변경하면 그 재질을 사용하는 모든 컴포넌트는 그에 맞춰 동일하게 변경된다. 
    그런데 쉐이더에서 어떤 특정상황에서 어떤 파라미터 값이 true로 들어오면 잠깐 그 효과를 주도록 색상값을 바꾸는 등의 작업을 할때가있다.
    난근데 딱 하나의 오브젝트만 재질의 성질을 잠깐 바꾸고 싶은데 이 재질을 참고하는 모든 오브젝트가 영향을 받아 재질이 바뀌게 된다.

 - 재질이 같다는 것은 그것을 공유하는 오브젝트들은 월드 위치값만 다르고 나머지 세팅값은 동일하다는 뜻이다. 
   그렇다면 상수버퍼로 매번 오브젝트 개수만큼 파이프라인에 상수버퍼로 똑같은 재질을 전달하지 말고 월드값만 전달하고 재질은 한번 세팅하면 그 재질을 공유하는 오브젝트는 한꺼번에 렌더링 하는 구조를 만들고싶다.
   이런 구조를 인스턴싱이라고한다.

 - 이런 인스턴싱 구조 또는 그와 비슷한 구조를 쓸때, 앞서 말했던 딜레마가 신경쓰인다. 딱 하나의 오브젝트만 잠깐 빨간색으로 바꾸고싶은데 재질을 공유하는 모든 오브젝트들이 영향을 받게 된다.
   이래서 재질을 바꿀때 원본재질을 바로 바꾸지 말고 재질의 복사본을 바꿔야한다. 즉 GetMaterial() 이아니라 GetDynamicMaterial()함수를 써야한다.
   이게 뭔 의미냐면 원본재질에 바로 접근해서 재질을 변경하지말고 동적재질을 바꿔서 재질변경의 효과를 노려야한다는 뜻이다.

   이를 위해서 원래 RenderComponent에는 맴버로 메쉬와 재질을 각각 하나씩 갖고있었는데 이제 재질은 1개가 아니라 3개의 재질을 갖는다.
   m_ShareMtrl, m_DynamicMtrl, m_CurMtrl. 기존 m_Mtrl은 m_CurMtrl이 됬다.
 
 * Entity는 거의 최상단 클래스인데 본인의 복제버전을 주는 Clone()함수를 가상함수로 정의 나중에 추상함수로 정의한다고 함 지금은 이걸 상속하는 애들이 너무 많아서 다 구현하기에 시간이 없다.
  
 - 동적재질이 있으면 스크립트에 그걸 재질로 줄거고, 그게 null이면 m_SharedMtrl(공유재질)을 검사해서 공유재질이 있었다면 그걸 동적재질로 Clone() 해서 그 복사한 동적재질을 세팅한다.
   이렇게 저장해논 동적재질은 에셋매니저에 등록이 안되어있는 재질로, 렌더컴포넌트가 독자적으로 가진 재질이다. 따라서 에셋매니저의 관리를 벗어난 존재이므로 렌더컴포넌트가 따로 관리해줘야한다.

 - SetMaterial()의 동작도 조금 바뀐다. 인자로준 재질 _Mtrl은 m_CurMtrl, m_SharedMtrl에 각각 대입하고, m_DynamicMtrl은 null로 세팅한다.
  동적재질을 null로 세팅하는 단계를 빠트리면 재질 set을 하고 나서 분명 새로운 재질로 set했는데 동적재질에는 그 새로운 재질 set하기 전의 재질이 남아있어서 재질이 변경 안된거처럼 동작한다.
     

 - 이제 오브젝트의 Script 에서 BeginOverlap() 에서 재질 얻어올때 동적재질로 불러온다. 원본재질로 불어오지 말고!! 아마 2D 포폴에는 원본재질 불러올 일이 없을것이다.
   모든 오브젝트들이 자신만의 복사본 재질을 갖고, begin()에서 그걸로 세팅된다.

 - 유니티에서는 동적재질set하는 함수 이름이 setMaterial()로 되어있다. 그래서 진짜 찐 원본 재질을 바꾸고 싶다면 setSharedMtrl()로 호출해야한다. 이거 모르고
   그냥 getMaterial()하면 분명 난 원본 재질 바꾼줄 알았는데 매 tick()마다 복사본 재질을 바꿔서 엄청난 프레임저하를 초래하는 경우가 있었다 + 재질을 공유하는 놈들도 같이 안변했음
   유니티는 네이밍이 거지같아서 초보자들이 이러한 재질 시스템을 이해하기 너무 어려웠다고 한다. 엔진마다 이런 함정들이 있기때문에 문서를 꼼꼼하게 살펴봐야한다.






