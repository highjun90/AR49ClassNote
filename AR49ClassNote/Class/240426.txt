버전 관리 꼬여서 1교시 수업 날림... 
버전 갈라져서 기록한거 복붙하는데 사라져있음.. 그냥 수업끝나고 바로 커밋하고 푸시하면 되는데 30초 일찍 일어난다고 이사단이남.. 반드시 수업 끝나고 푸시하고 갈것

지금 1교시분은 기억을 더듬어서 수업한거 적는거임

 [1] 빛 감쇠율 계산식 변경
     원래 1 - D/R 수식으로 감쇠율이 결정 됬는데 이렇게 선형적으로 빛이 급격하게 감소하는건 부자연 스러워서 광원의 맨 끝에가서야 어두워 졌으면 좋겠다
     -> 이거랑 비슷한 함수가 코사인 함수잖아? 그럼 감쇠율도 코사인 함수적으로 나오게 수식을 바꾸자!

     fDistanceRatio = saturate(1.f - (fDistance / Light.fRadius));             에서
     fDistanceRatio = saturate(cos(fDistance / Light.fRadius * (PI / 2.f)));   로 바꿈

     0~1 사이 값을 0~90도로 치환해서 코사인 함수에 넣어 준거임. 원래 0~1 사이의 값에 PI/2 곱해주면 됨
     ( 1 : 90도(PI/2) = D/R : X ) 
     => X = D/R * PI/2 

  [2] 그리고 디버깅렌더러에서 디버그용 스피어, 큐브 만드는 작업 함.

   CRenderMgr.cpp에서 RectMesh 그려주는 코드 복붙해서 CUBE 그려주는 함수도 살짝만 고쳐서 만듬
   스피어도 비슷.

   CLight3D에 finaltick()에 디버그용 그림 그리는 코드 있음

   디버그용 큐브메쉬를 만드는데 얜 토폴로지가 삼각형이 아니라 선임.
   기존 큐브메쉬 정의할때 쓴 정점 정보에 그냥 인덱스만 다르게 해서 메쉬를 만듬

   윗면이 
   0   1

   3   2

   아래가 지금 생각안남 분석해야함

   여튼 그렇게 윗면 넣고 아랫면 넣고
   나머지 4개 기둥 선분 푸시백해서 사선이 없는 큐브메쉬 완성.


191
======================================================================================================


 - debug.fx에서 g_int_0 이 있으면 현재 그리는 디버그메쉬가 스피어다 라는 뜻.
  - g_int_0 (스피어메쉬일떄만) 하는 작업입니다.
  - 정점쉐이더에서 미리 뷰스페이스 노말벡터를 계산해서 픽셀쉐이더에 전달해줄겁니다.
    그리고 스피어와 카메라 사이의 시선벡터도 구해서 전달합니다.

  - 픽쉘쉐이더에서 시선벡터와 각 픽셀의 뷰스페이스 노말벡터를 내적하면, 값이 1이 나올수록 각도가 거의 일치했다는거죠?
    1에서 이 값을 뺀 값을 알파값으로 써서 테두리에 있는 픽셀들은 잘보이고, 안쪽으로 들어간 픽셀들은 투명하게 보이게 합니다.

    그런데 문제가 있음 뒷면들은 무조건 각도가 90도 이상이여서 결과가음수값이되고 , saturate하면 0이나오고, 그럼 투명값이 1 -  0 이되서 1이되기 때문에 엄청 찐하게 보여요
    따라서 90도 이상인 픽셀들은 안그리게 해야합니다. 내적의 결과가 음수가 나오면 양수로 바꿔버리게 abs()함수를 써버리는걸로 처리합니다.

    ppw(복잡한식, 0.1); 의 의미는 10번 제곱해야 원래 값이 나오는 값을 찾는 겁니다.
    이거 안해주면 원이 쫌더 찐하게 나와요(안쪽이 덜 투명함)

    vOutColor.a = 1.f - pow(saturate(abs(dot(-vEye, _in.vViewNormal))), 0.1f); 

    완전 복잡해 보이는데 차근차근 뜯어보면 다 이유가 있어요.
    천천히 다시 분석해봅시다

    1) 1에서 빼는이유.
     - 내적 결과가 -시선벡터 와 일치하는 픽셀일수록 1이 나오는데, 나는 중앙은 투명하게 하고 모서리는 선명하게 하고 싶어서 내적의 결과에 1을 뺸다. 반대라면 1에서 빼주는게 아니라 그대로 써야함.
    2) abs()
     - 뒷면 픽셀들은 180도에 가까울수록 중앙이기 때문에,
    3) pow(결과값, 0.1)
     - 1보다 작은 값들은 1이상 제곱을 할수록 작아지고, 1이하 제곱을 할수록 커진다.
     - 1보다 큰 값들은 1이상 제곱하면 커지고, 1이하 제곱을 할수록 작아진다.
     - 우리는 전자인 경우다. 내적의 결과가 0~1사이의 값이기 때문임.
       따라서 여기에 0.1을 제곱한다는 의미는 원래값보다 더 큰 값을 구하고 싶다는 말이다.
       이 작업을 하는 이유는 원래는 중앙으로부터 테두리로 갈수록 서서히 찐해지는데, 우리가 원하는건 좀더 중앙이 더 텅 비어있는걸 원하기 때문에 결과값이 좀더 1에 가까운 경우가 더 많아야해요.
       (코사인 함수모양 처럼)


 - 수업때는 따로 충돌 수업 안한다. 3차원으로 체크하면서 OBB 충돌은 총 15번 체크 해야해요 인터넷으로 검색하세요. OBB는 비용이 매우커요.
   대부분 그냥 두 스피어 사이의 거리와 반지름 더한값 비교해서 충돌 비교합니다. 아니면 OBB방식으로 하려면 15번 충돌검사하는데 이건 거의 불가능합니다 고사양게임일수록.

   정교한 충돌게임은 온라인게임말고 그냥 클라이언트게임같은데서나 하고 서버게임은 거의 못합니다. 
   obb 충돌쓰는 3D게임은 철권같은 게임. 어차피 플레이어가 2개밖에 없잖아요 그래서 가능한겁니다. 

   3D충돌은 여러분이 알아서 하세요.

 - 스카이박스란 큰 어떤 메쉬안에 우리 월드를 집어넣는 포장지 같은겁니다. 이렇게 스카이박스에 텍스쳐를 집어넣고 그안에서 원하는 작업을 하는거에요

 - 그 다음엔 렌더타켓을 여러개 쓸거에요 지금은 단일 렌더타켓을 쓰는데 여러장 쓸거에요. 디퍼드(지연)렌더링을 하려고요.
   그리는 시점을 처음에 그리는게 아니라 나중에 일괄적으로 그려요
   나중에 그래서 구조가 다 바꿔야되요.
   멀티 렌더타켓->디퍼드 렌더링->디퍼드 라이팅 이렇게 순서대로 구현되야되요. 전단계가 구현 안되있으면 다음 단계 구현이안됨
 
 - FBX 맨날 엔진에서 만든 메쉬를 쓰는게 아니라 FBX로딩으로 외부꺼 사용할거에요
   또 움직이는 FBX는 어떻게 처리해야되는지.

 - 그다음 지형시스템.
 x`x
 - 과제 - 스포트라이트 설치해서 광원처리 해보삼

   
        
       




192