 -	FSM 컴포넌트 만들기
  - 수업시간에 컴포넌트 만드는건처음.
  - 상태값을 여러개 만들어서 전환시키는 구조
  - 컴포넌트가 추가 되었으니 enum값을 추가

 - CStateMachine 클래스
  - CFSM 포인터를 맴버로 가진다. 
   - FSM은 에셋이다. 기본적으로 동일한 행동패턴을 가진 몬스터가 많을 것이므로 몬스터마다 FSM을 따로만드는게 아니라 에셋으로 설정해서 최대한 하나를 공유해서 쓰도록 하는것
     보스는 보스만의 FSM을 가지면됨
  - 이 클래스는 CFSM을 관리해주는 컴포넌트고 실질적인 상태동작은 CFSM클래스가함.

 - CFSM 클래스
  - 기본적으로 엔진에셋이 아니므로 관련 생성자 인자는 false. 만약 false로 해놓고 파일상에 저장된 FSM 에셋이 없다면 엔진에셋으로 만든 FSM은 삭제될것임
    엔진에셋으로 구현한 FSM을 사용해야겠다면 엔진에셋설정을 true로 해놓을것

 - CState 클래스
  - 모든 State의 공통부모이고, 캐릭터가 사용할 실제 state는 클라이언트가 이 클래스를 상속한 클래스로 구현해야함 run, jump등
  

 && 큰틀 
  - 게임오브젝트 중에 stateMachine 이라는 컴포넌트가 있다.
   - 이 StateMachine에서 원하는 FSM(인공지능)을 선택한다.
    - 내가 선택한 FSM은 또 여러가지 State를 가지고있다.
     - 각 States는 또 고유의 finalTick()을 가지고있다.
  - blackboard(말그대로칠판)이라는 개념을 구현해서 사용할거다.
   - FSM을 사용하는 오브젝트의 스테이터스정보를 갖고있다. 이걸 적어놓는 이유가 일일히 오브젝트에 필요한 정보가 어딨는지 알아내고 또 그거 접근하는거 자체도 힘들어서
     FSM을 사용하는 오브젝트가 상태변화 조건에 필요할것 같은 데이터를 미리 블랙보드에 적어놔서 FSM이 그걸 참고한다.

   - 블랙보드는 그럼 누가 들고있나?
    - FSM이 아니라 스테이트머신이 들고있음.
      왜냐면 FSM은 에셋이기 때문에 그걸 참고하는 오브젝트들의 수치(예를들면이동속도)가 미묘하게 다를 경우에
      FSM이 블랙보드를 들고있게 되면 그것을 에셋으로 참고하는 모든 몬스터 오브젝트들이 똑같은 상태로 취급되버림.
    - 반면에 FSM이 또 따로 들고있는 블랙보드도 있다.
     - 예를들면 경비 몬스터가 있다고 칠때, 어느한 경비몬스터가 플레이어를 감지하면 모든 경비몬스터가 추적상태로 전환되야함
       이건 스테이츠머신이 블랙보드를 들고있으면 최초 감지한 몬스터만 추적상태가 될것임
       따라서 이 경우는 FSM이 들고있는 블랙보드를 참고해서 상태전환이 이뤄져야함
    - 결론> FSM, StateMachine 둘다 들고있고 FSM은 상태전환 필요한 조건을 때로는 본인이 들고있는 블랙보드를 참조하거나,
            어떨땐 StateMachine이 들고있는 블랙보드를 참고한다.
            다르게 말하면 각 블랙보드를 사용하는 의도는 명확하다고 볼수있음
            StateMachine의 블랙보드 == FSM을 공유하는 다른 오브젝트가 영향을 받지 않아야할때
            FSM의 블랙보드          == 이 FSM을 공유하는 모든 오브젝트가 영향을 받아야할때


 - 클라이언트 쪽에 예시가 되는 state 구현해보기
  - CCreateTempleLevel.cpp의 init()에 임시 FSM객체 만들어보기

 - UI쪽에 FSMUI 만들기
  - FSMUI 클래스 생성
  - 인스펙터에 FSM의 블랙보드가 들고있는 정보를 띄우면된다

  =======================================================================

 - 임시로 몬스터 객체, 몬스터 스크립트 생성
 - SetFSM()함수 구현중에 -> '지금은 블랙보드 구현을 안했는데 나중에 FSM 바꿀때 기존에 들고있던 랙보드 clear 해야하는 작업이 필요해서 lnline으로 안하고 c++에 직접 구현했습니다.'
 - CState클래스
  - state들은 Entet()와 Exit()을 꼭 구현해야합니다.
  - 한 FSM이 여러 state를 갖고있기떄문에 Ptr클래스를 사용불가. state는 본인을 소유한 FSM정보를 알고있는 맴버에 일반포인터사용.
    FSM도 본인이 소유하고있는 State 정보를 들고있어야하기 때문에 서로 Ptr클래스로 참조시 순환참조의 늪에 빠지게 되서 
    절대 레퍼런스 카운트가 사라지지않다고함
    
 - CFSM 클래스
  - 본인을 소유하고있는 stateMachine을 파이널tick의 인자로 넣어줘서 FSM이 범용적으로 대응할수있게 해준다.
    (본인을참조하는 스테이트머신이 여러개일수있으므로)

 - 에셋매니저에 FSM 추가하는 법
  1) CFSM 객체 생성
  2) AddState()로 state들을 추가
  3) addAsset()으로 FSM을 에셋에추가

 - Module 필터에 블랙보드 클래스 만들기
 
 - enum class로 블랙보드가 사용할 데이터정의
  - 이넘클래스이름은 BB_DATA
  - 인트부터 벡터, 오브젝트까지

 - 구조체로 블랙보드가 저장할 데이터 묶기
  - BB_DATA, 보이드포인터 (데이터주소기록)

 - CBlackboard 클래스
  - 맴버로 맵을 가짐. key는 문자열, second는 앞서 정의한 구조체 
  - 블랙보드는 Clone 될수있어서 복사생성자 활성화

&& 블랙보드는 복사생성자가 있지만 맴버 m_mapBBdata map은 복제가 안되게 할겁니다
   이유>  블랙보드 세팅하는 부분은 begin()함수에서 한다고함. 전체 다 구현하고 더 자세히 설명해주신다하심

 - AddBlackbordData()함수, CBlackboard.cpp

 - StateMachine에서도 Blackboard를 맴버로 추가.
 - CStateMachine클래스
  - AddBlackboardData()함수
   - 인자로 블랙보드키(문자열), 블랙보드의데이터타입, 데이터의주소를 인자로 필요
   - 나중에 StateMachine은 분기처리로 FSM의 블랙보드에 저장할지 본인의 블랙보드에 저장할지 결정

 - 예시) 몬스터의 스테이츠머신이 파이널틱을 호출받으면, FSM을거쳐 Idle state의 finaltick()도 호출되고, 
         그때 idle state는 스테이츠머신의 블랙보드에 접근해 데이터를 가져온다
         그래서 trace인지 idle 유지할지 결정

   