
 (어제 수업 못들음)
 - 어제 절두체 렌더링할때 최적화한다고 했죠
  - 월드의 8개점 구하고 6개 표면 제작을 해야되는데
    이제 평면을 구할떄 

    점세개가 ㅁ평면을 구성하는 요소니까 월드에서 점 8개 구하면 평면을 도출하면 되겠죠
     abcd 점 4개만 있으면 평면하나 구할수있다 했죠
     그 함수가 XMPlaneFromPoints()함수입니다.

    문제는 평면이 어디로 향하게 하냐 라는 겁니다 법선벡터가
    저는 모든 법선벡터가 평면 내부를 가리키게 할겁니다 통잃성을 위해서.

    XMPlaneFromPoints()가 평면을 만들때 법선벡터를 어떻게 만들어주는지 한번은 확인해 봐야합니다.
    이 함수는 인자로 점3개주면

    0  1

       2 

    우선 1에서 2뺀다고 하네요.
    1번벡터에서 2번벡터빼니까 2에서 1로향하는 벡터가 나오겠죠
    1에서 3을 빼면 3에서 1을 향하는 벡터 나오겠죠

    다음 크로스를 2-1, 3-1 하니까 시계방향으로 감싸쥐니까 결과는 정점1의 위쪽이 되겠네요.
    즉 법선벡터가 평면의 위로 나온다는 말입니다.

 - 완성된 평면을 저장할 6개면 벡터,  그게  Vec4  m_arrFace[(UINT)FACE::END];  입니다.
   (Vec4 로 평면을 표현할 수있다고 하는데 지난시간 수업못들음 ㅠㅠ)

 - 아니다 그냥 법선벡터가 각 평면에서 나가게 할게요 <- 이유 좔라좔라 설명했는데 이해못함;

 - 우선 NEAR 평면 잡을게요
   그리고 FAR 잡는데 456으로 잡으면 법선이 안으로 들어오겠죠
   547로 잡아야 왼손으로 잡을때 밖으로 향하겠네요 (4에서 5로 향하는벡터, 7에서 5를 향하는 벡터를 왼손 cross.)

 - 이런식으로 만들어진 평면들의 법선벡터가 절두체 밖이 되게 점 3개씩 지정합니다.
 - 그리고 정점순서 되게 중요하다 047이냐 074냐에 따라서 왼손 cross할때 노말이 밖이냐 안이냐로 결과가 완전 달라짐
   왼쪽평면을 047 순서로 정점 잡으면 법선이 안으로가고, 074로 해야 법선이 평면밖으로 향한다.

   왜냐면 047일때는
   '4에서 7로향하는 벡터'에 '7에서 0으로 하는벡터'를 왼손으로 잡는데 이러면 왼손잡아보면 법선이 안으로 향한다.

 - CFrustun::FrustumCheck()
    평면이 6개니까 반복문으로 6번해야함.
   입력으로 들어온 월드포즈랑 xyz 내적한게 Face의 W(d값) 보다 작아야한다.
   즉 반대로 내적한 결과가 d값보다 커버리면 false다.

   이걸 이용해서 오브젝트들 카메라 시야에 담겼을때 잘 나오는지 한번봅시다.
 
 - CCamera.cpp 
   오브젝트에 Transform에 월드포즈를 검사요인으로 하고, 그걸로 카메라 본인의 FrustumCheck()가 실패했다. 그러면 카메라에서 이 오브젝트는 분류할 필요도 없는거죠. 절두체 시야에 없는거니까. 그래서 continue 해버립니다.
   스카이박스 같은 애들은 이 검사에서 예외해야합니다 얘는 카메라 절두체 영역에 없어도 무조건 보여야 되죠 나중에 그 기능을 추가해야겠네요 오브젝트가 절두체 영역 검사를 받을지 않받을지.

   
 - 원래 ax + by + cz + d = 0 이여야 되는데 d가 마이너스처럼 여겨짐??
   아니면 처음부터 N dot P + D > 0 이다 이렇게 애도 될거 같아요
   내적결과 (n Dot p) 어쩌구.. 미치겠따
 
 - 자 스카이박스는 안보이고 땅은 잘 보이죠. 카메라 옳기면 땅도 사라집니다. 카메라 절두체 벗어나면.

 그래서 프러스텀체크할때 완전 중심으로 해버리면 완전 뚝 사라지죠 우리가 시야박스를 너무 정교하게 체크하고 있기 때문이죠. 하지만 우리가 물체를 볼때 모서리같은 부분은 예외처리를 해줘야 해요
 카메라가 물체 중심 안찍고 있다고 안그려버리면 너무 이상하잖아요.

 바운딩박스를 어떤물체 감쌀만큼의 크기를 주는거죠.
 그래서 카메라 절두체가

 물체마다 제일큰 동작 기준으로 바운딩박스를 넣어주는 겁니다. 이건 여러분들이 해야해요. 박스의 중심위치와 박스 반지름을 가져와서 그게 절두체안에있으면 그린다.

 그래서 Fustumcheck()함수를 하나더 만들겁니다.
 하나는 물체 중심만 검사하는놈, 하나는 물체에 바운딩박스가 있어서 물체 중심을 카메라가 안찍더라도 일정영역까지는 벗어나도 찍어주는걸로 판정하는놈.

 - 본인의 좌표랑 노말이랑 내적하면 노말쪽으로 투영하게 되는거잖아요. 
   이게 abcd값보다 작으면 평면의 방적식에 집어 넣었을때 9보다 작게 나오겠죠.
   ax + by + cz = d 일때가 딱 평면 경계랑 맞아 떨어지는거고
   우리는 ax + by + cz - d 가 0보다 작으면 평면 안쪽에 있는거고
                              0보다 크면   평면 밖에 있는 걸로 했죠.

 - 여기에 한술더떠서 반지름까지 따져야해요
   중심은 분명 디스턴스 값보다 멀어서 양의 값이 나올텐데 바운딩박스가 있는놈들은 본인의 반지름만큼 더 벗어나야 되요


 - 절두체는 요정도로 마무리 하겠습니다.
   아예 바운딩박스 컴포넌트가 없다 그냥 위치값으로 하겠다 그래도 되요. 바운딩박스는 여러분이 컴포넌트 만들어서 구현하세요.
   트랜스포컴포넌트에 bool값으로 m_FrustrumCheck가 참인놈들만 절두체 검사하게 구조를 만들수도있겠죠. 이건 여러분들에게 구현넘길게요 여러분이 짜세요

---------------------------------------------

 - 이제 테셀레이션을 이용한 지형을 구현해봅시다.
   렌더컴포넌트가서 랜드스케이프 컴포넌트 추가할게요
 
 - CLandScape() 클래스
  - 지형에대한 렌더링기능이 있기때문에 렌더컴포넌트 상속을 받습니다.
  - 초기화함수 만들게요 지형은 지형설정할때 이 면설정을 할거거든요 face x, y. 
    기본메쉬를 엔진에서 제공하는거 쓰지말고 그때그때 만들거거든요?
    2 by 2 라고 했을때 사각형 4개(삼각형8개)로 구현될겁니다.
    여기에다 테셀레이션이 들어갈거에요.

    기본 판자체가 커야되요. 
    어느정도 기본 면이 촘촘하게 배치 되어야 그래도 64 by 64 정도로 되야
    거리에따라 극단적으로 분할하고 안하고 이러지 않겠죠. 
    
    그냥 지형메쉬가 사각형 하나 띡 해놓았다고 생각해보세요. 즉 삼각형이 두개인거죠.
    지형 크기 자체가 정말 클텐데, 삼각형 두개 갖고 테셀레이션 할지 않할지 하는게 별로 의미가 없습니다. 게다가 어색해보이기도 할거구요.
    삼각형이 그래도 많아야 거리에 따라서 테셀레이션으로 복잡하게 그릴지 안그릴지가 의미가 있겠죠. 
    
    지형메쉬를 이루는 사각형이 적을수록 플레이어가 어떤 섬에 가까이 갈때 디테일이 휙휙 바뀌는걸 더 잘 느낄거에요.
    사각형이 많을 수록 더 부드럽게 지형이 디테일하게 바뀌겠죠
    
  - 초기화 작업에서 해야할게 많아요 컴퓨트 쉐이더도 써야되고.
    초기화 함수는 생성자에서 한번 호출할게요.

  - 기본적인 렌드스케이프 쉐이더는 있어야겠죠.

 - landscape.fx
  - 세이더 형식, 세이더 모드 설정하고
    저희가 기본 예시로 만들어 놓은 테셀레이션 쉐이더파일인 tess.fx 를 튜닝해서 만들어 나갈겁니다. 코드 그대로 복붙해옵니다.
    함수이름을 다 바꿔줍시다.
  
  - 얘는 디퍼드 렌더링때 쓰일겁니다.
    주석으로 관련 정보들 다 적어줍시다.
    지형안으로 파고들어서 볼일은 없으니까 컬백으로하고
    뎊스스텐실은 less, 블랜드는 디폴트 둘다 별로 할게 없습니다.

 - 에셋매니저에서 이제 지형 전용쉐이더, 재질 미리 만들어줍니다.
   



 - 정리
  1) 카메라가 찍는 영역을 절두체로 했을때, 오브젝트가 어떻게 이 절두체 안으로 들어온 놈인지 판정하는가?
    - 오브젝트의 월드 Pos와, 카메라의 절두체를 구성하는 평면의 법선벡터를 내적하는 것이다.
      이말은 다시말해서, 오브젝트의 월드Pos를 평면의 법선벡터에 투영하는 것이다.
      평면의 법선벡터를 1이라고 가정했을때, 내적의 결과가 1보다 작으면 이는 곧 투영된 오브젝트 Pos가 1 보다 작은 벡터라는 말과 동일하다. (좌표가 곧 벡터라는 사실)
      즉 이것은 투영된 좌표가 평면 안쪽에 있다는 말. 절두체는 6개의 면으로 이루어져있으니 이 검사를 총 6번해서 다 평면 안쪽에 있다면 이 오브젝트는 카메라 절두체 안에 있다는 말이고,
      이 물체는 렌더링 될수있다는 말이다.


(push안함)
=====================================================================================================================================

 - CLandScape::Init()
  - CreateMesh()로 지형의 면 개수와 재질을 지정.

 - 지형의 Face 설정을 할때,  X Y 값들을 원점 기준으로 증가 할게요 즉 로컬스페이스 사각형의 좌하단을 0,0 으로 한다고요
   NDC 좌표처럼 - 쪽으로 가지 않고요. 
   이걸 약속으로 지형메쉬 만듭니다.

 - CLandScape::CreateMesh()
  - 지형메쉬를 이루는 정점의 위치를 정의하고 전용재질도 만든다.
  - 메쉬 만들때 Z, X축에 정정을 위치시킵니다.
    이때 우리는 몸 밖으로 가는 방향이 z 플러스인데 UV는 몸 안쪽으로 오는 방향이 z 플러스일겁니다. z축방향이 메쉬 정의할때 방향과 UV 방향과 반대라구요.

 - 인덱스 지정
   한번반복문돌떄마가 사각형 인덱스 하나 잡아줘야되거든요?

   0        1    2
      
   2   1         0

   사각형 하나의 정점들이 요렇게 인덱스로 묶일겁니다. 패치2개죠.

   이런 사각형들이 Face 면 개수에 따라서 쭉 메쉬로 만들어 져야합니다.

   예시로 지형메쉬 face가  2 by 2인 메쉬라고 하면 정점이
   
   (z축)
   ^
   |
   |

   7  8  9

   4  5  6   

   1  2  3    --> (x축)

   요렇게 9개 인덱스로 이뤄져 있을거에요. 이걸 3개씩 묶어서 패치 8개로 즉 사각형 4개로 묶으면 지형재질 정의된겁니다
   
   예시에서는 우선 제일 처음 만들어질 사각형은
   (4 2 1), (2 4 5) 요렇게 정점이 묶이겠죠. 코드 잘 분석해보세요. 요 예시에만 적용되는게 아니고 Face 늘어나도 그거에 맟춰서 정점인덱스 묶는 코드입니다.



 - 이제 지형에 로피맵? 을 적용해볼게요 에셋좀 가져올게요
   가로가 5200짜리 픽셀이고 x값이 높이인 에셋입니다.

   랜드스케이프에 함수하나 만듭시다.
   멤버로 지형에 높이를 설정하는 텍스처구요 m_HeightMapTex;
   지형에다가 높이를 설정.

   tempLevel에 적어논 LandScape()d에 SetHeightMap()을 적어서 랜드스케이프의 높이맵을 적용한거죠. 본인의 높이값으로 쓰는 텍스처입니다.

   당연히 쉐이더에 이 텍스처를 바인딩해야 쉐이더에서 쓰겠쬬? 랜드스케이프의 render()에서 
   머터리얼이 TEX_0에 높이맵을 바인딩하는 코드 추가할게요.

 - 지형자체의 면 개수를 알아야 지형전체에서 매치되는 UV값을 매칭시킬수있다. 
   문제점이있다. 지금 쉐이더에서의 아무 조치안한 UV값은 하나의 사각형 기준의 UV값이지 전체 지형에서의 UV값이 아니다. 즉 1x1 사각형 기준이지 
   Face X x Face Z 크기에서의 사각형 UV값이 아니란 말이다.
   
   %% SampleLevel()을 써야한다고한다 Sample()은 못쓴다는데 왜 못쓰지? 이 함수는 무슨 차이가있찌?


   어떻게 전체지형에서의 UV값을 알아낼까?
   전체기준 면 개수로 나눠주면 전체 지형 크기에서의 UV값을 알아낼수있다. g_int_0과 g_int_1에 Face 정보를 전달해주자.



  && 높이텍스처를 넣어줘서 어떻게 각 정점들이 높이가 달라지는지 정확하게 분석할 필요가있다


  - 높이맵에 현재 노말이 다 위로 향하기 때문에 빛 넣어줘도 단색으로 나올거다
    높이가 적용될때 노말값을 직접 계산하는 코드를 추가해야한다.









214