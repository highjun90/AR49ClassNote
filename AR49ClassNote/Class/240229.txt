 - 윈도우에서 제공해주는 함수를 이용해서 content 폴더를 감시상태로 만들겁니다. 
   그래서 이 파일의 변경점이 생기면 그걸 감지하게할거에요

 - m_hnotify라는 맴버변수를 CImguiMgr.h에 선언합니다.

 - FindFirstChangeNotification()함수.
   얘를 쓰면 폴더감시자라는 핸들을 반환값으로 가져올수있어요. 
  - 인자
   - 1) 감시할 폴더경로
     2) 하위폴더까지 변경점을 감시할건지 여부 -> true
     3) 플래그 조합
      파일이름을 키값으로 사용하고있기 때문에 파일이름 바뀌면 알림받기 |
      디렉터리 이름생기거나 바뀌면 알림받기 |
      감시하고있는 경로에 새 파일 추가되거나 삭제될때 FILE_ACTIOON_ADD | FILE_ACTION_REMOVE |

   - FindCloseNotification()이라는 함수로 감시자 핸들을 종료시켜준다


 - observe_content()함수
  - imguiMgr에서 tick() render()이후에 실행되는 함수로, 한틱에서 파일에 무슨 변경점이 생겼는지 검사하는 함수
  - WaitForSingleObject()
   - 인자
   1) m_hNotify(감시자핸들)
   2) 밀리세컨드단위로 알림이 올때까지 기다림. 만약 인자가 0이면 peekMessage처럼 동작함. 0이상이면 GetMessage처럼 동작함
      그냥 한프레임에 한번씩 검사하고 싶으니까 우리는 0을 넣어준다.
   - DWARD를 반환하는데, WAIT_OBJECT_0 이면 뭔가 사건이 발생했다는거고 어쩌구_Fail 이면 아무사건도 안일어난거임 자세한건
     구글링해서 반환코드확인할것
  - 

&& 지금 Imgui에서 우리가 수동으로 보여주라는 에셋만 보여주는데 이제는 알아서 컨텐츠 폴더에있는 모든 에셋을 보여주게 할거다

 * 지금 이런 작업들을 하는이유
   메모리 상에서 사용중인 에셋과 실제저장장치에 저장되어있는 에셋의 싱크를 맞추고 싶은 것이다.
   예를들어 프로그램이 어떤 에셋을 사용중인데 갑자기 파일에서 어떤 에셋 삭제한다고해보자.
   사실 상관없다 이미 메모리상에 에셋이 올라와 있기 때문에.
   문제는 프로그램 다시 껐다 켰을때이다. 이때는 분명 잘 참조하고 있던 에셋이 없어서 파일경로에서 메모리로 로드해야되는데 이미 삭제되서 없음
   그래서 실제 저장장치에 있는 에셋정보와 메모리 상에 올라와있는 에셋정보를 동기화해주자는 것이다.

 - ResetContent()함수는 에셋매니저 상에있는 에셋들을 다시 imgui상으로 출력하는 것이다.
   지금 원하는 기능은 에셋매니저에는 로딩되어있는데 오히려 실제 저장장치에는 없는 경우는 에셋매니저에서(메모리상에서)제거 해야한다. 
   이런측면에서 볼때 이 함수는 저장장치에 있는 에셋에 변화가 생길때 그걸 전혀 반영하지않음 

 - ReloadContent()함수.
  1) 먼저 컨텐츠 폴더 경로부터 찾는다.
  2) FindFirstFile()
   - 두번쨰 인자는 첫번째 인자로준 파일경로를 조사해서 어떤 파일을 찾았을때 그 정보들를 기록해놓는 공간이다.
     - WIN32_FIND_DATA FIND_DATA = {};를 선언하고 두번째 인자로 넘김
 

 - Content.h에서 파일이름들을 가진 벡터하나를 맴버로 가지게하자
  - FindFileName()함수
   -FindFirstFile()로 일단 첫번째 파일찾고 그 정보를 가진 핸들을 반환받는다
    그다음 FindNextFile()의 첫번째 인자로 앞서 반환받은 핸들을 넣어줘서 다음 파일 정보를 저장한다.
    이걸 반복문구조로 구현해서 전체 파일 정보를 받아온다.
    %% 맨뒤에 역슬래시 붙어있으면 오류나서 핸들반환을 안했음 그러나 PathMgr.cpp에 적혀있는 맨뒤 역슬레시를 지울순 없음 다 터져서.
       그래서 맨 처음만 파일경로 받아와서 맨뒤의 역슬래시를 삭제하는 작업을 해줌
       -> 이건줄 알았는데 아니었네? 1교시 수업시간에  "*.*" 그냥 이거 불러온파일경로에 추가시켜주셨더니 해결.
    %% 오류 의심되는데 바로 밑에다가 계속 GetLastError()함수 사용중이심
    %% 지금 폴더감시자가 파일만 찾고 디렉터리는 감지하지 않아서 디렉터리도 감지하게 만들어야하는 상황임
       content 디렉터리 밑에 파일은없고 디렉터리만 있는데 하위디렉터리로 진입해서 파일 안찾고 그냥 딱 content폴더에 파일없음 이렇게 동작해버리는 상황.

===========================================================================

 - 컨텐츠 패스 경로 가져와서 그경로에 *.*를 붙여줘야함.
   *(Asterisk)는 어떤게 와도 상관 없다는 뜻임
   *.* 은 파일명아무거나, 확장자 아무거나 라는 뜻.

   FindFileName()함수에서 붙여줌.
 
 - FindFileName()
  - 눈에 보이진 않지만 모든 폴더에 .. (점이 두개) 라는 보이지 않는 폴더가 포함되고있다.
    얘의 존재이유는 바로위 부모폴더로 이동시키는 폴더이다. 뭔가 실제로 저장하는 애가 아님.
    실제로 한 디렉터리에 폴더전체 불러오기 해보면 ..도 포함되어있음. 
    이 .. 폴더는 제외하는 코드를 따로 적어줘야함.

 && 패스매니저에서 전체경로에서 상대경로를 추출해주는 함수를 많이쓸거같으니 만들겠다.
  - GetRelativePath()함수 
   - 첫번째인자로 full경로를 준다.
   - 상대경로는 GetContentPath()의 반환값을 빼주는게 상대경로가 될것이다.
   - wstring.find()해서 상대경로가 존재하지 않았다면 -1반환한다. 그떈 그냥 nullptr 리턴.
     그게 아니라면 제대로된 경로를 줬다는 뜻이니까 상대경로를 짜른다.

     .substr()함수를 이용함. 첫번째 인자가 시작위치, 두번째 인자가 시작위치에서 짤라낼 길이.


 && 중단점테스트하심
  - '.. 폴더넘기고 level 재귀로 들어가고 하위폴더에도 .. 폴더 있겠죠? 그거 또 넘기고 temp.lv 잘검색됬죠?' 
    최종적으로 에셋들의 상대경로들이 벡터에 다 저장되게됬다.  (m_vecAssetFileName)

  - 재귀함수이기 떄문에 폴더단위로 hFindFile 핸들이 생겼다가 사라집니다.
  

---------------------이렇게 실제 존재하는 에셋들의 파일경로를 모두 찾았습니다. 이제 그걸로 메모리에 reload 동기화 해야합니다.

 - ReloadContent()함수로 돌아와서
  - 파일확장자에 따라 로드할 에셋들이 무슨 타입의 에셋인지 구분시켜주는 함수가 필요하다.
   - GetAssetTypeByExt()함수
    - 함수 경로에서 확장자만 추출한 다음에 그걸 어떤 에셋타입으로 보겠다고 하고 그 ASSET_TYPE 을 리턴해주는 함수
     ^^ 레벨 확장자의 경우에는 레벨은 에셋으로 하지 않는 엔진이므로 따로 처리할겁니다.
     - mdat은 메쉬데이터인데 이건 3D에서 쓰는겁니다 지금은 안씀
     - 텍스처나 사운드는 확장자 종류 음청많다
     & 설명 못들었는데 쉐이더는 프로그래머 의도를 컴퓨터가 파악못한다고 쉐이더는 프로그래머가 일일히 수동으로 하니까 fx 얘네도 레벨처럼 따로 처리한다함

 - 메쉬 세이브로드를 순수가상함수여서 구현은 해놨을텐데 어차피 2D에선 따로 구현할게 없다함 그래서 부모꺼씀

 - 그동안 에셋들 키값을 경로로 안주고 이름으로 준애들 다 경로로 수정해줌
   그리고  AssetMgr의 load()를 인자가 굳이 2개일 필요가 없음 키값과 경로가 동일하니. but 인자 하나로 줄이는 작업을 할 엄두가 안나서 그냥 둔다함

 - ReloadContent() 마지막에 ResetConten()해줘서 트리에 변경사항 적용시킨다.

 ^^ 레벨을 완성하고 나서 어떤 에셋을 참고했는지 참고정보를 save하는거다. 레벨전환해서 레퍼런스 카운트가 1인애들은 에셋매니저만 참고하고있는 애이기 떄문에 삭제된다.
 ^^ 아직 컨텐츠 폴더에 삭제될때의 대응이 안된다. 삭제될 애들 찾아서 필요한 작업(assetMgr에서 메모리해제)해주는건 아직 구현안되있음
 ^^ imgui에 content변경 알람 올떄마다 연동되서 작동하는것도 구현안되있음



 

  
