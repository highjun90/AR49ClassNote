 - 어제한거 - 두종류의 오브젝트(사각형) 만들어서 벡터에 넣어놓고 반복문으로 출력

 - 오브젝트의 움직임은 컴포넌트 기능으로 제공하기엔 한계가있음 why 엔진은 미리 만들어지는 것인데 사용자가 뭘 원할지 알수없음
 - 언리얼 엔진은 모든코드가 공개되어 있지만 유니티는 아니므로 상속을 해서 컴포넌트를 구성하진 못한다.
   하지만  유니티는 script라는 걸 상속해서 내가 필요한 기능을 만들고 반대로 게임오브젝트에 넣어주는 방식이다. (언리얼처럼 탑다운 방식의 구성이 아님)
   API때는 언리얼 방식으로 했고, 2D는 스크립트 방식으로 엔진을 만들어보겠다.
    (참고 - script는 대본. 게임오브젝트가 실행해야할 대본)

 - enum class에서 END 까지가 엔진에서 제공하는 기본컴포넌트, 그뒤에 만들어진 script는 사용자정의 컴포넌트라고 할 수 있다.
 - 스크립트는 게임오브젝트에서 여타 컴포넌트 처럼 m_arrCom 배열에 저장해두지 않고 m_vecSript라는 벡터에 따로 저장한다. 

 - 따라서 AddComponent() 함수에서 처리방식이 두종류로 분리된다. 인자로 온 컴포넌트가 엔진기본제공 컴포넌트인지, 사용자정의컴포넌트(스크립트)인지.
   모든 게임오브젝트는 렌더링 관련 컴포넌트는 무조건 하나만 가지게 할것입니다. 

 - 주로 Tick() 이 스크립트쪽에서 구현되어야할 것이다. finalTick()에서는 엔진에서 제공하는 확정적인 기능으로 렌더링 파이프라인 마무리 작업을 해준다.
   즉, 스크립트쪽에서는 finalTick()에서 작동되는 경우는 없다. 아예 스크립트 클래스에 finalTick()에 final 키워드를 박어넣어서 상속해서 사용하는 일이 아예 없도록 해놨다.
   혹시나 상속해서 쓰고 어 왜 스크립트 컴포넌트는 finalTick() 동작 안하지 왜 아예 중단점 안들어오지 하는 상황을 원천차단.

 - Asset(메쉬와 쉐이더)를 관리할 에셋메니저클래스만들기. 다양한 오브젝트들이 이 에셋메니저에서 맘에드는 메쉬나 쉐이더를 요구함
  - 에셋타입 개수만큼 크기의 배열 m_mapAsset 이 멤버변수로있음

 A1. 템플릿은 헤더에 구현
 
  - init()에는 에셋메니저가 기본적으로 가져야할 에셋을 등록함
    AddAsset() 함수의 인자는 해당 에셋의 이름(key)과 에셋포인터타입 (메쉬나 쉐이더)이다.
    템플릿으로 안만들었으면 일일히 에셋유형이 메쉬일때 쉐이더일떄 다 만들었어야했다.

  - 템플릿으로 구현한 함수에서 템플릿인자의 타입은 어떻게 알수있을까
    typeid(T)함수로 알아내서 type_info& info 포인터에 저장. 
    이후 이렇게 알아낸 info의 주소값과 내가 원하는 타입의 주소값을 비교해서 타입을 알아낼수있음 (똑똑하게 딱 뭐라고 알아내는게 아닌 주소값으로 간접적으로 일일히 찾는것)

-----------------------


 - 소멸자에 virtual 붙여줘야 상속하는 애들이 delete 할때 부모 말고 본인 소멸자 호출할수있음
   이경우는 대체로 부모 포인터를 이용해서 부모를 상속한 객체를 delete할때 일어남 그래서 웬만하면 부모소멸자에 virtual 써주는게 좋음
   메모리 delete에서 여러 오류가 있겠지만 소멸자에 못들어 오는 경우에 이 케이스를 의심해보라 
 
 - CLayer는 Centity를 상속. Layer는 게임오브젝트에 대한 벡터를 멤버변수로가짐.
   CLevel은 이러한 Layer를 여러개 가질수있고, 그래서 멤버변수로 Layer에 대한 벡터를 가짐
   즉 레벨 하나에 여러개의 레이어를 갖고, 그 여러개의 레이어는 또 여러개의 오브젝트를 갖고 Tick()같은 작업 수행.

 - 레벨도 여러개가 있을 수있고 그 레벨을 관리해줄 레벨메니저 CLevelMgr를 만듬


1. 일주일동안 바뀐건 아무거도 없고 구조만 재설계한겁니다.
   이제 카메라기능 만들어봅시다.

 - 카메로 오브젝트고 그 카메라가 보고있는 모습을 윈도우화면에 띄울겁니다.
 - 원근투영과 직교투영에 따라 필요한 데이터가 다르다.
  - 원근투영은 FOV(시야각)
  - 직교투영은 Width(직교투영의 가로길이), scale(직교투영배율)
  - 둘 다는 AspectRatio(종횡비, 투영가로세로 비율), Far(투영최대거리)
  
 - 카메라를 쓰려면 변환행렬을 이해할 때가 됬다.
  - 포지션 스케일 회전에 대한 내용을 따로 저장해놓지 말고 행렬하나에 다 저장해놓자.
  - 상태행렬이 4x4 이므로, 좌표행렬은 1x3 이 아니라 1x4 행렬로 억지로 하나 늘린다. 3차원 좌표계를 쓰는중인데, 위치행렬 (x y z w)에서 실제 필요한 좌표는 xyz 이지만 w는 억지로 넣어준거고, 이 w를 동차 좌표라 한다.
    차원을 맞춰주기위한 좌표(동차)라는 뜻이다.
  
  - 월드 안에 이동정보는 행렬에서 41, 42, 43 위치 이다.

  - HLSL에서 mul()함수는  행렬곱셈해주고 float3와 인자 하나로 줘도 되는 생성자가 있음.
    
  - 사선이 크기(scale)정보가 된다 즉 행렬에서 11, 22, 33 위치.

  - 이게 월드스페이스다. 


    