* 머터리얼 마저 정리
 - SetScalarParam()함수 

 - SetTexParam()함수
   선생님 예시로 template에서 두번째 인자(typename 이 적용되는 인자)에 정수타입으로 적어주고 함수이름 바로 옆에 <int> 생략. 그래도 알아서 타입 매핑해서 template이 알아서 <typemane int>로 생성
   템플릿함수의 꺾쇠부분생략인데.. 명시하는게 좋아보임

 - UpdateData()함수에서 레지스터와 텍스처(m_arrTex[]) 바인딩할때 안쓰는 텍스처 레지스터까지 null로 매핑(이전에 작업한 texture가 GPU에 있을수 있으므로 clear)

 - HLSL에서 존재하지 않는 텍스처에서 샘플링을 시도하면 디폴트 설정인 0값으로 설정
   따라서 덱스처가 세팅되있지 않으면 검은색으로 텍스처가 뜸
   

 - 재질의 맴버가 총10개인데 이것이 null인지 검사한다면 몇만개의 픽셀마다 하는 것이므로 퍼포먼스저하
   따라서 차라리 각 멤버에 대응하는 bool값들을 전달시켜서 null인지 아닌지 상태를 저장한 데이터까지 같이 보내줌
   (bTex[]가 bool 이 아닌 int? -> HLSL 최소단위가 4바이트)
   (bTex[] 밑에 16바이트 맞춰주려고 쓰지도않는 iPadding[2] 생성 (16바이트 바이트패딩) )   

 - discard는 픽셀쉐이더를 아예터트리는 것으로, 알파블랜딩의 투명처리와는 원리가 다름
   따라서 알파블렌딩을 쓸때 투명하게 처리된 영역뒤에 다른 텍스처가 출력안되는 현상을
   HLSL의 discard를 쓰면 투명영역뒤에 있는 다른 텍스처 출력이가능 <-해봐야함 MS왈 현재픽셀의 결과를 출력하지 않음
   (알파블렌딩은 본인색에 0을 곱해서 출력안하는거지 깊이값은 남아있음. discard는 깊이스텐실이 남아있건 아니건 무조건 터트리는형식)

a1.샘플러세팅에 들어있는것 hlsl에 texture에 UV와 sam으로 color 추출하는데 추가적인것 어부

2. 에셋에 스마트포인터 적용하기
 a2. 템플릿으로 friend 걸어주면에셋에 파생된 애들은 모두 friend가 됩니다.
 a3. comptr있는데 굳이 Ptr이라는 스마트포인터용 클래스 생성해서 asset관리

 - CMesh, CMaterial 전방선언으로 처리했던걸 Ptr 템플릿 쓰느라 이제 다 include. 
   템플릿은 형태를 명확히 알아야함
   
  - 연산자 ==의 원래 형태는 '호출자.Ptr::Operator==(비교대상)' 인데 비교대상이 왼쪽에(맞나?) 있으면 제대로 동작안하므로 전역함수로 == 정의

 -? Ptr 쓰는 걸로 변경하는 과정에서 자동으로 가상함수로 호출됬던 텍스처의 load()함수가 템플릿으로 인해 불가능해짐
    그래서 friend 걸어서 해결했다함
    ??
 - 

 - 에셋 자신이 레퍼런스 카운트 가지고 0이하면 자가소멸 
 A3 레벨이 종료될때 에셋의 레퍼런스가 1인 것들은 자동으로 날라간다 <- 0이아닌 이유

  - 딴레벨에서 에셋을 이미 참조하고 있으면 갖다쓰면되고 에셋이 없었다면 불러오는건 동일

 - 스마트포인터 방식에서 누가 자기를 가리키는지 역참조해서 가리키는 방식도 있지만 레퍼런스카운트방식이 간단