 - LevelMgr의 init()에 있던 하드코딩코드들을 client 쪽으로 옳기기
 
  - 레벨이 없는 경우를 대비하게 코드구조변경하기
   - 렌더매니저의 tick()에서 레벨이 없다면 바로 return하는 코드 추가
   - CCollisionMgr은 CEngine 쪽에 있었는데 레벨매니저의 tick()안으로 들어가게 변경.

 - CLevel의 init() 내용전부 삭제
 
 - 클라이언트 쪽에 레벨 하나 만들기
  - 클래스를 네임스페이스로 쓰기만 할거고 객체는 안만드는 레벨생성하기
   - Client 프로젝트쪽에 03  CreateTempLevel.cpp 라는 임시레벨로 뭔가 테스트할떄 사용
  - CreateTempleLevel() 에서 예전 CLevel의 init()에 있던 코드들이 복붙되어 조금씩수정됨
   - 여기서 설정해논 레벨을 현재레벨로 지정하는 작업이 필요.
    - task에 CHANGE_LEVEL 추가. 
    - 레벨을 변경하는 것도 레벨매니저에서 해줘야함. ChangeLevel()이라는 함수생성
      이 함수는 인자로 받아온 현재레벨을 태스크매니저에 알려줘서 일단 하던 tick()작업은 다 끝내고 레벨 변경하게함.
    - ChageLevel_Task()는 태스크매니저로부터 레벨변경요청이온걸 레벨매니저가 수행하는 작업. 반대로 착각하지마세요
      이함수가 진짜로 레벨매니저가 레벨을 바꿔주는 함수임.


    ** 왜 이런 구조가 됬나? ChangeLevel(), ChangeLevel_Task() 굳이 두 함수 만들어서 레벨을 바꾸는 이유?
     - ChageLevel()함수는 레벨을 바꾸고싶다는 예약을 하는 함수다. 그 예약을 태스크에 저장해 놓는것. 
       만약 바로 레벨을 바꿔버리면 render()같은 애들이 채 작업 하기도 전에 레벨을 바꿔버려서
       뭔 오류가 날지 모른다. 따라서 적어도 하나의 tick()이 전부 끝나고 레벨이 바뀌어야한다. 그러기위해 task매니저를 이욯하는 것이다 적어도
       task매니저 단계에선 한 tick()이 일단 다 완료가 된 상태일때 task매니저가 일을 하니까.

       이제 task는 tick()돌던중에 레벨 바꿔주세요 한 예약(ChageLevel()) 을 실제로 레벨 바꿔도 괜찮다고 
       태스크매니저가 레벨매니저의 ChangeLevel_Task()를 호출시켜준다.


 - 레벨바꿔줄떄 아웃라이너 갱신도 시키게 m_bCreateObject를 true로 해주는 코드 추가.

 - 최초 레벨이 등록되기 전에 한 tick()돌아야 정상동작하는 코드가 많았다.
  - 충돌매니저의 LayerCheck()에 레이어이름 두개를 인자로 주는데 아직 레벨이 레벨매니저에 등록되지 않아서 오류가 난다.
    이런경우는 어쩔수없이 레이어 이름말고 레이어 인덱스를 인자로 줘야한다.
    정확히 이해한거는 아닌데 충돌매니저 입장에선 인자로 문자열 주면 어쩄든 레벨을 가져와서 문자열 비교를 해야되서 그렇다함
  - 카메라도 "UI" 문자열대신 31 인덱스로 인자를 줌

 - 프로그램 시작하면 아무것도 클릭안했는데 인스펙터에서 처음 componentUI들이 중단점에 걸리면 안되는데 지금 들어오는상황. 초기값이 활성으로 되어있기 때문.
   그래서 컴포넌트UI들에 Deactivate()하는 코드를 일일히 추가함

-------------여기까지해서 Level init()에 있던거 옳기기 완료

 - 이제 스크립트들이 엔진안에 들어있는데 이걸 클라이언트 쪽으로 분리처리해야한다.
   선생님은 Engine에서 Client로 옳기는대신 아예 스크립트 전용프로젝트를 만들어서 라이브러리참고 형식으로 돌아가게 한다함.

   그래서 전체적인 구조가 Engine의 코드를 갖다쓰는 애들이 Script, client 이고, Script의 코드를 Client가 갖다쓴다.
   즉 계층구조가
   
   Engine
   |   |
   |  script
   |   |
   client
   
 ==========================================================================================================


  # 시간많이 남아서 겸사겸사 새거배우기
   - constexpr 키워드 
    -> 컴파일타임에 수행해서 코드를 살려둘지 삭제할지 결정해줄 수 있는 키워드.
       아무때나 쓸수있는게 아니고 컴파일타임에 비교가 가능해야함.
  
    예시) 템플릿변수를 만들어보자. 변수에다가도 템플릿을 넣을 수 있다.

    객체나 함수도 템플릿객체, 함수면 뒤에 자료형까지 합쳐진게 진짜 객체, 함수이름이다
    vector<int>와 vector<float> 은 다른 자료형이다.

    constexpr 로선언된 변수는 const보다 더 엄격한 조건을 변수에 적용하는 키워드이다.
    예를들어 const Asset_Type m_Type은 런타임 도중에 딱한번 초기화되고 상수로 취급되기 때문에 나중에 변경할수없다.
    허나 constexpr은 컴파일타임 도중에 값이 확정나야한다. 런타임도중이아니라. 그래서 조건이 더 빡세다.

   템플릿변수 Mybool은 std::is_same_v()랑 동일한 역할을함.
   Mybool은 이번 수업시간만 남겨놓겠다고함

   Asset에서 에셋타입 반환해주는 gEtAssetType()에 이 구조적용


 # 스크립트 프로젝트 옳기기
  - Vㅊ++  디렉터리 외부 include 디렉터리 client랑 똑같이.
                    라이브러리 디렉터리도        똑같이
  - 구성속성 디버깅 작업디렉터리 변경
    구성속성 일반 출력디렉터리 변경
                   대상이름 변경

  - pch.h 에 디버그모드일떄 아닐떄 엔진라이브러리 참고하는거 전처기리 코드추가

  - 프로젝트 종속성설정

  - 클라이언트에 스크립트 라이브러리 전처리기추가

  - Engine 폴더에 예전 스크립트 헤더 삭제

  - 임시레벨.cpp 파일에 engine/ 이걸 script/로 변경해줘야될 부분변경

  - bat 폴더 스크립트전용꺼 만들기

  - 스크립트 프로젝트 빌드 전 이벤트 설정해주기


**
 - 이제 클라이언트는 스크립트 쓸러면 스크립트 헤더파일 include 하고 오브젝트는 AddComponent(new 헤더파일로추가한컴포넌트) 하면 됨


 - Engine 프로젝트에  global.h 에 <experimental/filesystem> include.
  - 실험기능이여서 define 걸어줘야함. _SILENCE_EXPEMENTAL_어쩌구
    이거 넣어줘야 경고표시 안뜸

  - key값을 경로로 쓰는 놈들은 wstring 대신에 path 라는 클래스 쓰면 좋다.
 
  - 이런 함수들 쓰면 편하다.
   - exists();
   - copy();




















