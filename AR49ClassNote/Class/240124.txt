 - 텍스처 로딩할때 시스템 메모리로 먼저 로딩하는데 ScratchImage라는 다이렉트엑스의 클래스로 모든 확장자에 대응할수잇게 만들엇다.
   그거랑 일대일로 texture2D에도 GPU에도 들고있는다 이 두개를 다 갖고있는게 CTexture 클래스다.
   
   텍스처를 create함수로 만들면 바로 GPU에다 만들고 끝이다. 시스템메모리에 없는 것이다 이경우에는.
   렌더타켓이나 뎁스스텐실, 컴퓨트쉐이더의 대상이 되는 텍스처는 원본이미지가 수정되는 경우이다.
   (보통은 원본이미지 (텍스처)가 수정 되면안됨)
   그런데 웜즈같은 게임은 폭탄 파괴된 땅은 오히려 GPU쪽에서 이미지를 시스템 메모리쪽으로 가져와야 내가 그 영역의 색깔을 조사할수있다.
   이걸 도와주는 함수가 captureTexture()라는 다이렉트엑스 함수다.
   스크래치 함수가 없는경우에는 시스템메모리와 GPU메모리상의 텍스처가 일대일 매칭이 안되는 경우이므로 이떄 
   capturetexture()함수를 쓴다는게 그런의도다.
   
   GEtPixcels() 함수안에있다
    내가 스크래치이미지로 들고있지 않는 텍스처는 capturetexture()함수로 gpu에서 텍스처 가져오고 그거의 주소를 가져오는 getpixel()함수 쓰면된다. 이걸로 이제 픽셀 위치에 직접 접근해서
    색깔을바꾸던지 하면된다.

 - 이제 파티클 10개를 관리해보는 시스템 만들어보자. 그럼 파티클안에서도 맴버가 있을테고, 쓰레드 하나가 파티클 하나씩 담당해서 처리하게 한다.
   쓰레드가 처리할 행동을 컴퓨트 쉐이더로 정의해준다. 이러려면 읽기 쓰기가 가능한 버퍼가 있어야되고 구조화버퍼를 써야되고, 언오더디드엑세스 레지스터로 바인딩한다.

   : SV_DispatchThreadID라는 시멘틱을 쓰면 본인이 속한 그룹조합에서 이 쓰레드가 배정된 id를 가져올수있다고 했음
   이외에도 SV_GroupID 같은것도 있음

   사용예시는 쉐이더함수의 인자로 쓰임 -> void CS_Setcolor (uint3 id : SV_DispatchThreadID, uint3 groupid SV_GroupID)
   
   SV_GroupID                    -> 본인쓰레드가 속한 그룹의 ID (쓰레드 ID가 아님!)
   SV_GroupThreadID              -> 쓰레드가 속한 한 그룹내에서의 쓰레드의 ID
   SV_GroupIndex                 -> 한 그룹에서 2차원, 3차원의 쓰레드 ID를 1차원으로 표현.
   SV_DispatchThreadID           -> 전체 그룹까지 포함한 쓰레드 ID
   요 4개중 3개가 쓰레드 id 이고 맨위만 그룹의 id에 대한거임

----------------------------------
 - 파티클시스템으로 이야기 돌아오자.

 - 구조화버퍼도 이제 생성될때 쉐이더 리로스뷰만 가질게 아니라 언오더드엑세스 뷰도 가질수있습니다 그래서 m_UAV 멤버 추가.
   CStructuredBuffer 도 SB_Type이 READ_Write 인경우가 생기는 거다. 이경우는 u슬롯에 바인딩 될수있게 플래그에서 언오더드엑세스 값을 추가. + 뷰생성

 - struct.h에 파티클구조체 만들기. 파티클 구조체는 뭘 가져야할까? 
  - 우선 16바이트 정렬이 되어야 GPU에 바인딩할수있음 그걸 고려하면서 멤버만들자
  - vWorldPos, vScale 등-> 월드에서 위치 및 크기 및 회전
  - vVelocity           -> 파티클의 속력
  - mass                -> 질량. 화염방사기 효과 같은경우 중력영향을 받아야함
  - Active              -> 활성화 여부. 화면에 파티클이 보이게 할건지 아닌지
  - Age                 -> 생긴 순간부터 현재까지 존재한 시간.
  - Life                -> 파티클이 사라져야할 시간. Age가 이 값을 넘기는 순간 수명을 다해서 사라져야함
  - 이렇게 용량 크니까 앞에서 말한대로 구조화버퍼로 들어가야함.

 - CParticleSystem
  - m_ParticleBuffer     -> 구조화버퍼. 
                            참고) 구조화버퍼의 장점인데 구조화버퍼는 시스템메모리고 가져올 필요가 없음 그러나 지금은 우리가 그 결과를 보고싶으므로 시스템메모리 쪽으로 가져오게
                                  Creat()함수 마지막 인자에 true 적어줌 나중엔 false로 바꿔줘야해요 true가 의미가 없음
  - 원래라면 finalTick()안에서 CPU 상에서 뭘할지 코드를 짰을텐데 이젠 파티클 전용 컴퓨트 쉐이더와 렌더링 쉐이더 두개가 필요
    그리고 일단 눈에 보이는게 중요하기 때문에 파티클 5개짜리 초기값 넣어줘서 구현해보자
  
=============================================================================================

 - 파티클 시스템 생성자에서 파티클들의 초기값을 넣어주고 그 결과를 한번 봅시다. (엔진>컴포넌트>렌더컴포넌트필터>파티클시스템cpp)나중에는 삭제할것.
 - 파티클은 깊이 테스트는 진행하지만 본인의 깊이는 기록하지 않는다 -> 이게 정확한 의미가 뭔지?
   일단 설명상으로는 사각형 메쉬를 써서 눈송이 같은 파티클을 쓰면 투명한 모서리 부분이 다른 그림을 가리는 상황이 나오므로 본인의 깊이를 기록하지 않되,
   다른 물체가 가리면 안보여야하므로 깊이 테스트는 진행한다고 설명함

 - 왜 트랜스폼 업데이트가 의미가없지 파티클 시스템은?
   -> 설명상으론 게임오브젝트의 월드좌표지 파티클 컴포넌트는 의미가 없다함

 - struct.fx에 구조화 버퍼가 쓸 타입 tParticle 구조체 정의. cpp파일에 정의한 파티클구조체랑 똑같이.
   이걸 particle.fx에서 구조화버퍼의 <>꺾쇠안에 그대로 적어줌 g_ParticleBuffer

 - 전처리기로 particle을 상수버퍼 g_ParticleBuffer의 g_int_0 데이터에 접근하는 거라고 정의해줌 매번쓰기 귀찮으니
 - 포지션 정할떄 수식이 복잡한데 우선 오브젝트의 좌표를 끌고와서 본인의 월드좌표를 더해주는 거라함
   레벨매니저에서 파티클 오브젝트 코드 적으며 '오브젝트 위치는 의미가 없으니까. 파티클 위치에 그릴거니꺼'

 - (결과나오고) 지금 for문으로 5개 파티클 만든거 비효율적임 천개면 어쩔건데. 내일은 반복문이 아닌 인스턴싱버전으로 바꿀거임
 


      

   