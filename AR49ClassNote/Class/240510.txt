 
 - 오늘은 그림자 구현해볼거에요

 - 어제 광원시점에서 물체들을 한번찍어야지 물체의 그림자들을 판정할수 있다고 했어요.
   디렉셔널라이트는 구현이 그래도 할만한데 포인트 라이트는 진짜 힘들어요.
   왜냐?
   광원의 중심위치에서 총 6방향 6면체 시점으로 사진을 미리찍고, 한 픽셀의 그림자계산을 하려고 하면 그 미리찍은 6개의 시점에 대해 총 6번 검사를 해야해요.
   하지만 이걸 한번에 그리는 방법이 이론상으로는 있어요
   지오메트릭쉐이더를 활용하면 하나의 시점에서 여러방향의 렌더링을 뽑을 수 있어서 포인트라이트를 구현할수 잇다고는 하는데 저도 구현해본적 없어서 수업시간에는
   포인트라이트 그림자는 따로 구현하지 않을겁니다. 궁금한 친구들은 제가 자료는 있어서 참고해줄수 있긴합니다.
   포인트라이트를 6번 렌더링하는 방식으로 구현 시도한 친구 있었는데 프레임이 개 박살이 났어요. 결국 포인트라이트 그림자 구현은 한번에 렌더링할수있는 방법으로 구현해야 할겁니다.

 - SHADOW_DEPTH MRT 타입 미리 정의해놨네? 잘됬네요
  - 얘는 텍스처 1장으로 구성되어있고, 다른 곳에서 텍스처 Find하는게 아니고 직접 텍스처 만들어야되요
  - 얘는 해상도가 높으면 높을수록 좋아요. 우리가 실제로 보이는 해상도랑 일치할 필요가 없는애고 해상도가 높으면 높을수록 좋아요 해상도 높을수록 정확도가 올라가는거라.
    제가 알기론 텍스처 최대 해상도가 8192로 알고있어요 워낙 오래되서 지금은 커졌을 수도 있는데 일단은 이렇게 텍스처 해상도를 설정합니다.
   
   그리고 R32 단 32비트로 합니다. G나 B까지 쓸 필요가 없어요.
   그리고 imgui상에서는 알파값이 있어야 텍스처가 imgui상에서 보이는데, 현재의 imgui 설정에서는 안보일겁니다. 알파값도 없고 해상도도 안맞거든요 
   그렇다고 시각화 하겠다고 알파값 넣어줄려면 텍스처 용량이 메모리를 너무 많이 잡아먹어요 무슨 1000기가가 넘을수도 있는데
   그래서 렌더타겟 옵션만 주고, 실제로 값을 볼방법이 딱히 없어서 비주얼 스튜디오의 그래픽 쉐이딩 상에서는 표시되니까 그렇게 시각화 보는걸로 하죠. 

   아니 잠깐 설명하다가 쉐이더 리소스 있어야되네 생각해보니까 위에 세줄 이야기 했던거 번복하심

   물체의 깊이를 렌더타겟에 저장하고, 물체의 깊이가 깊이 텍스처에 저장하죠.
   깊이는 깊이대로 기록하면서 최종 깊이값 역시 깊이인 겁니다.
   즉, 지금 렌더타겟과 깊이 텍스처 두개의 텍스처를 쓰는데 원래는 깊이 텍스처 하나만 써도 되거든요? 근데 구조적으로 그게 불가능합니다. 
   깊이텍스처 단독으로 써서 쉐이더 리소스를 바인딩 할수 없다ㅠ <- 정확하지 않음 설명듣긴들었는데 여튼 렌더타겟까지 있어야한다고함 하나만 쓰면 참 좋겠는데 구조적으로 그게 불가능 하다는 식으로 말하심

   따라서 굳이 깊이값 판정하는 뎊스 텍스처하나, 최종적으로 결정된 깊이값 저장하는 렌더타겟하나 이렇게 두개 있어야함. 둘다 깊이값저장한다는 말임

  - C렌더매니저init.cpp 에 MRT 정의한 코드 확인해볼것.


 - 데칼 끝났으니까 데칼 오브젝트 코드 지울게요.
   그리고 빛좀 밝게 하구요
   메쉬 렌더 finaltick()에서 그렸던 디버그 십자가 삭제할게요 보기 불편하네

 - 광원시점에서 렌더링하는 코드 작성해보자
  - 렌더매니저 render_editor()
   - 메인카메라 렌더링 하는 코드 있죠? 그 이전에 해줘야될 작업을 추가할겁니다.
     광원시점 shadowDepthMap 생성하기

   - 트랜스폼 컴포넌트가 이동관련 정보를 담고있으니, m_IsDynamic 이라는 bool 맴버를 새로만들어서 동적물체인지 정적물체인지 구분할거에요. 디폴트값은 동적물체입니다.(true)
   - 레벨플레이 버튼 누르는 순간 물체의 깊이값 사진한번 찍어서 메모리에 저장해 두는 방식을 추천할게요

   - CreateDynamicShadowDepth()
    - 메인카메라나 에디터카메라나 그리기전에 한번 수행되야합니다.
    - 먼저 MRT type을 SHADOW_DEPTH 로 바꾼다.
    - 광원시점에서 바라보았을때의 물체의 깊이정보를 기록하게한다.
      그 함수가 render_shadowdepth()
      우리는 디렉셔널 라이트일때의 깊이정보만 기록할겁니다 포인트 라이트는 어려워서 안할거임
      
      shadow depth MRT는 완전 디렉셔널 라이트 전용 MRT입니다. 그리고 텍스처 해상도가 엄청 높죠?
      반면 포인트라이트는 해상도가 그리 높을 필요 없어요. 
      그리고 최적화를 정말 잘해서 한번에 6가지 시점 렌더링하더라도 어쨌든 연산이 많이 들어가기 때문에 포인트라이트는 그림자를 끄는 게임들이 많아요.
      위처같은데서 횟불 들면 그림자가 생기죠? 근데 지나가다가 마을에있는 횟불은 그림자가 없어요. 포인트라이트도 꼭 필요한 애만 그림자 그리게 하는거죠.

 - CLight3D::render_shadowdepth()
  - if문으로 본인이 디렉셔널라이트가 아니다 라면 그냥 바로 return 시킵니다.
  - 디렉셔널 라이트라면 이제 빛 본인의 시점으로 렌더링 해야되는데, 기존엔 카메라 시점으로 했죠? 
    카메라에 했던거처럼 또 맴버로 뷰프로젝트 행렬 맴버로 추가로 넣기엔 좀 그래요.똑같은 짓 반복하는거 같아서.
    
    묘수로 빛에 게임오브젝트를 맴버를 가지게 합시다. m_CamObj 얘는 레벨에 속해있는애가 아니고요 카메라 처럼 동작하게 하려고 그 기능을 가져오려고 
    오브젝트 하나를 그냥 쥐어준겁니다. 예외적인 존재죠 레벨에 속해있지 않고 그냥 기능만 제공해주는.
    생성자에서 이 오브젝트가 트랜스폼과 카메라 컴포넌트를 가지게 해둡시다.

  - 부모쪽에 COMPONENT_TYPE이라는 const 맴버가 있어서 컴파일러가 자동으로 제공하는 대입연산자가 안됩니다.
    *m_CamObj->Transform() = *Transform() 이 안먹히는 이유입니다.
    그래서 어쩔수없이 Transform()->Set어쩌구 함수들로 일일히 세팅해야됩니다.

   - CTransform::GetWorldRot()
    - XMMatrixDeconpose()의 4번재 인자로 우리 월드 최종행렬을 넣어주고요 거기서 쿼터니언 뽑아내고,
      쿼터니언에서 행렬로 바꿔주는함수인
      XMMatrixRotationQuaternion(Qurt) 로 최종 회전행렬 matRot를 리턴한다.
      전달해주고 싶은 각 xyz 축별 회전이 모두 통합된 회전행렬이다.
  
  - 각 축별 통합 행렬을 구하는거 까진 했는데 통합행렬을 각 축별로 얼만큼 회전했는지 분해해주는 함수는 지원해주지 않아요 그게 어렵기때문이에요 해가 여러개일 수도 있거든요.
    각 축별 회전값이 필요한 이유는 카메라 세팅할때 결국 축별 회전 값이 필요하기 때문이에요.

    거의다 오른손 좌표계로 되어있어서 내가 능력이 되면 왼손좌표계 기반코드로 짜겠는데 제가 그걸 못해서 결국 1주일동안 애써서 찾긴했어요. 근데 코드 자체가 
    많은 부분이 생략, 축약되어 있어서 정확한 원리는 파악이 잘안되요. 어쨌든 그 찾은 코드를 저희 엔진에 이식할게요.
    DecomposeRotMat()함수. 

  - 



















207
==========================================================================================



208