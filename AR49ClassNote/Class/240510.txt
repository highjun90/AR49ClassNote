 
 - 오늘은 그림자 구현해볼거에요

 - 어제 광원시점에서 물체들을 한번찍어야지 물체의 그림자들을 판정할수 있다고 했어요.
   디렉셔널라이트는 구현이 그래도 할만한데 포인트 라이트는 진짜 힘들어요.
   왜냐?
   광원의 중심위치에서 총 6방향 6면체 시점으로 사진을 미리찍고, 한 픽셀의 그림자계산을 하려고 하면 그 미리찍은 6개의 시점에 대해 총 6번 검사를 해야해요.
   하지만 이걸 한번에 그리는 방법이 이론상으로는 있어요
   지오메트릭쉐이더를 활용하면 하나의 시점에서 여러방향의 렌더링을 뽑을 수 있어서 포인트라이트를 구현할수 잇다고는 하는데 저도 구현해본적 없어서 수업시간에는
   포인트라이트 그림자는 따로 구현하지 않을겁니다. 궁금한 친구들은 제가 자료는 있어서 참고해줄수 있긴합니다.
   포인트라이트를 6번 렌더링하는 방식으로 구현 시도한 친구 있었는데 프레임이 개 박살이 났어요. 결국 포인트라이트 그림자 구현은 한번에 렌더링할수있는 방법으로 구현해야 할겁니다.

 - SHADOW_DEPTH MRT 타입 미리 정의해놨네? 잘됬네요
  - 얘는 텍스처 1장으로 구성되어있고, 다른 곳에서 텍스처 Find하는게 아니고 직접 텍스처 만들어야되요
  - 얘는 해상도가 높으면 높을수록 좋아요. 우리가 실제로 보이는 해상도랑 일치할 필요가 없는애고 해상도가 높으면 높을수록 좋아요 해상도 높을수록 정확도가 올라가는거라.
    제가 알기론 텍스처 최대 해상도가 8192로 알고있어요 워낙 오래되서 지금은 커졌을 수도 있는데 일단은 이렇게 텍스처 해상도를 설정합니다.
   
   그리고 R32 단 32비트로 합니다. G나 B까지 쓸 필요가 없어요.
   그리고 imgui상에서는 알파값이 있어야 텍스처가 imgui상에서 보이는데, 현재의 imgui 설정에서는 안보일겁니다. 알파값도 없고 해상도도 안맞거든요 
   그렇다고 시각화 하겠다고 알파값 넣어줄려면 텍스처 용량이 메모리를 너무 많이 잡아먹어요 무슨 1000기가가 넘을수도 있는데
   그래서 렌더타겟 옵션만 주고, 실제로 값을 볼방법이 딱히 없어서 비주얼 스튜디오의 그래픽 쉐이딩 상에서는 표시되니까 그렇게 시각화 보는걸로 하죠. 

   아니 잠깐 설명하다가 쉐이더 리소스 있어야되네 생각해보니까 위에 세줄 이야기 했던거 번복하심

   물체의 깊이를 렌더타겟에 저장하고, 물체의 깊이가 깊이 텍스처에 저장하죠.
   깊이는 깊이대로 기록하면서 최종 깊이값 역시 깊이인 겁니다.
   즉, 지금 렌더타겟과 깊이 텍스처 두개의 텍스처를 쓰는데 원래는 깊이 텍스처 하나만 써도 되거든요? 근데 구조적으로 그게 불가능합니다. 
   깊이텍스처 단독으로 써서 쉐이더 리소스를 바인딩 할수 없다ㅠ <- 정확하지 않음 설명듣긴들었는데 여튼 렌더타겟까지 있어야한다고함 하나만 쓰면 참 좋겠는데 구조적으로 그게 불가능 하다는 식으로 말하심

   따라서 굳이 깊이값 판정하는 뎊스 텍스처하나, 최종적으로 결정된 깊이값 저장하는 렌더타겟하나 이렇게 두개 있어야함. 둘다 깊이값저장한다는 말임

  - C렌더매니저init.cpp 에 MRT 정의한 코드 확인해볼것.


 - 데칼 끝났으니까 데칼 오브젝트 코드 지울게요.
   그리고 빛좀 밝게 하구요
   메쉬 렌더 finaltick()에서 그렸던 디버그 십자가 삭제할게요 보기 불편하네

 - 광원시점에서 렌더링하는 코드 작성해보자
  - 렌더매니저 render_editor()
   - 메인카메라 렌더링 하는 코드 있죠? 그 이전에 해줘야될 작업을 추가할겁니다.
     광원시점 shadowDepthMap 생성하기

   - 트랜스폼 컴포넌트가 이동관련 정보를 담고있으니, m_IsDynamic 이라는 bool 맴버를 새로만들어서 동적물체인지 정적물체인지 구분할거에요. 디폴트값은 동적물체입니다.(true)
   - 레벨플레이 버튼 누르는 순간 물체의 깊이값 사진한번 찍어서 메모리에 저장해 두는 방식을 추천할게요

   - CreateDynamicShadowDepth()
    - 메인카메라나 에디터카메라나 그리기전에 한번 수행되야합니다.
    - 먼저 MRT type을 SHADOW_DEPTH 로 바꾼다.
    - 광원시점에서 바라보았을때의 물체의 깊이정보를 기록하게한다.
      그 함수가 render_shadowdepth()
      우리는 디렉셔널 라이트일때의 깊이정보만 기록할겁니다 포인트 라이트는 어려워서 안할거임
      
      shadow depth MRT는 완전 디렉셔널 라이트 전용 MRT입니다. 그리고 텍스처 해상도가 엄청 높죠?
      반면 포인트라이트는 해상도가 그리 높을 필요 없어요. 
      그리고 최적화를 정말 잘해서 한번에 6가지 시점 렌더링하더라도 어쨌든 연산이 많이 들어가기 때문에 포인트라이트는 그림자를 끄는 게임들이 많아요.
      위처같은데서 횟불 들면 그림자가 생기죠? 근데 지나가다가 마을에있는 횟불은 그림자가 없어요. 포인트라이트도 꼭 필요한 애만 그림자 그리게 하는거죠.

 - CLight3D::render_shadowdepth()
  - if문으로 본인이 디렉셔널라이트가 아니다 라면 그냥 바로 return 시킵니다.
  - 디렉셔널 라이트라면 이제 빛 본인의 시점으로 렌더링 해야되는데, 기존엔 카메라 시점으로 했죠? 
    카메라에 했던거처럼 또 맴버로 뷰프로젝트 행렬 맴버로 추가로 넣기엔 좀 그래요.똑같은 짓 반복하는거 같아서.
    
    묘수로 빛에 게임오브젝트를 맴버를 가지게 합시다. m_CamObj 얘는 레벨에 속해있는애가 아니고요 카메라 처럼 동작하게 하려고 그 기능을 가져오려고 
    오브젝트 하나를 그냥 쥐어준겁니다. 예외적인 존재죠 레벨에 속해있지 않고 그냥 기능만 제공해주는.
    생성자에서 이 오브젝트가 트랜스폼과 카메라 컴포넌트를 가지게 해둡시다.

  - 부모쪽에 COMPONENT_TYPE이라는 const 맴버가 있어서 컴파일러가 자동으로 제공하는 대입연산자가 안됩니다.
    *m_CamObj->Transform() = *Transform() 이 안먹히는 이유입니다.
    그래서 어쩔수없이 Transform()->Set어쩌구 함수들로 일일히 세팅해야됩니다.

   - CTransform::GetWorldRot()
    - XMMatrixDeconpose()의 4번재 인자로 우리 월드 최종행렬을 넣어주고요 거기서 쿼터니언 뽑아내고,
      쿼터니언에서 행렬로 바꿔주는함수인
      XMMatrixRotationQuaternion(Qurt) 로 최종 회전행렬 matRot를 리턴한다.
      전달해주고 싶은 각 xyz 축별 회전이 모두 통합된 회전행렬이다.
  
  - 각 축별 통합 행렬을 구하는거 까진 했는데 통합행렬을 각 축별로 얼만큼 회전했는지 분해해주는 함수는 지원해주지 않아요 그게 어렵기때문이에요 해가 여러개일 수도 있거든요.
    각 축별 회전값이 필요한 이유는 카메라 세팅할때 결국 축별 회전 값이 필요하기 때문이에요.

    거의다 오른손 좌표계로 되어있어서 내가 능력이 되면 왼손좌표계 기반코드로 짜겠는데 제가 그걸 못해서 결국 1주일동안 애써서 찾긴했어요. 근데 코드 자체가 
    많은 부분이 생략, 축약되어 있어서 정확한 원리는 파악이 잘안되요. 어쨌든 그 찾은 코드를 저희 엔진에 이식할게요.
    DecomposeRotMat()함수. 



 - 정리 
   1) 포인트라이트 그림자 구현은 (1) 포인트라이트 상하좌우앞옆 총 6시점에서의 물체 깊이값을 저장하고 픽셀의 그림자여부를 판단하는 방법
                                 (2) 지오메트릭 쉐이더에서 렌더링 한번에 총 6시점 관련 계산을 모두 마치는 방법
      이 있고 당연히 (2)번이 좀 더 좋은 퍼포먼스를 보인다. 수업시간때는 포인트라이트 그림자는 구현 안할거임 너무 복잡함.

   2) 한 픽셀이 그려질때 그게 그림자영역에 있는지 판단하려면 그 위치에 대응하는 미리 저장된 물체의 깊이값으로 비교해서 판단해야한다.
      그게 SHADOW_DEPTH MRT 에 저장된 텍스처이다.
      그리고 물체의 깊이값 저장은 카메라의 위치가 기준이 되면 안되고 디렉셔널라이트 위치가 기준이 되야한다. 당연하다. 물체들의 깊이값은 광원이 기준이 되야 
      픽셀들도 나와 광원 사이에 물체가 있는지 제대로 판정하지 카메라가 기준이 되버리면 애초에 그림자의 정의에 어긋난다.

   3) SHADOW_DEPTH MRT는 텍스처가 2개 세팅되어있다. 하나는 렌더타겟, 하나는 깊이텍스처. 그런데 렌더타겟에 무슨 색깔 같은 값을 저장하는게 아니라 
      그냥 깊이값을 저장한다. 즉 렌더타겟도 깊이값저장, 깊이텍스처도 깊이값저장. 왜 굳이 똑같은 텍스처2장을 쓰는가?
      깊이텍스처의 깊이값은 모든 물체들의 깊이값을 비교하는데 쓰이고, 렌더타겟에는 그렇게 비교한 물체들의 최종깊이값을 저장하는 것이다. 
       
      그리고 굳이 이렇게 텍스처 2장 안쓰고 1장만 써도 이론상으론 가능한데, 렌더타겟 텍스처를 쓰지 않으면 쉐이더 리소스를 바인딩 할수 없다는 선생님의 설명이있었다
      사실 정확하게 파악 못했고 이건 제대로 이해 못해서 더 공부 해봐야함 왜 굳이 텍스처 2장을 쓰는지.

   4) CLight3D 객체가 오브젝트를 가지게 한다.
      이 오브젝트는 레벨에 속하지 않을 뿐더러, 그냥 오브젝트가 제공할 수 있는 기능만 쓰기위해서 맴버로 추가한 것이다.
      이 오브젝트는 트랜스폼과 카메라 컴포넌트를 가지고, 빛은 각 물체의 깊이값을 저장하는데 필요한 여러가지 자원과 기능을 이 오브젝트에서 제공받아서
      최종적으로 그림자를 그리는데 잘 활용되게된다.

    


207
==========================================================================================

 - 방금 회전횡렬 분해하는 함수 추가했죠? 이게 추가됬으니
   내가 어떻게 하면 광원이 어떤 방향을 비출지 막 짱구 굴려서 직접적인 회전 수치를 트랜스폼에 직접 적어줬었잖아요
   그러지말고 그냥 내가 원하는 광원의 방향벡터만 적어주면 알아서 회전횡렬이 세팅되는 기능을 트렌스폼에 구현할수 있을거 같아요.
   Transform()->SetRelativeRotation()으로 하지말고
   Transform()->SetDir(1.f, -1.f, 1.f) 이런 식으로요.

 - CTransform()::SetDir()
  - cross 함수로 도출한
   
   vRight
   vUp
   _Dir

   자체가 회전행렬입니다.
   인자로준 _Dir은 원래내가 바라보는 방향이니까 front 방향 벡터겠죠.

   그렇게 도출한 matRot을 각 축별로 분해해서 Vec3에 저장하고 
   그걸 SetRelativeRotation()의 인자로 넣어줘서 회전행렬로 설정해주면 끝.
  
  ??) cross로 무슨 왼손좌표계로 감싸쥐는걸로 막 right up 도출하는데 솔직히 이해안됨 ㅠㅠ 이부분은 공부필요.
  ??) 쿼터니온이 뭐였지? 자꾸 쿼터니온어쩌구하네..

  ??) 인자로준 dir을 front로 하고, 그걸 y축과 cross 해서 right를 도출했다 
      그리고 그렇게 도출한 right와 dir로 up을 도출했다.

  - 만약에 right와 dir이 직선을 이루는 경우는 예외처리를 해야겠네요.
    cross의 결과가 알수없는 경우로 뜨죠? (막 디버그모드에서 ??? 값이 이렇게 뜬걸로 보임)
    예외처리로 
    if(vRight.x == 0.f && vRight.y == 어쩌구.. )
    이렇게 제로벡터일때는 x축을 right으로 설정할게요

  - 완전히 아래로 바라볼때는 초기 방향설정이 잘못되니까 그걸 예외처리 했어요.

  - 아 스바 너무 빨라 수업이.... 내가 뭘 이해 못했는지 적는것도 벅차다.



 - CLight3D::render_shadowdepth()로 돌아와서.
  - finaltick()주면 최종 월드 행렬 계산하겠죠. 그런데 오브젝트에 바로 파이널틱 주면 안되요 레이어 등록하는 코드가 있어서.
    그래서 컴포넌트에 수동으로 파이널틱 줘야합니다. 오브젝트 보고 파이널틱 줘서 컴포넌트들 알어서 파이널틱 돌리게 하려고 했는데 그럼 레이어 설정관련해서 오류납니다.
    이거때문에 예전에 imgui인가 에서 그 레이어 등록하는 기능뺀 파이널틱 따로 정의한적 있는걸로 기억합니다

 - 원래 sortObject()함수는 내가 찍기로한 레이어에 있는 모든 물체 가져와서 도메인에 따라 분류한거잖아요? 근데 빛에 있는 카메라컴포넌트는 그럴 필요가 없어요 따라서
   새로운 분류 함수를 정의해야합니다.

 - 잠깐 생성자로 와서 
   빛의 카메라는 직교투영으로 설정해야합니다.
   우리 지금 디렉셔널 라이트 그림자 만들고있죠? 포인트 라이트는 원근투영을 써야겠지만 우리는 오직 디렉셔널만 만들기로 현재 약속했으니 무조건 직교투영입니다.
   far도 한 10만정도 넉넉하게 해야합니다.
   fov는 직교니까 필요없고
   LayerCheckAll()하고 UI레이어 만 제외합니다.
   아 그리고 이대로 직교투영쓰면 안되는게 우리 카메라 해상도를 화면해상도랑 일치 시켰었는데 
   그림자 깊이 mrt는 해상도 졸라 높게 했었잖아요. m_Width와 m_Height set하는 함수 추가해서 해상도를 넉넉하게 설정합시다.  10000 으로 할게요.


 - 렌더컴포넌트와 메쉬만 있으면 분류를 받을거에요 기존처럼 디퍼트 막 이렇게 분류해서 언제 렌더링될지 분류되는게 아니라
   어차피 여기에 그려질 물체들은 지들이 설정된 재질 쓸게 아니라 그림자 전용 재질을 쓸거래서 그냥 렌더딩 될수있는 조건만 되면 다 그립니다.

 - CCamera::SortShadowMapObject()











  






208