 - 카메라에서 렌더링할, 디퍼드로 분류되는 애들을 먼저 그린다고 했죠. 
   도메인이 디퍼드로 설정된 오브젝트들은 쉐이더 자체가 출력 타겟이 4개로 설정되어 있기에 
   오브젝트의 도메인을 잘 설정해줘야 합니다.

   이렇게 디퍼드 MRT를 먼저 값 설정이 완료되면, 다음단계로 Lighting MRT로 변경하고,
   거기에 이전 디퍼드 MRT에 기록된 정보를 이용해서 Lighting MRT의 렌더타겟들에 값을 채웁니다.

   마지막으로 Merge 단계를 거칩니다.


   포인트 라이팅쪽을 제가 오늘 수업에 할거니까 스포트 라이트를 여러분들이 하세요.
   포인트 라이트에서 고려해야될거 - 볼륨.
   광원이 있는 영역자체를 그렸다기 보다는 영역에 갖다댈 물체가 있는지 검사하는거죠.
   광원의 메쉬인 스피어 공간 내에 포지션 타겟의 정보와 비교해서, 겹치는 영역에만 색을 그리는겁니다.
   당연히 겹치는 부분이 없는 광원의 스피어 영역은 버려지겠죠.

   이전에 디렉셔널 라이트 일때는 그냥 렉트메쉬써서 픽셀 전체영역 검사했죠. 
   포인트 라이트는 문제가 있습니다. 얘는 3차원 적으로 생각해야해요

   땅이있다고 칩시다. 포인트라이트가 땅 표면의 중심 위에 있다고 해볼게요.
   그럼 포인트라이트의 스피어메쉬는 어떻게 그려져야합니까? 스피어 전체영역이 다 그려져야 합니까?

   아닙니다. 딱 평면하나만 그려져야 합니다. 그런데 호출된 볼륨메쉬 전체에 대해서 픽쉘쉐이더 다 호출시켜서 계산한다고 해결되는게 아니고,
   픽쉘쉐이더 호출해서, 호출된 모든 픽셀쉐이더에 포지션을 가져와보면 다 무슨 값이 있어요. 그래서 뭐가 있네? 이러면서 그리면 안된다고요
   2차적으로 진짜 얘가 광원 스피어영역 안에 속해있는 놈인지 여부를 체크해야합니다. 

   그 방법은 크게 2가지가 있습니다. 
   1) 스텐실. 우리가 매번 스텐실 거리는데 실제로 스텐실 활용해본적이없죠
   2) 디퍼드 MRT에서 남은 정보를 활용한다.

   쉬운거부터 해봅시다.

   실제 구 스피어 영역에 있는지 따져봐야 합니다. 어떻게 해야할까?
   CLight3D::finaltick()에서 트랜스폼의 위치값이 실제 3D공간에서의 위치죠? 트랜스폼에서 계산한 나의 정보를 매번 갱신하죠?
   그리고 Light3D에서 본인의 반지름을 가지고있죠? Light가 반대로 트렌스폼에 자신의 반지름 정보를 알려줍니다. 이건 언제만 할거냐? 광원타입이 포인트인 경우에만 합니다.
   그래야 볼륨메쉬 배치할때 트랜스폼이 계산한 월드로 본인의 영역을 계산하겠쬬.
   예시로, 반지름이 500이라면 지름은 1000이죠? 그래서 SetRelativeScale()에서 반지름의 2배값을 전달해줍니다. 반지름의 2배를 본인의 스케일로 잡는겁니다.
   이렇게 설정해줘야 빛의 트랜스폼에서 볼륨메쉬(스피어메쉬)를 배치시킬 수 있습니다.

   애초에 구는 로컬스페이스에 있었겠죠 그다음 월드 뷰 투영까지 와서 픽쉘쉐이더가 호출됬겠죠. 
   우리는 구의 윗부분의 UV값으로 포지션타겟에 값을 가져왔다고 칩시다. 그럼 애가 진짜 구의 영역내에 존재하는 놈인지 확인하려면 프로젝션 상태에서 꺼꾸로 로컬로 돌아가서 검사하는 겁니다.

   구는 반지름 0.5짜리 정점으로 돌아가갰죠? 검사하는 픽셀이 똑같은 과정을 거쳐서 구의 스페이스 영역에 끌고 왔을때도 영역내에 있는지 검사하면 되는겁니다.

   구의 원점에서 검사하는 픽셀 사이 거리가 0.5 이상이면 광원의 영향을 안받는 것이고, 0.5 이하면 광원의 영향을 받는겁니다.

   이렇게 하는 이유는 판정조건이 항상 동일하기 때문이에요. 추가적인 계산이나 그로인한 여러 정보가 필요 없는거죠

   이해를 위해서 볼륨메쉬가 큐브일때를 생각해보세요 만약에 우리 광원이 스피어가 아니라 큐브였다면? 그걸 생각해보세요.
   얘는 로컬스페이스로 끌고갈때 xyz축 어디 한축이라도 벗어나 있으면 광원 밖에있는 앱니다. 
   땅이 큐브영역에 들어있는 위치. 

   
             [-----------------]
   ----------[-----------------]-------------
             [-----------------]

  실제 광원에 들어와 있는 영역은 두번쨰 [-----------------] 인데, 포인트텍스쳐에서는 위, 아래 [-----------------] 까지 겹쳐있게 됩니다 근데 얘가 실제로 광원의 영역에 있는앱니까?
  아니죠 광원 너머에 있는게 투영효과 때문에 겹쳐서 화면에 보이는 거잖아요 이런 애들을 광원영역에 없는 걸로 판정해야해요. 
  그런데 포지션텍스처 값과 큐브메쉬 영역만 갖고 픽셀쉐이더에서 계산하려하면 그냥 광원에 있는걸로 계산해야되죠 이건 우리가 원하는 결과가 아닙니다.
  그래서 보이는 화면이 기준이 되면 안되고, 실제 포지션 값으로 영역판정을 해야 된다는 말입니다. 볼륨메쉬가 스피어일때도 마찬가지였던거죠.


  이 방법은 장단점이 있습니다.
  장점
  연산이 빨라요. 볼륨메쉬 내부에 체크판정하는게 빠릅니다. 왜냐면 즉시 한번에 검사할수 있어요. 원패스로. 픽셀이 이 볼륨메쉬 영역에 있는지 바로 검사할수 있어요.
  단점
  볼륨메쉬가 되게 특징이 있어요. 어떤 볼륨메쉬를 사용했느냐에 따라 메쉬 형태에 맞춰서 검사 방법을 일일히 다 고려해야합니다.
  그런데 볼륨메쉬가 엄청 복잡하거나 규칙이 없는 메쉬면 쓸수 없겠죠?


 - 2번째 방법 스텐실 버퍼.
  얘는 장단점이 1번째랑 딱 반대겠ㅈ?
   장점 - 볼륨메쉬 도형이 어떤 모양이던 상관없음
   단점 - 연산이 좀 더 많이 필요.

  자 예시로 이 방법을 설명해봅시다.
  어떤 평면이 있고, 어떤 인물이 있다고 합시다. 두 영역이 겹쳐있을떄 그 부분만 특정 색상으로 변화하는 효과를 주고싶어요
  이떄 첫번쨰 방법으론 이걸 처리 못해요 인물 메쉬 자체가 너무 복잡하고 규칙도 없기 때문에 평면의 포지션과 인물의 포지션을 로컬스페이스로 끌고가서 영역판정을 계산할 수식을 세울수가 없습니다.
  이 상황은 바로 스텐실 버퍼를 이용해야합니다.


 - CCamera.cpp
  - m_MatProjInv 라는 애를 추가해서 투영행렬의 역행렬을 미리 정의. 월드역행렬도 똑같이 추가.

 - struct.h에서 미리 선언했던
  - g_Transform.matViewInv 와 월드Inv 까지
    CCamera::render()에 미리 구해 놓습니다. 
    동시에 관련 get함수도 정의해놓구요

 - CLight3D::render()
  - 광원타입이 포인트일떄,
    matVWInv를 MAT_0 슬롯에 넣어서 쉐이더에 전달합니다. 스포트라이트도 마찬가지겠죠?
    matVWInv로 본인의 투영좌표에서 로컬좌표로 다시 돌아가게 하는 역행렬세트입니다.
    (로컬x월드x뷰 = 뷰포지션을 로컬로 돌려놓으려면 뷰포지션 x 뷰역행렬 x 월드역행렬 해야함
     이때 뷰역행렬 x 월드역행렬 이 바로 matVWInv 임)

 - light.fx
  - g_mat_0 이 추가적으로 들어오게 됬습니다 MAT_0 슬롯이었쬬?
    PS_PointLight() 쉐이더 함수는 그냥 디렉셔널 쉐이더 함수 그대로 복사해서 코드 수정할게요

 그전에
 - CAssetMgr_init.cpp에서
   포인트라이트 쉐이더와 재질을 정의합니다.

  - CLight3D::render()에서
   INT_0에 바인딩 하는 부분은 광원 모든타입에 공통 적용되네요 그냥 if문 밖으로 빼겠습니다.
   그리고 UpdateData() render()도 타입 상관없이 똑같이 해주는 거니 얘도 if 밖으로 뺄게요
   결과적으로 디렉셔널 라이트 단독으로 하는게 없네요 그냥 디렉셔널라이트 일때 따로 처리한다는 개념은 코드상에서 안보이게 되네요
   그리고 차라리 if문으로 디렉셔녈 라이트가 아닐때 역행렬 바인딩하는 코드를 추가했습니다.















201
=======================================================================================


202