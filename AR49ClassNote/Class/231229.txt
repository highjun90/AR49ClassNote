 - 충돌체는 렌더링 대상이 아니지만 충돌체의 범위를 화면에 시각적으로 볼수있으면 좋으므로 디버그용 렌더링구조를 만들자
 - 양이 많아질거 같아서 CRenderMgr, CRenderMgr_init 로 cpp 파일을 두개로 만듦
 - 지금 렌더링구조는 레벨에서 레이어, 그 자식 순으로 탑다운 방식으로 render 했는데
   이제는 카메라 기준으로 바꿀겁니다. 레벨에 있던 render()함수 없애고, 카메라를 가져와서 카메라의 render를 쓸겁니다.

 - RenderMgr에 카메라들의 벡터를 들고 있을겁니다. 이 RendeerMgr에 카메라를 등록시키고, 그 벡터에  있는 카메라 중 한 카메라를 가져와 렌더링 합니다. 여러개도 가능(UI카메라, 캐릭터카메라등)
 - 카메라를 벡터에 두는 이유가 카메라 우선순위에 따라서 카메라를 순차적으로 벡터에 저장할꺼기 때문입니다.
   벡터의 인덱스의 0번째 카메라가 메인카메라입니다. 나머지는 서브카메라여서 그려주긴 할건데 메인카메라만큼 많은 기능을 하진 않습니다. 서브카메라들은 자기 시점에서 덧그려주는 역할정도를 할겁니다.

 - m_vecCam[] 의 한자리에 카메라 들어가려고 하는데 이미 딴게 있다면(==null 아니면) 오류출력
 - 지금은 꼴랑 카메라 하나지만 render()함수에서 순차적으로 카메라들에게 렌더시킴

 - 두종류의 LayerCheck()함수 만듬 인자로 인덱스를 줄건지 아니면 레이어 이름(엔터티 기본기능으로 이름설정있었음)으로 줄건지
  - 지정된 레이어만 카메라가 렌더하도록 유도
  - 레이어 이름으로 찾아도 어차피 인덱스를 인자로 하는 LayerCheck()로 감
  - m_LayerCheck 의 각 자리가 바로 레이어를 카메라가 렌더할건지 아닌지에 대한 정보가 있는것.
   - 만약 두번째 인자 bCheck가 true면 비트값 1, 아니면 0
  - 정리하자면, 카메라가 LayerCheck()함수를 호출해서 각 레이어를 출력할지 안할지 설정하는 것이다.
     (카메라말고 Level에도 LayerCheck() 함수가 있는지 확인)

 - 원래는 그냥 Camera->LayerAllcheck()로 레이어 다출력해도 됨 

 - 예시로 나중엔 UI 카메라는 31번 레이어만 찍고, 다른 카메라는 31레이어 뺴고 다 찍는 그런 구조를 둘겁니다.
   이렇게 되면 다른 몬스터나 주인공이 31번 레이어 범위를 지나가도 포착안됨(정확히 말하면 의도적으로 안그림)
   반대로, UI카메라 아닌 서브카메라가 설령 UI가 있는 방향을 바라봐도 UI를 그리지 않게되니 보이지 않음

 - 원래 finalTick()쪽에 변환행렬이 있었는데 이러면 카메라가 여러개 될때 각 카메라들이 FinalTick()떄 서로 렌더파이프라인 한다고 다투므로 오류난다. 따라서 finalTick() 이아닌
   Render 하기 직전에 변환행렬을 적용해야한다. 지금 Render() 함수의 최상단에 변환행렬을 두도록 변경했다.

==============================================
 tDebugShapeInfo 라는 구조체 만들기
  - enum class로 DEBUG_SHAPE 도 정의. 충돌체의 모양이 사각형인지 원형인지 등을 나타냄
  - vWorldPos, scale, rot 등 변환행렬
  - vColor 색상
  - 얼만큼의 tick()까지 유지할건지 Duration. 0이면 딱 1프레임만 찍힘
  - 깊이테스트 할건지 말건지 알려주는 bDepthTest.

 - DrawDebugRect, Circle, Cube, Sphere()함수 만들고 인자 형태별로 오버로드까지함
  - AddDebugSHapeInfo()함수  RenderMgr에 인자로 열심히 적은 Info(tDebugShapeInfo) 줌

 - 이제 rendeer()와 render_debug() 두번 렌더하게됨


 - 디버그 전용오브젝트만들기 (m_pDebugobj)
  - 트렌스폼 컴포넌트는 무조건있어야겠죠? 그리고 메쉬렌더도 AddComponent 하구요 (미리 구조부터 정하심)
** switch문 뭐 단축키 누르더니 알아서 enum 타입 전제별로 쏵 템플릿처럼 만들어줌


 - 디버그용 전용 재질 하나 만들게요

 - hlshl의 전역레지스터 선언들이 딴 fx에 다 있어서 새로운 fx는 그걸 이용못하니 이제 그것들을 따로 분리해서 거기에 둘게요 이제 그걸 참조합니다.
   #include "value.fx" 하면 됩니다

 - 대충 쉐이더 잘 만들어졌다고 하고 에셋매니져에서 디폴트 메쉬, 쉐이더, 재질을 Create하는 함수를 만듭니다.
   CreateDefaultMesh, Shader, Material()
   
 - 기존에 있던 std 메쉬 쉐이더 재질만 있었는데 default용 메쉬 쉐이더 재질을 추가했음. 방금 fx파일에 적은거 연결해서.

 - 재질 만들고 쉐이더 만들었는데 아직 fx에서 제대로 코드가 안만들어져 있어요 그거만 제대로 작성하면 잘나ㅗㅇ겠죠
* 갑자기 환경설정에서 쉐이더 모델 5.0으로 변경

 - 외곽선만 그리게 쉐이더에서 설정할겁니다.
   샘플링할거라서 UV값이 필요없긴한데 일단 가져올게요<-?


 - 디버그 그림들은 UI카메라가 아니라 메인카메라에 들어가 있어야 변환행렬이 옳게 적용되겠죠?

 - UV값과 discard를 이용해서 디버그그림의 테두리만 나오게 할 순 있으나 이게 원근투영에서는 거리에 따라 두께가 달라져서 별로 안좋다. 
   그래서 아예 directx에서 제공하는걸 이용한다. 항상 화면을 기준으로 그 라인에 해당하는 픽셀만 그려주기때문에 거리에 따라서 두께가 바뀌지 않는다.
   아니면 토폴로지에서 triangle list 말고 line strip을 쓰면된다. 전자는 삼각형 면에 해당하는 픽셀을 그리는거고 후자는 그냥 점을 연결한 라인의 픽셀만 그린다.


 


