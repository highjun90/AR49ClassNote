 * 어제한 것 컴퓨트쉐이더 이론
  - CGraphicShader.h 파일은 렌더링 파이프라인이 전체적으로 어떻게 이뤄지는지 보여주는 파일이다.

 -CComputeShader
  - CShader를 상속한다.
  - m_CSBlob            -> 컴파일된 이진파일의 컴퓨트 쉐이더를 가리키는 포인터
  - m_CS                -> 컴퓨트쉐이더를 가리키는 포인터
  - m_Const             -> 재질상수버퍼. 컴퓨트쉐이더만의 고유 재질이다.
  - m_GroupX,Y,Z()      -> 그룹 개수(3개)
  - m_ThreadX,Y,Z()     -> 스레드 개수(3개). 스레드는 정해져있는거라 const.
  - GetGroupX,Y,Z()     -> protected로 설정
    SetGroupX,Y,Z()   

  - 컴퓨트쉐이더는 종류가 한가지가 아니고 개별마다 하는 역할이 다 다르다. 그래픽스쉐이더는 클래스는 하나지만 모든것을 변수화 시켜놔서 어떻게 조합하느냐에 따라 별개의 쉐이더로 볼 수있었고
    컴퓨트 쉐이더는 컴퓨트 쉐이더 객체마다 하는 일이 다르다. 각 컴퓨트 쉐이더마다 공통점이 있는게 쉽지 않기떄문에 컴퓨트쉐이더마다 재설계해야한다. 
    즉 CComputeShader를 상속해서 특별한 컴퓨트 쉐이더를 설계해야한다는 뜻

  - 컴퓨트 쉐이더는 크게 3단계로 수행된다.
   1) UpdateDate() -> 컴퓨트쉐이더에서 필요한 데이터들을 GPU에 바인딩하고 
   2) Execute()    ->  본인의 기능(연산)을 수행하고
   3) Clear()
   - 2) 3)은 가상함수. CComputeShader를 추상클래스로 만들어서 상속하는 애들은 반드시 2) 3)을 구현시켜야한다.

 - Excute()함수
  - 자식의 가상함수 UpdateData()가 시행되고  (setcolor.fx는 색깔설정)
    부모는 상수데이터 바인딩한다.
     1)상수버퍼 만들고 2)상부버퍼에 전달할 데이터(m_const) 넣어주고 3)GPU와 연결 (UpdateData_CS() )
    그다음엔 CONTEXT의 dispatch()함수로 실행한다던데 잘모르겠음


 ** 실제로 컴퓨트 쉐이더를 하나 만들어보자
  - 독특하게도 fx파일이 아님에도 ShaderCode 하위파일로 만드는게 있다. 아래에 Compute파일 만들고, 그 아래에 SetColor라는 파일 만든다.
    그아래에 CSetColorShader.cpp 파일 만든다. 

  - CSetColorShader
   - CComputeShader 상속
   - m_TargetTex
   - m_Color       
   - 이게끝임 여기에 대응하는 컴퓨트 쉐이더(fx)파일 필요.

  - setcolor.fx
   - 그냥 컴퓨트 쉐이더 방식으로 텍스처에 색깔 넣어주는 간단한 기능의 쉐이더
   - 머터리얼이 전달받은 스칼라 값중에 g_vec4_0 를 쓸게요 (CComputeShader의 m_Const) 
     g_vec4_0에 내가 설정했던 컬러있겠죠
   - u0슬롯은 뭔가? 기존 t슬롯은 텍스처나 구조화버퍼도 쉐이더리소스뷰로 지정된 텍스처 레지스터에 바인딩했따
     이때는 unordered access view(UAV)가 필요하다 CTexture.h에 미리 정의해뒀다. 이 슬롯의 재밌는 특징은 읽기 쓰기 다 가능하다.
     기존엔 쉐이더에서 sample로 레지스터 읽기만 가능했다 (텍스처 만들때 플래그로 처음부터 그렇게 설정한것이다.)
     - 추가로 앞에 RW 붙여야함 Read Write. RWTexture2D. (그냥 Texture2D라고 선언하면서 u슬롯 쓰려면 오류남)
    - 아무 텍스처나 이렇게 UAV에 바인딩되게 만들수 있는게 아니고 CreateTexture() 할떄 플래그를 조합시켜줘야한다.
      D3D11_BIND_SHADER_RESOURCE 뒤에 비트OR 연산자로 뭐하나더 적어줘야한다. (언오더드 엑세스 어쩌구)
    

 - CS(Compute Shader) 전용 바인딩함수를 만들겠습니다. 기존엔 vs,ps 등 5개 쉐이더 각각 다 따로 되어있죠. 여기에 컴퓨트 쉐이더도 따로 바인딩 전용함수에서 바인딩합니다.
   
 - CAssetMgr_init()에 컴퓨트쉐이더인 setcolor.fx를 컴파일, 생성및 저장한다.
   CComputeShader의 Create() 인자로 fx파일 경로와 함수명 알려줘서 m_Blob과 m_CS에 결과를 받는다.
   에셋 매니저에 AddAsset()으로 등록한다.

 - LevelMgr의 예시
  - 텍스처 정의, pCS에 쉐이더 불러오기, SetColor()로 색 설정, SetTargetTexture()로 대상 텍스처 지정, Execute()로 실행


  =============================================================================================================

 - 타겟색상을 어떤 색깔로 칠하는게 SetComputeShader 이기 때문에 UpdateDate() 반환값을 정수로해서 성공여부를 부모가 파악하게 할게요
   예를들어 텍스처 로드가 실패한다던지. 텍스처가 로드 안되면 이 컴퓨트 쉐이더가 의미없음.

 - CTexture.h 에서 컴퓨트 쉐이더를 GPU에 바인딩할때, UpdateData_CS()함수를 쓸텐데 이게 레지스터 바인딩을 RWTexture2D로 하냐, 아니면 그냥 Texture2D로 하냐에 따라 구분할 필요가 있어요
   즉 컴퓨트 쉐이딩할때 텍스처 읽기만 하고 쓰기는 안하는 텍스처도 있거든요? 원래 파이프라인 렌더링은 고민할 필요가 없었죠 어차피 파이프라인은 읽기밖에 없으니까
   오로지 언오더릿 엑세스뷰로 바인딩 가능한 쉐이더는 컴퓨트 쉐이더입니다.
   그래서 이름을 뒤에 _SRV _UAV로 나눳어요 
   
 - Clear()로 바인딩 걸어놨던 레지스터를 해제한다. 해제안하면 딴 컴퓨트 쉐이더에서 이 슬롯에 바인딩할떄 데이터가 남아버릴수있음
  - 최근에 사용해던 레지스터 번호를 기억하는 멤버 만들어놓는다 m_RecentNum_SRV, _URV
  - 언오더엑세스뷰 set하는 함수들에서 마지막에 기존 set함수에 없었던 i인자도 있는데 별 의미 없다함

 - Dispatch()함수에서  Dispatch에서 그룹정보를 받아가고, fx파일에서 numthreads로 한 그룹의 쓰레드 구성이 어떤지 최대 3차원으로 표현하는 것이다.
   [numthreads(a,b,c)] 면 이 한 그룹의 쓰레드 개수는 a x b x c 이다.
   하나의 그룹이 가질 수있는 쓰레드 최대개수가 1024이다. hlsl버전 5.0 기준이고 버전 올라갈수록 증가. 32x32가 1024 이다. a b 값에 32 넣으면 z값은 1밖에 못넣음 최대치임
   보통 3차원 배열은 쓰레드도 3차원 개념으로 적어준다 z값까지 이용해서. 
   그럼 1024 쓰레드도 부족하다? 그러면 그룹을 한개말고 여러개 전달하면 된다.
   그룹수는 제한없다. 한 그룹이 가질 쓰레드가 1024개인 것만 제한한다.

   uint3 id는 곧 쓰레드의 id이다. 

   쓰레드 ID와 텍스처의 픽셀 xy값을 동일하게 매칭시키기위해 UpdateData()에서 그 수식도 적어준다.
   fx파일에서는 그 쓰레드 ID로 텍스처의 xy값에 연결해서 색을 바꿔준다.

   이런 구조를 실현하려고 fx파일의 한 그룹의 쓰레드총합(numthreads[a x b x c])에서 설정한 a b c 값과 m_ThreadX,Y,Z 의 수치를 동일하게 맞추고, 
   이렇게 맞춘 쓰레드 xyz 값을 기준으로 필요한 그룹의 개수를 구한다.
   현재 32 x 32 x 1 로 쓰레드 조각을 구성했으므로 cpp 파일에서도 32 x 32 x 1로 쓰레드 XYZ값을 설정한다.
   핵심은 fx 파일과 cpp 파일의 abc, xyz 값을 정확히 매칭 시켜야 fx파일에서 텍스처 색깔 입히는 수식이 정상적으로 작동한다는 것이다.
   본인이 32 x 32 x 1 이 마음에 안들어서 바꿀 순 있는데 그럼 꼭 fx파일과 cpp파일의 쓰레드 개수값을 동일하게 맞춰야한다.

 - 그럼 32배수가 아닌 텍스처는 어떻게 해야함? 
   텍스처 해상도와 쓰레드 개수단위와 딱 안 맞아 떨어져서 쓰레드영역과 텍스쳐가 겹치지 않는 부분은 결국 쓰레드도 그리는 작업을 안하는 부위인데
   fx파일에서 id의 xy값 조사해서 텍스처 너비와 높이 초과하는 픽셀은 그냥 아무 작업 안하고 return 시킨다.

 - 응용해서 id.y 가 500~600 사이면 그려라하면 가운데만 그릴것이다.