 * 지난시간 - 복사생성자 레벨구혀중

 -  기존에는 레벨만들고 나서 오브젝트를 집어넣었다. 레벨은 최대 32개의 레이어가 있다. 
   게임오브젝트의 복사생성자는 레이어정보까지 복사되는건아니다. 복사되놓고 레벨에 안집어넣을수 있기 때문에. 그러다보니까
   이렇다보니 복사레벨은 레벨이 소유하고 있는 오브젝트들이 레벨에 집어는 넣지만 레이어는 소속이 없는 상태가 되서 문제가 된다.

   해결1 - 레이어 복사생성자에서 AddObject()함수 안쓰고 직접 push_back()해서 오브젝트들 본인이 소속된 레이어가 뭔지 몰랐다
           (복제된 레이어는 오브젝트를 소유하고있는데 소유된 복제 오브젝트들은 어떤 레이어가 날 가졌는지 모르는상태였음)
           
   이제 또 다른문제 -> 최상단 오브젝트들의 자식오브젝트들은 어떤 레이어에 소속되야 하나? 
   지금 구조는 자식오브젝트들은 다 레이어인덱스가 -1인채로 복제될것임. 
   허나 최상단 오브젝트가 어디 레이어에 소속될때, 자식 오브젝트들의 레이어 인덱스가 -1이었다면 강제로 최상단오브젝트의 레이어인덱스를 따라가게 구조를 짠 상태다
   따라서 복제된 자식오브젝트들은 처음엔 -1이었다가 최상단 오브젝트가 레이어에 addObject()될때 강제로 최상단 오브젝트의 레이어에 소속된다.

   결론 - 선생님의고민) 내가 원하는건 자식오브젝트들이 복제되기전 레이어 인덱스를 고대로 유지되길 바라는데 지금 구조는 그게 불가능하다.

   그래서 새로 고안한 해결법 >> 최상단 오브젝트가 복제될때 최상단 오브젝트는 -1로 레이어 인덱스가 설정되게하고, 그 자식오브젝트들은 원래 레이어 인덱스를 유지한다. 
   이 상황에서 최상단 오브젝트가 어떤 레이어에 들어갈때 최상단 오브젝트만 레이어인덱스 변경하고 자식레이어인덱스들은 본인의 레이어 인덱스를 유지한다.
   (AddObject()의 두번째  인자가 false면 자식 오브젝트의 인덱스는 변경하지 않은채로 해당 부모 오브젝트만 레이어 인덱스를 변경해준다.)


 - 오류 두번째 -> 레벨이 카메라오브젝트를 갖고있을떄, 렌더매니저가 들고있던 메인카메라의 시점으로 렌더링해서 우리가 그 화면을 보고있는데
                  원래는 레벨의 정지, 플레이, 퍼즈 상태를 구분해놓고 play상태 돌입하자마자 카메라 우선순위에 맞춰 렌더매니저에 등록해놓고 최우선 카메라 오브젝트 시점으로 화면을 렌더링한다.
                  지금은 카메라 우선순위 설정하자마자 렌더매니저에 카메라를 바로 등록하는데 이는 잘못된것이다. 그냥 변수하나에 본인의 우선순위를 기록만 해놓고
                  레벨이 play상태가 되는 순간에 비로소 카메라들을 렌더매니저에 등록해야함. 카메라의 begin()함수에서 렌더매니저에 등록시켜야한다.
                  이 begin()함수가 바로 레벨이 play되면서 시작하는 순간에 할일들을 기술한 것이다. 생성자에서 하면 되지 왜 begin()에서함? 이러면서 헷갈려하는 사람도 있는데,
                  엄연히 다름. begin()을 만든의도가 레벨이 stop상태일때 실행되면 안되고, 레벨이 play싱태일때 해야할 일을 구분해서 시행되어야할때 쓰인단말임

                  RegisterCamera()함수를 SetCameraPriority()함수에서 CCamera()의 begin()에 옳겨놨다.
                  SetCameraPriority()함수는 원래 카메라의 우선순위설정후 바로 랜더매니저에 등록하는 기능이었는데 이제는 (오늘 카메라 클래스에 새로 추가된) 맴버에 우선순위상태를 저장만하는 용도로 동작이 변경됬따.

                  begin()함수에서 카메라들이 랜더매니저에 등록되면 카메라 우선순위에 맞게 렌더링되는 구조가 됬다.

 - 우리가 이제 화면을 제대로 볼수 없기 때문에 렌더링이 안될것이다.( 다만 level의 begin()을 강제로 호출하면 잘 됨) 이제 에디터용 카메라가 필요하다  


** CEditorObjMgr
  - 레벨에 속해있지 않으면서 imgui처럼 실제 발매되는 게임에는 없어져야할 객체다. 레벨이 play상태가 아닐때 동작할 기능들이 들어가게된다.


 - CGameObjectEx 클래서
  - CEditorObjMgr  전용 오브젝트.
  - 어떤 레벨이나 레이어에 속해있지 않는 오브젝트들은 finaltick()이 동작하지 않을 것이므로 이 finaltick()을 재정의 해줘야한다.
    에디터매니저용 오브젝트 클래스가 따로 필요한 것이다.
  - CGameObject를 고대로 상속하면됨 오브젝트이긴 오브젝트인에 에디터매니저에서 쓰이는 오브젝트들의 finaltick()같은거 재정의 하려고 한것이므로.
  - 기존 오브젝트의 finaltick() 코드 복붙하고 조금씩수정한다.
   - 레이어 인덱스 등록하는 부분뺴버림,
   - 툴용오브젝트들은 dead 될일이없음 그냥 껐다 켯다의 개념은 있어도. 그래서 IsDesd()검사하는 부분도 삭제.


 - #define _RELEASE_GAME 코드가 주석처리 안될때가 imgui와 에디트매니저가 실행됨
                                주석처리 되면 imgui와 에디터매니저가 안보임
   이런 구조를 적용하려면 #ifdef _RELEASE_GAME 
                          #endif
   사이에 EditorObj와 imgui관련 코드들을 적어주면됨.

   발표할때 주석처리된 #define _RELEASE_GAME 플래그를 주석 풀어주면됨


============================================================================================================

 - 진도가 빨라서 오늘한거 등등을 다시 짚겠다
  
 - 현재구조는 레벨 사전설정이 완료되고 레벨의 begin()을 강제 실행하는데 나중엔 begin()버튼 눌러야 (== level이 play 상태가 되야) 레벨의 begin()이 시작되게 할거임
   지금은 그냥 프로그램 실행하잠자 바로 레빌이 play상태.

 - 지금은 레벨이 하드코딩으로 되어있는데 원래 시작할떄 레벨은 텅 비어있어야 된다. imgui같은걸로 작업후 save하면 프로그램 다시 실행시 save한 파일을 분석해서 재현하는 식이 되야함
   레벨이 play 모드일땐 save 기능이 동작되선 안됨
   게임 save 모드와 레벨 save 모드는 다르다. 게임 save는 게임의 진행정보를 저장하는 완전 별도의 기능인 클라이언트 컨텐츠다. 레벨 save는 레벨을 구현한 정보를 저장하는 기능이다

 - 부모오브젝트가 있는 오브젝트들은 추가 회전을 하는데 구현이 살짝 잘못됬다.
   
 - 완성된 레벨
