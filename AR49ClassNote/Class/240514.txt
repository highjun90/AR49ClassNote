 
 - 오늘 그림자는 판정만 끝나면되고 테셀레이션 들어갑니다.

 디렉셔널라이트인 경우에는 자기쪽 카메라의 뷰행렬곱을 MAT_!에 곱해놓고 렌더링 들어갔었죠?
 광원의 시야로 얘를 가져가 봤는데 g_tex_2에서 내가 저쪽에서 투영되어 있는 위치 값이랑 비교를 해야죠
 투영좌표계는 가로세로 -1 ~ 1 공간이죠.
 UV는 전체 범위가 1인데 투영좌표계는 2잖아요 그걸 UV기준으로 바꿔주기위해서 0.5 곱해줄게요. 그럼 -0.5 ~ 0.5 범위가 되겠고
 거기에 0.5를 더해주면 UV 좌표계처럼 0~1사이 값이 됩니다. 이게 투영좌표계에서 UV값으로 전환하는 방법이죠

 - light.fx
  첫번째 인자 x값은 vLightProjPos.x * 0.5 + 0.5 <- 이게 UV좌표계 변환이고,
  두번째 인자 y는 1에서 빼주는이유가 y값은 반전시켜줘야 UV좌표계랑 일치하잖아요. <- 확실하게 이해못함 아마도 투영좌표계는 위쪽이 + 고 UV좌표계는 아래가 + 니까 그걸 반전시켜준거 인듯
  
  이걸로 fDepth 값을 구하는거죠 g_tex_2에 저장된 광원카메라 깊이 텍스처를 샘플링해서.
  fDepth = g_tex_2.Sample(g_sam_0, vShadowMapUV).x; <- 이게 광원깊이텍스처에서 가져온 깊이값입니다.
  하필 x값만 가져온 이유는 애초에 쉐이더에서 32비트 공간만써서 float4의 x값만 써도 충분히 깊이값 저장했었잖아요 쉐이더에서도 리턴값을 x에만 담아서 리턴했고요 어제했죠. shadowmap.fx에서.

  - 실수의 오차때문에 fDepth 에 오차를 0.001f 까진 허용해주는 걸로 해서 0.001를 넘어서야 그림자다라고 판정할게요.
    이 0.001값 같은걸 매직넘버라고 합니다. 보통 쉐이더 분석할때 이 매직넘버도 잘 보셔야해요 결과값 분석할때 확실히 영향 미치니까요.

  - fShadowPow는 갑쇠비율입니다 내가 그림자가 지는 픽셀이라면 이 비율만큼 약해지는겁니다.
    
    if( fDepth + 0.001f < vLightPos.z / vLightPos.w  )

    위 코드가 참이면 이 픽셀은 그림자 영역에 있는 놈, 아니면 그림자 영역에 있지 않은 놈이다.

    if문을 분석하자면, vLightPos.z는 이 픽셀이 광원카메라 좌표계로 이동했을때의 값, 즉 월드좌표계에 있던 픽셀이 광원시점의 투영행렬까지 곱했을때의 값이다.
    여기에 w를 나눠줘야 진짜로 이 픽셀의 광원시점에서의 깊이값이 나온다. (메인카메라 시점이 아니라!!)
    그 깊이값이 fDepth 보다 크다는 의미는 곧,
    어떤 물체 뒤에 이 픽셀이 존재한다는 의미이고,
    이는 이 픽셀은 그림자 영역에서 존재한다는 말이다.

  
  && 첫번째 문제점) 선생님이 그림자 안지고 스피어 전체가 어두워 지니까 어디서 연산 잘못됬는지 확인하려고 비주얼스튜디오의 파이프라인 디버그 모드로 확인중이셨음
     선생님왈 왜 스피어가 다 그림자 영역으로 판정되지? 라며 의구심을 품는중

     일단 광원깊이타겟 클리어 하는거 해줄게요. 얘는 ClearRT가 아니라 Clear해줄게요 얘는 자체 ??(타겟?)을 가지고 있으니까" <- 이 ??가 뭐지..
     Clear 했더니 그림자 잘 나오네요 스피어 전체가 안까메지고 딱 그림자 생겨야 할 영역에 그림자 나오죠. 클리어를 안해줘서 그랬구나 

     -> 결론 -> 광원깊이텍스처 clear 안해주면 깊이값이 계속 누적되서 다 까메질수도 있다.

     두번째 문제) 그림자에 계단현상이 생김. 그림자 자글거리는 이유는, 해상도를 아무리 높게 잡았어도 검사하려는 픽셀이 너무 멀리 있어서 
                  마치 컴퓨터에서 이미지 계속 끝까지 확대하면 픽셀계단현상 보이듯이 어떤픽셀들은 그림자판정으로, 바로 옆픽셀들은 그림자 없는 판정으로 뭉탱이로 판정되는 영역이 존재한다는 말이죠
                  이건 광원깊이텍스처의 해상도가 높을수록 그림자 계단현상이 줄어들긴하지만 근본적인 해결법은 아닙니다.

                  라이팅할때 그림자까지 동시에 계산하죠? 원래 이러면 안되요. 원래는 어느지점에 그림자가 들어갈지 따로 판정하는 MRT를 따로 만들어야해요.
                  근데 얘도 어쨌든 계단현상으로 그림자 영역그리라고 기록될거란 말이죠 얘를 블러처리해주고, 그 블러처리 해준 그림자 영역으로 빛을 계산해야합니다.
                  즉 우리가 지금까지 한 과정에 중간과정이 하나더 있어야 저렇게 계단현상이 안생긴다고요 그 중간과정이 계단현상을 부드럽게 처리해주는거고요"

                 ->이거 어떻게 해결했는지 까먹었다 정리하다가.. 수업진짜 개빠르네;; 어쨌든 계단현상 고치셨다.

  $$ 자 또 세번째문제. 스피어의 뒷면까지 그림자 판정을 받아요. 환경광은 그림자 판정을 받으면 안되죠. 코드를 좀 수정할게요
     
     결론 -> 최종 광원 세기 계산할때 환경광을 나중에 처리하는?? 방식으로 <- 정확하지 않음 코드봐야함 어쨌든 환경광을 나중에 어떻게 한다고하심

      네번쨰 문제. 광원이 보고있는, 직교투영 범위를 벗어난 물체는 그림자 처리를 어떻게 해야할까요?
      자 직교투영범위 밖에 있는 픽셀를 검사하려고 하면 UV좌표값이 1 넘어가겠죠? 
      UV 설정을 램모드 즉 반복패턴으로 설정했기 때문에 설령 실제픽셀 앞에 물체가 없었더라도 거기에 매칭되는 UV에는 값이 있었다면 판정은 아예 있지도 않은 물체의 그림자가 있는걸로 판정될 수 있다는말이죠.
      따라서 UV값을 넘어가면 아예 그림자 검사 안하도록 합니다.

      결론 -> 쉐이더코드상에서 UV값 벗어나는건 그림자 검사 안하게 if 조건문에 추가했습니다.

      다섯번째 문제 그렇다고 두번째 문제 해결법으로 직교투영 범위 넘어간애들은 아예 그림자 검사 안해서 이상한 그림자 안지게 까지 한건 좋은데, 그렇다고 광원 범위 넘어간 영역에 잘 보이던 그림자가
      안생기면 그것도 어색하단 말이죠? 
      이거는 광원이 카메라를 따라오도록 하는걸로 해결합니다.
      아니면 월드가 너무 넓다면 애초에 그림자 판정하는 광원깊이텍스처를 여러개 두고, 그림자 판정검사하는 픽셀의 월드좌표값을 보고 어느 광원깊이텍스처에 매칭시킬지 판정하는거죠.
      월드가 크다면 이 방식을 사용하셔야 할겁니다. 광원따라가는건 연산량 미친듯이 증가해서 프레임 저하될수도 있거든요. 그럴바에야 구역나누고 구역마다 광원깊이텍스처를 따로 두는게 낫다는거죠.

      결론 -> 이건 선생님이 구현안해줄거임 나중에 할...지도?
 
  - 자 여기까지 그림자 기초적인 틀을 완성시켰습니다. 나중에 체크해야할것은 3D애니메이션 할떄, 캐릭터가 로컬스페이스에서 움직이거든요? 로컬에서 움직인걸 월드에 배치한단말이죠?
    원래 캐릭터 리소스들은 디폴트로 T자로 팔벌려 있는 모습이 있단 말이죠? 
    이때 막 캐릭터는 움직이는데 그림자는 T자 모양으로 고정되어 있습니다. 
    이건 광원깊이텍스처에서 깊이값 미리 저장할때 T자 모양으로 서있을때를 기준으로 깊이값을 저장해 놓아서그래요.
    즉, 애니메이션 단계까지 갈때쯤이면 여러분이 그림자 관련 코드를 수정해야한다는 말입니다.
    실시간으로 애니메이션 물체의 깊이값을 광원깊이텍스처에 계속 최신화 해주어야 검사받는 픽셀들도 애니메이션 움직이는거에 맞춰서 판정받는다는 말입니다.
    지금 제가 구현한거 수정안하고 애니메이션의 그림자를 보면 항상 T자모양만 그림자 모양으로 나올겁니다.

    미리 말씀 드리자면 제가 따로 그림자 고쳐주는거 안해줄겁니다 여러분이 알아서 하세요.


  - 지오메트릭 쉐이더는 다이렉트10에 추가됬구요, 헐과 도메인쉐이더 합친 테셀레이션은 다이렉트11에 추가됬고 우리가 이걸 지형에 적용시켜볼게요
    쉬었다가 다음교시에 계속합시다.


209
====================

  - 플레이어 오브젝트를 좀 바꿔볼게요. Plane으로,
    그리고 Sphere를 Rect로 교체.

    테셀레이션의 기본적인 문법을 알아야되니까 재질을 std3d_DeferredMtrl 쓰지말고 딴거써볼게요

  - tess.fx 테셀레이션파일
   - 세이더 형식 셰이더 모델 설정해주고
   - 테셀레이션 함수는 우선 포워드시점에서 그려주는 쉐이더로 설정할게요
     우선 이게 제대로 동작되는지 화면에 띄워놓고 차근차근 수정해봅시다.

  - 에셋매니저 init, Tess Shader 정의
   - 도메인은 오페이크(불투명) 레스터라이저모드는 WIRE_FRAME 으로 해놀게요.
   - Mtrl 까지 정의하고

   - 이걸 그대로 출력하면 사각형 선들 마젠타색으로 나오는거 확인할수있죠.

 - 자 오랜만에 파이프라인 이미지 봅시다.
   
   우리는 헐쉐이더와 도메인쉐이더는 작성할수있고요, 그사이에 있는 테셀레이터 스테이지는 못건듭니다 얜 고정이에요.
   - 테셀레이터 스테이지: 정점생성
   - 헐쉐이더 : 정점이 어떻게 생겨날지 계수전달.
      ** 복습 - 토폴로지 : 위상구조, 정점의 상태와 구조        
    
   테셀레이션은 전용 토폴로지가 따로있습니다. '3개의 제어점이 있는 패치리스트' 라는 토폴로지에요
   패치는 조각, 덩어리 라고하고요 이때의 패치는 삼각형을 말합니다. 즉 패치 하나가 삼각형 하나죠.
   기존의 삼각형 토폴로지에 대응한다고 이해하시면 됩니다. 컨트롤 포인트는 3가지 면?을 말합니다.

   정점쉐이더는 사각형 메쉬니까 6개가 정점쉐이더에서 헐쉐이더로 넘어가겠죠?
   그걸 헐쉐이더는 3개씩 끈어서 하나의 패치로 여깁니다.

   그리고 patch constant function 이라고 해서, 패치당 한번씩 더 호출되는 함수가 있어요 패치를 구성하고 있는 애들당 한번씩 호출되는 얘가 이놈입니다.
   패치별로 분할 횟수를 지정하는거죠. 이걸 테셀레이터에 토스하면, 내가 요청한 만큼 정점 만들고,
   도메인쉐이더가 이렇게 원래 정점과 테셀레이션에서 만든 애들 일일히 다시 정점쉐이더처럼 작동합니다. 즉 도메인쉐이더는 정점쉐이더랑 같다고도 볼수있죠.
   차이점은? 도메인 쉐이더는 

   버텍스 쉐이더는 사실 할게없어요. 그럼 테셀레이션만 쓰고 정점쉐이더 안쓰면 안됨? 이론상 맞는데 정점쉐이더는 꼭 쓰라고 시스템 적으로 강제했어요.

   지오메트릭 쉐이더는 그렇게 도메인쉐이더에서 처리한애들을 또 분할하는거에요 따라서 테셀레이션과 지오메트릭쉐이더를 둘다 쓰는 일은 거의 없고요
   좀 간단한 처리는 지오메트릭 쉐이더, 복잡한 처리는 테셀레이션을 보통 채택합니다.
   둘다 쓴다는 말은 정점 분할을 두번씩이나 한다는건데 굳이..? 라는 생각이 들긴합니다.

   보통 지형의 디테일을 잡을떄, 플레이어로부터 거리가 멀어지면 테셀레이션 레벨이 낮아지고, 가까울수록 테셀레이션 레벨이 높아지는 방식을 씁니다.
   그래서 막 어쌔신 크리드 할때 보면 플레이어가 배타고 섬가까이 갈때 가까이 갈수록 막 매끈한 돌이 갑자기 울퉁불퉁해지고 이런 현상을 볼수있어요 이게 테셀레이션을 거리에 따라
   적용한 겁니다.

 - tess.fx
  - 도메인쉐이더의 리턴값이 픽쉘쉐이더에 들어가고, 정작 정점쉐이더는 헐쉐이더로 들어갈겁니다.
  - 헐쉐이더는 총 2개의 함수로 구현되야 합니다. 그런데 우리 쉐이더만들때 함수 하나만 받는데 이거 어캐함?
    fx 파일에 디스크립션 정보를 넣어줘야함.
    
    헐쉐이더 디스크립트 문법
    [patchconstfunc("PatchConstFunc")] 이거해주면 두개 묶어서 컴파일해줌
    [outputtopology 어쩌구 ] 요런거 일일히 암기하지마세요 마소 MSN가서 참고하세요
    분할도 최대 제한치를 적어줘야해요 저는 64로 할게요
    partioning 분할방식인데 정수방식과 실수방식이 있어요 실수방식은 되게 자연스러운 방식이 가능합니다.
               막 3.4분할 이러면 패치의 한면을 비율에 맞게 분할하지 않겠죠?
               정수는 딱딱 끊어지게 분할합니다. 저희는 일단 정수방식 분할로 설정할게요.
    
  - vPos 를 SV_Position에 매핑하면 안되죠 그냥 POSITION에 넣어줘야합니다 SV_Position은 이제 도메인 쉐이더가 쓰는거에요 픽셀 쉐이더에 넘기는 얘가 도메인이 되여야하죠 정점쉐이더가 아니라.
  
  - 첫번째 인자로 한 패치를 구성하는 정점들을 전달하고, 두번째로 입력으로 정점 3개가 들어왔지만, 그 3개 정점중에서 그 애들을 구분할수 있는 인덱스값을 전달합니다.
    헐쉐이더에 정점 본인과, 본인이 속한 패치의 다른 정점들를 항상 묶어서 전달하는 이유는 패치 모양을 바꾼다거나 다른애들의 방향벡터를 참고한다던가 잘 안쓰긴합니다만 혹시 몰라서 패치단위로 묶어서 보내는 겁니다.
    착각하시면 안되요 이 헐 쉐이더 함수는 오직 정점하나에 대해서만 연산합니다 같이 전달한 다른 패치의 정점들도 함꼐 계산하는게 아니에요
    헐쉐이더는 모든 정점마다 한번씩 호출되고, 패치상수함수는 패치단위로 호출됩니다.
    즉 우리가 지금 3개 정점을 묶어서 패치로 여기니까 패치상수함수는 헐쉐이더보다 1/3 정도 덜 호출되겠죠


  - 이렇게 보니까 헐쉐이더 하는게 없죠? 그냥 정점쉐이더에서 받은거를 그냥 테셀레이션에 전달하네요.
    자 중요한건, 얘랑같이 묶인 함수인 PatchConstFunc()입니다. 얘가 일을하는겁니다.
   
    모서리와 내부를 몇분할 해야되는지 설정합니다. 우리 설정대로라면 하나의 삼각형은 총 6개의 삼각형으로 분할될테고, 패치대로 정점 3개씩, 도메인에 가면 총 18번 호출되겠죠 


 - CGraphicsShader.cpp -> CreatHullShader(), CreateDomainShader()정의.
  - 다른 쉐이더 만들때랑 큰 틀은 비슷해서 복붙하고 조금 수정하면됩니다.

 - 에셋매니저 init 돌아와서 Tess Shader 정의하는 부분으로 와서
   CreateHullshader() 새로 적어주도 중단점 적어볼게요

   와 버그가 막 존나 많네요 스펠링 많이 틀릴걸로 예상하긴했는데

   && 에러창 뜨면 뭐가 오류인지 다 알려줌 선생님 그거보고 대문자소문자 고치고 등등함. 








210
