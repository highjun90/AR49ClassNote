1.  카메라 움직임구현하기
 % 플레이어 움직임을 방향키로, 카메라를 wasd로 바꿈
 - 월드스페이스 변환행렬은 그대로 있고 거기에 단지 뷰스페이스를 곱해주면 그것이 바로 카메라 기능이 적용된 화면이다.
   다시말하지만 뷰스페이스 곱하지 않으면 그냥 월드스페이스의 원점에 카메라가 있는 모습이 화면에 나온다.
   또한 뷰스페이스를 곱하더라도 카메라 원점이 월드스페이스 원점과 똑같다면 뷰스페이스 곱하나 마나 월드스페이스와 다를게 없는것이다.

 - 카메라에는 카메라의 원점 정보 뿐만아니라 이제는 투영 방식에 대한 정보도 들어간다.
   직교투영과 원근투영.
    ** 뷰스페이스와 투영행렬은 같은 행렬에 정보가 포함되어있지 않고 따로 분리된 행렬에 있어보인다

** 다시) 투영행렬은 일정 범위의 공간을 NDC 좌표계로 쑤셔넣는 것이고 방식이 두가지다.(직교, 원근)
         
   A1. 이런 방식을 채택한 이유는?
         

 - NDC좌표는 정규화된 좌표계지만 실제 화면은 비율이 다양하다. 
   물체를 NDC좌표계에 매칭 시켜야 레스터 라이저에서 그걸갖고 픽셀영역을 정할 수 있으니 화면 비율에 따라 
   물체를 NDC 좌표계에 비율에 맞게 넣어준다.
  
 - 실제 화면과 실제 게임의 1픽셀과 일치하도록 XMMatrixOrthographicLH() 함수의 첫번째 인자에 우리 화면의 해상도와 동일하게 설정한다.
 - 종횡비는 가로 나누기 세로. m_AspectRatio. 1280x768 기준 1.666666...
 - XMMatrixOrthographicLH() 두번째인자는 종횡비고 세번째 인자는 월드스페이스에서 투영의 대상이 되는 깊이범위이다. 현재 기준 1~10000 사이로 설정했다.
 
 - 다시) 정해진 영역을 NDC좌표계에 압축하고 레스터라이저가 그릴 픽셀영역을 지정하고 그걸 실제 화면 해상도로 확대한게 우리가 실제보는 화면

2. 이제 원근투영을 만들자
 - 함수 XMMatrixPerspectiveFovLh()
   각도까지 이용해서 near, far 범위 내의 공간을 NDC 좌표계로 투영한다.
   첫번째 인자가 FOV(각도), 두번째가 종횡비, 그리고 near와 far. 

 - 직교투영에서만 m_Scale을 쓴다. 이것은 카메라가 투영하는 범위의 확대축소를 담당한다. 첫번째인자인 픽셀영역에 곱해주게된다.
   크기가 똑같은 물체라도 투영하는 범위를 확대하면 물체가 작아보일테고, 반대로 투영범위를 좁히면 실제화면에서는 물체가 커보이게된다. 줌인 줌아웃효과인 것이다.
 - 직교투영의 m_Scale과 비슷한 용도가 FOV이다. (filed of view) 단지 투영범위를 가로세로크기가 아니라 각도로 정할 뿐이다 
   게임에서 대쉬할때 화면이 확 땡겨지는 효과. 폭발효과 등 시야의 왜곡. 다이나믹효과. 타격감 효과 등등. 이펙트와 소리만으론 밋밋해서 이런 효과를 쓴다

3. 뷰행렬 디테일 채우기
 - 지금까지는 뷰스페이스에 이동정보만 적어놈. 그런데 카메라가 항상 바라보는 방향이 z축일리가 없음. 카메라가 딴데를 바라보고 있으면 z축을 바라보게 회전시켜야 화면에 의도한대로 
   보는방향대로 장면이 출력될것임. 따라서 카메라가 z축만 바라보면 회전변환은 필요없지만 만약 z축과 일치하지 않는 곳을 바라보고 있다면 z축을 바라보게 회전변완이 필요하고,
   당연히 물체도 카메라가 회전함에따라 회전 당하게 된다. 2D게임의 경우 거의 대부분 카메라가 z축을 보고있어서 카메라의 회전변환을 하는 경우가 많지는 않지만
   회전변환을 직접 유도해볼것임

  - 카메라도 transform 컴포넌트가 있고 거기에 방향벡터(right, up, front)가 있음. 각각 x축, y축, z축에 일치한게 디폴트상태이다. 
    이 상태에서 y축회전하면 카메라의 front와 right는 변한다. 이것을 우리는 원래형태인 단위행렬을 나오게 해야한다.
    다시말해, 최초 카메라는 방향벡터들이 단위행렬 형태로 존재한다. 그것의 방향이 변했을때 어떤 매트릭스가 있을것이고, 그 매트릭스를 곱해서 단위행렬로 만들어야 한다.
    이것이 역행렬이다. 항등원, 역원개념을 이용하자는 것이다.
    원래방향백터들의 매트릭스 (= 단위행렬)
      Right > [1 0 0]
      Up    > |0 1 0|
      Front > [0 0 1]                 
    행렬을 구성하는 각요소가 90도를 이루고 있으면 직교행렬이라고 하고, 이것은 역행렬을 구하기 쉽다. 원래 역행렬 구하는건 엄청 복잡하다. 
    How? 직교행렬은 전치시키면 그게 역행렬이다. 즉 직교행렬은 전치행렬이 곧 역행렬임.

    직교행렬은 자기자신과 내적하면 무조건 1나오고, 다른 벡터와 내적하면 무조건 0이 나온다.
    why? 내적한다는 것은 각요소를 곱해서 그 결과를 취하는 것이고, 공식은 A * B * Cos 이다. 그런데 만약 B가 A라면(자기자신을 내적) Cos은 1이된다.(각도가 0) 게다가 벡터 크기도 1임 그래서 1x1x1 이되고 결과도 1임
         게다가 다른 벡터는 다 직교행렬이라 했으므로 Cos은 0임(90도) 0을 곱하니 무조건 0나오는것임
         직교행렬에 전치행렬을 곱하면 단위행렬이 나올수 밖에 없다.

*** 카메라는 이동이 먼저고 회전이 나중이다. 월드스페이스 다르다!
    이유-> 오히려 뷰스페이스에서는 이동을 먼저하는게 허수를 제거하는 효과가 있다. 이미 시작부터 원점에서 시작하는게 아니기때문에 허수가 있는 상태임. 
    (카메라 위치를 원점으로 만들기 위한작업부터 해야 허수값을 뺄수있다는 것임 월드스페이스 원점과 혼동하지 말것 지금 우리는 월드스페이스 원점에서 카메라를 원점으로 만들고 있음) 
**** 여기까지 4행은 이동정보, 1열이 Right 2열이 Up 3열이 Front 의 정보를 갖게된다.
     뷰스페이스 형태)
       Rx Ux Fx 0
       Ry Uy Fy 0
       Rz Uz Fz 0 
       Mx My Mz 1
       (M은 Move 이동정보)

A2 벡터의 내외적

 - 이제 w를 누르면 카메라가 front 방향으로 이동한다. 월드스페이스의 front가 아니라 카메라기준에서의 front방향이다.

*** 마우스 우클릭하고있을때만 마우스로 카메라 회전시키기 기능이 동작하게 만들어놈2

