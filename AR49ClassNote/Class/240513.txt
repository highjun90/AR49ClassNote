
 - 그림자 하고있었죠 아직 그림자 안나오고있어요.
 - 그전에 수업 공지 할게요
  - 현재 자습실은 강의실로 바뀌고 상담실쪽 앞이 자습실로 꾸며질겁니다. 공사 정확하게 들어가면 알려줄게요
  - FPX로딩, 3D Animation, Instancing은 수업하는 의미가 없어요
    FBX 로딩은 3dMAX에서 제공하는 코드거든요? 코드는 엄청 많긴하고 걔네가 쓰는 압축방식을 이해해서 이미지데이터들을 추출해서 
    오토데스크 사이트 들어가면 지들이 만든 코드를 뽑아내는 라이브러리를 제공해요. 그걸 제가 잘 가공해서 수업에 진행하는데 
    
    완성된 기능을 몇가지 핵심만 설명할거고요.
    여러분들이 목숨걸고 해야할거는 빠른시간안에 회사의 프로젝트의 코드를 분석해야해요.
    3개월 수습에서 안끝나려면 주말에 나오지 말라 그래요 회사 코드 일주일 지나도 파악못하면 회사에서 좋던 사람들 다 돌변해요.
    어떻게 애네들이 돌아가는지 큰 틀만 설명할겁니다 한줄한줄 설명하지 말고 큰단위, 함수단위로 설명할거에요

    그리고 숙제내줄건데 당연히 코드를 다 이해해야겠죠.

    코드 리뷰방식으로 수업방식을 바꿀겁니다. 

    이때부터는 온라인 수업을 열겁니다.
--------------------------------------------------------------------

 - 그림자는 light component에서 진행하고 있었습니다.

 - 광원시점에서 물체들을 볼꺼니까 카메라의  m_vecShadow 에 모을겁니다.
   얘네는 쉐이더 도메인이 중요하지 않다고 했어요 단지 보이냐 안보이냐만 중요하다고 했죠.

 - CCamera::SortShadowMapObject()
  - 광원카메라는 31 레이어를 제외한 모든 레이어를 다 찍는다고 했어요
    메쉬 재질 쉐이더가 다 있는 애들만 m_vecShadow에 pushback 하면 그림자 오브젝트 분류는 그냥 끝난거에요.

 - CCamera::rednder_shadowmap()
  - 분류해놓은 그림자 생성 오브젝트들(m_vecShadow)을 그리라는 함수.
  - 이떄 사용할 전용 재질이 필요합니다. 
  - 해상도가 8192인 텍스처(쉐도우맵)에 깊이를 기록할 쉐이더가 필요합니다.
  - 물체가 메인카메라에서 그려질때의 재질과 메쉬가 있을텐데, 광원카메라 기준에서의 재질은 따로 있어야겠죠 깊이값만 저장하는 재질. 단, 메쉬는 메인카메라에서 쓰이는 메쉬와 공유해서 쓰면됩니다.
    광원에서 보더라도 형태는 같아야 하니까요. 
    
    (오브젝트의 컴포넌트로 렌더컴포넌트가 있는데, 그 렌더컴포넌트에서 세팅해놓는 메쉬와 머터리얼은 메인카메라에서 쓰이고,
     광원의 카메라에서 쓰일 재질과 메쉬는 따로 있어야하는데, 메쉬는 메인카메라랑 똑같이 쓰고 재질은 따로 구현해야한다는 말임)

  - shadpwmap.fx
   - 쉐도우 뎊스 맵의 약어인듯?
   - 픽셀쉐이더에 픽셀좌표의 투영좌표계에 보간된 값의 좌표와 xy해상도상의 픽셀위치 값을 따로 보냅니다.
   
   - Vz 뷰스페이스의 z 
     Px Py Pz 프로젝션 상의 xyz값.

     자 투영좌표계에 전달한 값은 실질적으로
     (Vz * Px, Vz * Px, Vz * Px, Vz)
     라고 했죠 투영행렬 곱하면 그게 최종 투영행렬의 좌표값아닌가? 라고 착각하면 안된다고 했죠. w (Vz)를 한번 나눠야 그게 진짜 투영공간의 좌표값입니다. 이거 수업 초반때부터 설명한 이론인데
     진짜 끝까지 써먹죠?
     우리는 정점쉐이더에서 전달받은 저 투영행렬 곱한 값에 z값(깊이값)만 원해요. 
     z값에 w나눈 값을 리턴하면됩니다 나머지 xy값은 알빠노입니다. 필요없어요.

     따라서 vOut에 z값만 딱 하나 담아서 리턴합니다. 오직 깊이값만 리턴하는거죠.


 - ShadowMap 전용 도메인 만들기. 렌더링 파이프라인 상관없이 광원시점에서 그릴때만 사용됨

 - CAssetMgr_init.cpp
   ShadowMap Shader정의하기, 
   shadowMapMtrl도 정의하기.
   정의할때 속성 잘 봐둘것 진짜 설명 설렁설렁하고 마치 다 알지? 이러는듯이 넘어감..

 - 카메라::render_shadowmap()
  - 우선 글로벌 뷰 프로젝트 행렬을 광원 기준으로 바꿔주고
     m_vecShadow에 저장된 오브젝트의 트랜스폼 업데이트하고(이때 맨처음 글로벌 행렬들 광원기준으로 세팅해서 알맞게 잘 되겠쬬)
     쉐도우전용재질 업데이트하고
     최종적으로 렌더컴포넌트의 메쉬보고 렌더하라고 하면 깊이값 저장 끝날겁니다.

    ** 자 다시 강조하지만 우리는 지금 해상도 8192 텍스처에 광원 시점으로 물체들의 깊이값을 저장하는 걸 하고있는겁니다. 
    && 광원시점의 뷰 프로젝트 행렬은 언제 어디에 세팅해놔서 글로벌 행렬로 대입시켰더라?

 - 스카이박스 문제가있어요. 뜬금없는 스피어 박스가 보일겁니다 광원 깊이 텍스처에. 
   우리는 스카이박스 메쉬를 쉐이더에서 가라쳐서 메인카메라에 확장시켜서 보이게 해놨지만
   실제론 중앙에 작은 메쉬가 있죠? 그 깊이값이 광원카메라에 기록될텐데 그런걸 예외 처리해야겠네요.

   따라서, 렌더컴포넌트에 기능하나를 추가할게요. 맴버로 m_DynamicShadow 추가.
   동적그림자를 그릴지 말지 알려주는 bool 값입니다. 모든 렌더컴포넌트는 이게 기본적으로 true로 생성자에서 세팅될텐데
   스카이박스는  생성자에서 SetDynamicShadow(false)로 해놓습니다.

   자 그럼 카메라.cpp에서 m_vecShadow에 들어갈 물체들인지 판단할때 메쉬 재질 쉐이더 세팅된 애들만 벡터에 push 시키는 부분에서 조건하나 더 추가합니다.
   바로 m_DynamicShadow가 true 인지 아닌지.
   스카이박스는 이게 false기 때문에 m_vecShadow에 안들어 가겠죠 그러면 최종적으로 광원의 깊이 텍스처에도 안그려질거고요.
   만약 스카이박스 깊이값이 기록되면 중앙에 알수없는 똥그란 그림자가 그려질거에요. 

 - 광원카메라는 픽셀 1만 범위로 했는데
   원래 직교투영 소스코드는 그 m_width를 적용안하고 있었음 그냥 해상도 범위만 찍게했음
   이제 카메라 생성자에서 w_width에 기본적으로 해상도를 세팅해 놓게 하겠음 
   




 && 비주얼 스튜디오에서 파이프라인 디버그 하는 화면 어떻게 띄우는거지..
    채널 히스토그램
    이벤트목록
    이벤트 호출스택
    파이프라인 단계
    픽셀기록
    속성

    뷰:GPU작업



 - 정리 : 
   
   이번 수업시간에 한건 거의 다 정확하게 이해는 못하고 대충 감만 잡았음

   1) 그림자깊이 쉐이더에서
      정점쉐이더에서 전달하는 두 좌표값(뷰프로젝션 곱한값, 그냥 포지션값)은 정확히 뭔가? 곱하는 뷰프로젝션이 메인카메라인가 광원카메라 기준인가?
      그리고 그냥 포지션값은 정확히 무엇인가? 

      이 쉐이더의 최종 목표는 어쩄든 8192 해상도 텍스처에 물체들의 깊이값을 저장하는것이다. 이걸 감안하고 분석해야한다.

      


(push 안함)
===============================================

 - 너무 수업초반에 설명해서 기억못할 수도 있는데 
   디바이스로 가보면 마지막에 뷰포트 설정이 있어요.
   이거 설명할떄 뭐라고 했다면 이때 뷰포트 설정할때
   
   처음부터 윈도우에 보내질 뷰포트영역을 고려해서 레스터라이저가 렌더타겟에 픽셀영역을 잡습니다.
   우리해상도랑 뷰포트설정이 동일했기 때문에 윈도우창에서도 화면전체영역을 기준으로 레스터라이저가 NDC좌표계에서 렌더타겟 전체영역으로 매핑한겁니다.
   우리가 뷰포트 영역을 설정한다는거 자체가 윈도우창에서 보여질 전체영역을 설정한다는 의미인겁니다.

   다시말해서, 레스터라이저는 NDC좌표계에서 렌더타겟에 픽셀영역을 잡을때 무조건 렌더타겟 전제비율에 맞춰서 그리지 않는다고요 
   그럼? 뷰포트 설정에 맞춰서 렌더타겟에 그려질 영역을 잡는다는 말입니다.

   왜 광원의 깊이 텍스처가 중앙에 안있고 좌상단 끝자락에 그려졌는지 이해가 되시나요?
   광원깊이텍스처는 8192고, 윈도우해상도는 그보다 엄청 작잖아요. 한 1920이었나?
   그런데 뷰포트 설정은 윈도우해상도로 해놨죠?

   그럼 레스터라이저는 그 8192해상도에서 좌상단을 시작점으로 해서, 꼴랑 화면해상도만큼의 가로세로비율만큼 NDC좌표계에서 그려질 영역으로 확장합니다.
   그래서 좌상단에 깊이값이 쏠려서 보였던거에요.

 - 뷰포트 영역이 디바이스가 아니라 MRT안으로 들어가야합니다.
   why-> 윈도우 해상도와 렌더타겟 해상도가 다를때, 그 해상도에 맞춰서 뷰포트를 잡아줘야하기 때문입니다.
   OMset 할때 뷰포트를 화면해상도가 아니라 텍스처 해상도로 맞춰줘야한다는 말이죠. 원래는 모든 OM이 화면해상도로 고정적으로 뷰포트 세팅을 했죠? 
---------------------

 - 자 지금 그림자그릴 물체의 분류를 다시 복기해봅시다.

  분류1) 움직이는물체 안움직이는 물체 - m_IsDynamic >> 트랜스폼컴포넌트에서 알려줌, 움직이지 않는 물체는 실시간으로 그림자정보(깊이값)을 계산할 필요없이, 프로그램 시작시 딱한번만 계산하면 된다.
  분류2) 움직이는 물체 중에서도 그림자 그릴지 아닐지 - m_DrawShadowMap >> 렌더컴포넌트에서 알려주는거임, 내가 비록 움직이는 물체지만 안그려지길 원할때 false로한다.
                

 - CCamera::SortShadowMapObject() 에서 m_vecShadow 검사하는 if문을 조금 바꿔야한다.
  - 우선 트랜스폼한테 얘가 움직이는 물체인지 물어보고,
    렌더컴포넌트에서 얘가 그려지길 원하는 움직이는 물체인지 물어보고,
    메쉬, 재질, 쉐이더 있는지 물어보고
    비로소 m_vecShadow에 넣는거다
-----------------------------------------

 - 이제 디렉셔널라이트와 포인트라이트 모두 픽셀이 어떤 물체에 가려져서 그림자 영역에 있는지 고려할수 있음.
   그림자까지 연산에 포함시켜야하는거죠 그 정보를 알기위해서 재질에  TEX_2에 물체깊이값을 전달합니다.

 - light.fx
  - 앞서 계산한 빛 값을 최종 light MRT로 결과값 반환하기 전에 그림자까지 고려해야합니다. 
    지금 내가 계산하는 픽셀을, 광원카메라 좌표계로 이동시켜서 미리 저장해놓은 물체의 깊이값 텍스처(그 8192 해상도)의 똑같은 위치에 값을 비교해서,
    그 8192 텍스처에 어떤 값이 있었다면 이 픽셀은 물체에 가려진 놈이구나하고 판단하고, 빛의 세기를 더 약하게 설정하는거죠

    자 이론은 이렇고 실제로 구현해봅시다.
    메인카메라의 뷰역행렬을 곱하면 월드좌표값 나오겠고, 거기에 광원의 뷰프로젝트 행렬을 곱하면 픽셀이 광원카메라시점의 좌표계로 이동하겠죠?
     - CLight3D::render()
      - 그전에  MAT_1 자리에 광원카메라의 뷰프로젝트 행렬을 전달해 놓을게요 그래야 픽쉘쉐이더에서 메인카메라 좌표계에서 광원카메라 좌표계로 이동시킬수 있겠죠?

   자 이렇게 이동시킨 픽셀에서 UV값을 뽑아냅니다. 뽑아낸 UV




208